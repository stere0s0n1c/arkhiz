/*!
 * 
 * DO NOT OVERRIDE THIS FILE.
 * Generated with "npm run build"
 * 
 * ## Project Name        :  Uix Kit
 * ## Project Description :  A free web kits for fast web design and development, compatible with Bootstrap v4.
 * ## Project URL         :  https://uiux.cc
 * ## Version             :  4.4.4
 * ## Based on            :  Uix Kit (https://github.com/xizon/uix-kit)
 * ## Last Update         :  September 25, 2020
 * ## Created by          :  UIUX Lab (https://uiux.cc) (uiuxlab@gmail.com)
 * ## Released under the MIT license.
 * 	
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "38371489f9e020e8cb4a";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_selfInvalidated: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 			invalidate: function() {
/******/ 				this._selfInvalidated = true;
/******/ 				switch (hotStatus) {
/******/ 					case "idle":
/******/ 						hotUpdate = {};
/******/ 						hotUpdate[moduleId] = modules[moduleId];
/******/ 						hotSetStatus("ready");
/******/ 						break;
/******/ 					case "ready":
/******/ 						hotApplyInvalidatedModule(moduleId);
/******/ 						break;
/******/ 					case "prepare":
/******/ 					case "check":
/******/ 					case "dispose":
/******/ 					case "apply":
/******/ 						(hotQueuedInvalidatedModules =
/******/ 							hotQueuedInvalidatedModules || []).push(moduleId);
/******/ 						break;
/******/ 					default:
/******/ 						// ignore requests in error states
/******/ 						break;
/******/ 				}
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus(hotApplyInvalidatedModules() ? "ready" : "idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 		return hotApplyInternal(options);
/******/ 	}
/******/
/******/ 	function hotApplyInternal(options) {
/******/ 		hotApplyInvalidatedModules();
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (
/******/ 					!module ||
/******/ 					(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 				)
/******/ 					continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire &&
/******/ 				// when called invalidate self-accepting is not possible
/******/ 				!installedModules[moduleId].hot._selfInvalidated
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					parents: installedModules[moduleId].parents.slice(),
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		if (hotUpdateNewHash !== undefined) {
/******/ 			hotCurrentHash = hotUpdateNewHash;
/******/ 			hotUpdateNewHash = undefined;
/******/ 		}
/******/ 		hotUpdate = undefined;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = item.parents;
/******/ 			hotCurrentChildModule = moduleId;
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			return hotApplyInternal(options).then(function(list) {
/******/ 				outdatedModules.forEach(function(moduleId) {
/******/ 					if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 				});
/******/ 				return list;
/******/ 			});
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModules() {
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			if (!hotUpdate) hotUpdate = {};
/******/ 			hotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule);
/******/ 			hotQueuedInvalidatedModules = undefined;
/******/ 			return true;
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModule(moduleId) {
/******/ 		if (!Object.prototype.hasOwnProperty.call(hotUpdate, moduleId))
/******/ 			hotUpdate[moduleId] = modules[moduleId];
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(141)(__webpack_require__.s = 141);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _gsScope; });
/* unused harmony export TweenLite */
/* unused harmony export globals */
/* unused harmony export default */
/* unused harmony export SimpleTimeline */
/* unused harmony export Animation */
/* unused harmony export Ease */
/* unused harmony export Linear */
/* unused harmony export Power0 */
/* unused harmony export Power1 */
/* unused harmony export Power2 */
/* unused harmony export Power3 */
/* unused harmony export Power4 */
/* unused harmony export TweenPlugin */
/* unused harmony export EventDispatcher */
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */

/* ES6 changes:
	- declare and export _gsScope at top.
	- set var TweenLite = the result of the main function
	- export default TweenLite at the bottom
	- return TweenLite at the bottom of the main function
	- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)
	- remove the "export to multiple environments" in Definition().
 */
var _gsScope = typeof window !== "undefined" ? window :  true && module.exports && typeof global !== "undefined" ? global : undefined || {};
var TweenLite = function (window) {
  "use strict";

  var _exports = {},
      _doc = window.document,
      _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;

  if (_globals.TweenLite) {
    return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.
  }

  var _namespace = function _namespace(ns) {
    var a = ns.split("."),
        p = _globals,
        i;

    for (i = 0; i < a.length; i++) {
      p[a[i]] = p = p[a[i]] || {};
    }

    return p;
  },
      gs = _namespace("com.greensock"),
      _tinyNum = 0.00000001,
      _slice = function _slice(a) {
    //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++])) {}

    return b;
  },
      _emptyFunc = function _emptyFunc() {},
      _isArray = function () {
    //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
    var toString = Object.prototype.toString,
        array = toString.call([]);
    return function (obj) {
      return obj != null && (obj instanceof Array || _typeof(obj) === "object" && !!obj.push && toString.call(obj) === array);
    };
  }(),
      a,
      i,
      p,
      _ticker,
      _tickerActive,
      _defLookup = {},

  /**
   * @constructor
   * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
   * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
   * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
   * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
   *
   * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
   * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
   * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
   * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
   * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
   * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
   * sandbox the banner one like:
   *
   * <script>
   *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
   * </script>
   * <script src="js/greensock/v1.7/TweenMax.js"></script>
   * <script>
   *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
   * </script>
   * <script src="js/greensock/v1.6/TweenMax.js"></script>
   * <script>
   *     gs.TweenLite.to(...); //would use v1.7
   *     TweenLite.to(...); //would use v1.6
   * </script>
   *
   * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
   * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
   * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
   * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
   */
  Definition = function Definition(ns, dependencies, func, global) {
    this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses

    _defLookup[ns] = this;
    this.gsClass = null;
    this.func = func;
    var _classes = [];

    this.check = function (init) {
      var i = dependencies.length,
          missing = i,
          cur,
          a,
          n,
          cl;

      while (--i > -1) {
        if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
          _classes[i] = cur.gsClass;
          missing--;
        } else if (init) {
          cur.sc.push(this);
        }
      }

      if (missing === 0 && func) {
        a = ("com.greensock." + ns).split(".");
        n = a.pop();
        cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes); //exports to multiple environments

        if (global) {
          _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)

          /*
          if (typeof(module) !== "undefined" && module.exports) { //node
          	if (ns === moduleName) {
          		module.exports = _exports[moduleName] = cl;
          		for (i in _exports) {
          			cl[i] = _exports[i];
          		}
          	} else if (_exports[moduleName]) {
          		_exports[moduleName][n] = cl;
          	}
          } else if (typeof(define) === "function" && define.amd){ //AMD
          	define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
          }
          */
        }

        for (i = 0; i < this.sc.length; i++) {
          this.sc[i].check();
        }
      }
    };

    this.check(true);
  },
      //used to create Definition instances (which basically registers a class that has dependencies).
  _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
    return new Definition(ns, dependencies, func, global);
  },
      //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
  _class = gs._class = function (ns, func, global) {
    func = func || function () {};

    _gsDefine(ns, [], function () {
      return func;
    }, global);

    return func;
  };

  _gsDefine.globals = _globals;
  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */

  var _baseParams = [0, 0, 1, 1],
      Ease = _class("easing.Ease", function (func, extraParams, type, power) {
    this._func = func;
    this._type = type || 0;
    this._power = power || 0;
    this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
  }, true),
      _easeMap = Ease.map = {},
      _easeReg = Ease.register = function (ease, names, types, create) {
    var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e,
        name,
        j,
        type;

    while (--i > -1) {
      name = na[i];
      e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
      j = ta.length;

      while (--j > -1) {
        type = ta[j];
        _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
      }
    }
  };

  p = Ease.prototype;
  p._calcEnd = false;

  p.getRatio = function (p) {
    if (this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }

    var t = this._type,
        pw = this._power,
        r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;

    if (pw === 1) {
      r *= r;
    } else if (pw === 2) {
      r *= r * r;
    } else if (pw === 3) {
      r *= r * r * r;
    } else if (pw === 4) {
      r *= r * r * r * r;
    }

    return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
  }; //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)


  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;

  while (--i > -1) {
    p = a[i] + ",Power" + i;

    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);

    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));

    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }

  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */

  var EventDispatcher = _class("events.EventDispatcher", function (target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });

  p = EventDispatcher.prototype;

  p.addEventListener = function (type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
        index = 0,
        listener,
        i;

    if (this === _ticker && !_tickerActive) {
      _ticker.wake();
    }

    if (list == null) {
      this._listeners[type] = list = [];
    }

    i = list.length;

    while (--i > -1) {
      listener = list[i];

      if (listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }

    list.splice(index, 0, {
      c: callback,
      s: scope,
      up: useParam,
      pr: priority
    });
  };

  p.removeEventListener = function (type, callback) {
    var list = this._listeners[type],
        i;

    if (list) {
      i = list.length;

      while (--i > -1) {
        if (list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };

  p.dispatchEvent = function (type) {
    var list = this._listeners[type],
        i,
        t,
        listener;

    if (list) {
      i = list.length;

      if (i > 1) {
        list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
      }

      t = this._eventTarget;

      while (--i > -1) {
        listener = list[i];

        if (listener) {
          if (listener.up) {
            listener.c.call(listener.s || t, {
              type: type,
              target: t
            });
          } else {
            listener.c.call(listener.s || t);
          }
        }
      }
    }
  };
  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */


  var _reqAnimFrame = window.requestAnimationFrame,
      _cancelAnimFrame = window.cancelAnimationFrame,
      _getTime = Date.now || function () {
    return new Date().getTime();
  },
      _lastUpdate = _getTime(); //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.


  a = ["ms", "moz", "webkit", "o"];
  i = a.length;

  while (--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }

  _class("Ticker", function (fps, useRAF) {
    var _self = this,
        _startTime = _getTime(),
        _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _tickWord = "tick",
        //helps reduce gc burden
    _fps,
        _req,
        _id,
        _gap,
        _nextTime,
        _tick = function _tick(manual) {
      var elapsed = _getTime() - _lastUpdate,
          overlap,
          dispatch;

      if (elapsed > _lagThreshold) {
        _startTime += elapsed - _adjustedLag;
      }

      _lastUpdate += elapsed;
      _self.time = (_lastUpdate - _startTime) / 1000;
      overlap = _self.time - _nextTime;

      if (!_fps || overlap > 0 || manual === true) {
        _self.frame++;
        _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
        dispatch = true;
      }

      if (manual !== true) {
        //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
        _id = _req(_tick);
      }

      if (dispatch) {
        _self.dispatchEvent(_tickWord);
      }
    };

    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;

    _self.tick = function () {
      _tick(true);
    };

    _self.lagSmoothing = function (threshold, adjustedLag) {
      if (!arguments.length) {
        //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
        return _lagThreshold < 1 / _tinyNum;
      }

      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    };

    _self.sleep = function () {
      if (_id == null) {
        return;
      }

      if (!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }

      _req = _emptyFunc;
      _id = null;

      if (_self === _ticker) {
        _tickerActive = false;
      }
    };

    _self.wake = function (seamless) {
      if (_id !== null) {
        _self.sleep();
      } else if (seamless) {
        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
      } else if (_self.frame > 10) {
        //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
        _lastUpdate = _getTime() - _lagThreshold + 5;
      }

      _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
        return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
      } : _reqAnimFrame;

      if (_self === _ticker) {
        _tickerActive = true;
      }

      _tick(2);
    };

    _self.fps = function (value) {
      if (!arguments.length) {
        return _fps;
      }

      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;

      _self.wake();
    };

    _self.useRAF = function (value) {
      if (!arguments.length) {
        return _useRAF;
      }

      _self.sleep();

      _useRAF = value;

      _self.fps(_fps);
    };

    _self.fps(fps); //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.


    setTimeout(function () {
      if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
        _self.useRAF(false);
      }
    }, 1500);
  });

  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;
  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */

  var Animation = _class("core.Animation", function (duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = !!vars.immediateRender;
    this.data = vars.data;
    this._reversed = !!vars.reversed;

    if (!_rootTimeline) {
      return;
    }

    if (!_tickerActive) {
      //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }

    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);

    if (this.vars.paused) {
      this.paused(true);
    }
  });

  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false; //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.

  var _checkTimeout = function _checkTimeout() {
    if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
      //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
      _ticker.wake();
    }

    var t = setTimeout(_checkTimeout, 2000);

    if (t.unref) {
      // allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
      t.unref();
    }
  };

  _checkTimeout();

  p.play = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.reversed(false).paused(false);
  };

  p.pause = function (atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }

    return this.paused(true);
  };

  p.resume = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.paused(false);
  };

  p.seek = function (time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };

  p.restart = function (includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
  };

  p.reverse = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }

    return this.reversed(true).paused(false);
  };

  p.render = function (time, suppressEvents, force) {//stub - we override this method in subclasses.
  };

  p.invalidate = function () {
    this._time = this._totalTime = 0;
    this._initted = this._gc = false;
    this._rawPrevTime = -1;

    if (this._gc || !this.timeline) {
      this._enabled(true);
    }

    return this;
  };

  p.isActive = function () {
    var tl = this._timeline,
        //the 2 root timelines won't have a _timeline; they're always active.
    startTime = this._startTime,
        rawTime;
    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - _tinyNum;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    this._gc = !enabled;
    this._active = this.isActive();

    if (ignoreTimeline !== true) {
      if (enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if (!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }

    return false;
  };

  p._kill = function (vars, target) {
    return this._enabled(false, false);
  };

  p.kill = function (vars, target) {
    this._kill(vars, target);

    return this;
  };

  p._uncache = function (includeSelf) {
    var tween = includeSelf ? this : this.timeline;

    while (tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }

    return this;
  };

  p._swapSelfInParams = function (params) {
    var i = params.length,
        copy = params.concat();

    while (--i > -1) {
      if (params[i] === "{self}") {
        copy[i] = this;
      }
    }

    return copy;
  };

  p._callback = function (type) {
    var v = this.vars,
        callback = v[type],
        params = v[type + "Params"],
        scope = v[type + "Scope"] || v.callbackScope || this,
        l = params ? params.length : 0;

    switch (l) {
      //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      case 0:
        callback.call(scope);
        break;

      case 1:
        callback.call(scope, params[0]);
        break;

      case 2:
        callback.call(scope, params[0], params[1]);
        break;

      default:
        callback.apply(scope, params);
    }
  }; //----Animation getters/setters --------------------------------------------------------


  p.eventCallback = function (type, callback, params, scope) {
    if ((type || "").substr(0, 2) === "on") {
      var v = this.vars;

      if (arguments.length === 1) {
        return v[type];
      }

      if (callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }

      if (type === "onUpdate") {
        this._onUpdate = callback;
      }
    }

    return this;
  };

  p.delay = function (value) {
    if (!arguments.length) {
      return this._delay;
    }

    if (this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }

    this._delay = value;
    return this;
  };

  p.duration = function (value) {
    if (!arguments.length) {
      this._dirty = false;
      return this._duration;
    }

    this._duration = this._totalDuration = value;

    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.


    if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
      this.totalTime(this._totalTime * (value / this._duration), true);
    }
    return this;
  };

  p.totalDuration = function (value) {
    this._dirty = false;
    return !arguments.length ? this._totalDuration : this.duration(value);
  };

  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }

    if (this._dirty) {
      this.totalDuration();
    }

    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
  };

  p.totalTime = function (time, suppressEvents, uncapped) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (!arguments.length) {
      return this._totalTime;
    }

    if (this._timeline) {
      if (time < 0 && !uncapped) {
        time += this.totalDuration();
      }

      if (this._timeline.smoothChildTiming) {
        if (this._dirty) {
          this.totalDuration();
        }

        var totalDuration = this._totalDuration,
            tl = this._timeline;

        if (time > totalDuration && !uncapped) {
          time = totalDuration;
        }

        this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;

        if (!tl._dirty) {
          //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.


        if (tl._timeline) {
          while (tl._timeline) {
            if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }

            tl = tl._timeline;
          }
        }
      }

      if (this._gc) {
        this._enabled(true, false);
      }

      if (this._totalTime !== time || this._duration === 0) {
        if (_lazyTweens.length) {
          _lazyRender();
        }

        this.render(time, suppressEvents, false);

        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
          _lazyRender();
        }
      }
    }

    return this;
  };

  p.progress = p.totalProgress = function (value, suppressEvents) {
    var duration = this.duration();
    return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
  };

  p.startTime = function (value) {
    if (!arguments.length) {
      return this._startTime;
    }

    if (value !== this._startTime) {
      this._startTime = value;
      if (this.timeline) if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
      }
    }

    return this;
  };

  p.endTime = function (includeRepeats) {
    return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
  };

  p.timeScale = function (value) {
    if (!arguments.length) {
      return this._timeScale;
    }

    var pauseTime, t;
    value = value || _tinyNum; //can't allow zero because it'll throw the math off

    if (this._timeline && this._timeline.smoothChildTiming) {
      pauseTime = this._pauseTime;
      t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
      this._startTime = t - (t - this._startTime) * this._timeScale / value;
    }

    this._timeScale = value;
    t = this.timeline;

    while (t && t.timeline) {
      //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      t._dirty = true;
      t.totalDuration();
      t = t.timeline;
    }

    return this;
  };

  p.reversed = function (value) {
    if (!arguments.length) {
      return this._reversed;
    }

    if (value != this._reversed) {
      this._reversed = value;
      this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
    }

    return this;
  };

  p.paused = function (value) {
    if (!arguments.length) {
      return this._paused;
    }

    var tl = this._timeline,
        raw,
        elapsed;
    if (value != this._paused) if (tl) {
      if (!_tickerActive && !value) {
        _ticker.wake();
      }

      raw = tl.rawTime();
      elapsed = raw - this._pauseTime;

      if (!value && tl.smoothChildTiming) {
        this._startTime += elapsed;

        this._uncache(false);
      }

      this._pauseTime = value ? raw : null;
      this._paused = value;
      this._active = this.isActive();

      if (!value && elapsed !== 0 && this._initted && this.duration()) {
        raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
        this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
      }
    }

    if (this._gc && !value) {
      this._enabled(true, false);
    }

    return this;
  };
  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */


  var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });

  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = p._recent = null;
  p._sortChildren = false;

  p.add = p.insert = function (child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if (child._paused) if (this !== child._timeline) {
      //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
      child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
    }

    if (child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.

    }

    child.timeline = child._timeline = this;

    if (child._gc) {
      child._enabled(true, true);
    }

    prevTween = this._last;

    if (this._sortChildren) {
      st = child._startTime;

      while (prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }

    if (prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }

    child._prev = prevTween;
    this._recent = child;

    if (this._timeline) {
      this._uncache(true);
    }

    return this;
  };

  p._remove = function (tween, skipDisable) {
    if (tween.timeline === this) {
      if (!skipDisable) {
        tween._enabled(false, true);
      }

      if (tween._prev) {
        tween._prev._next = tween._next;
      } else if (this._first === tween) {
        this._first = tween._next;
      }

      if (tween._next) {
        tween._next._prev = tween._prev;
      } else if (this._last === tween) {
        this._last = tween._prev;
      }

      tween._next = tween._prev = tween.timeline = null;

      if (tween === this._recent) {
        this._recent = this._last;
      }

      if (this._timeline) {
        this._uncache(true);
      }
    }

    return this;
  };

  p.render = function (time, suppressEvents, force) {
    var tween = this._first,
        next;
    this._totalTime = this._time = this._rawPrevTime = time;

    while (tween) {
      next = tween._next; //record it here because the value could change after rendering...

      if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
        }
      }

      tween = next;
    }
  };

  p.rawTime = function () {
    if (!_tickerActive) {
      _ticker.wake();
    }

    return this._totalTime;
  };
  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */


  var TweenLite = _class("TweenLite", function (target, duration, vars) {
    Animation.call(this, duration, vars);
    this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

    if (target == null) {
      throw "Cannot tween a null target.";
    }

    this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
        overwrite = this.vars.overwrite,
        i,
        targ,
        targets;
    this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

    if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
      this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()

      this._propLookup = [];
      this._siblings = [];

      for (i = 0; i < targets.length; i++) {
        targ = targets[i];

        if (!targ) {
          targets.splice(i--, 1);
          continue;
        } else if (typeof targ === "string") {
          targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings

          if (typeof targ === "string") {
            targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
          }

          continue;
        } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
          //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
          targets.splice(i--, 1);
          this._targets = targets = targets.concat(_slice(targ));
          continue;
        }

        this._siblings[i] = _register(targ, this, false);
        if (overwrite === 1) if (this._siblings[i].length > 1) {
          _applyOverwrite(targ, this, null, 1, this._siblings[i]);
        }
      }
    } else {
      this._propLookup = {};
      this._siblings = _register(target, this, false);
      if (overwrite === 1) if (this._siblings.length > 1) {
        _applyOverwrite(target, this, null, 1, this._siblings);
      }
    }

    if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(Math.min(0, -this._delay)); //in case delay is negative
    }
  }, true),
      _isSelector = function _isSelector(v) {
    return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
  },
      _autoCSS = function _autoCSS(vars, target) {
    var css = {},
        p;

    for (p in vars) {
      if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
        //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
        css[p] = vars[p];
        delete vars[p];
      }
    }

    vars.css = css;
  };

  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false; //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = p._lazy = false;
  TweenLite.version = "2.1.3";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = 120;

  TweenLite.lagSmoothing = function (threshold, adjustedLag) {
    _ticker.lagSmoothing(threshold, adjustedLag);
  };

  TweenLite.selector = window.$ || window.jQuery || function (e) {
    var selector = window.$ || window.jQuery;

    if (selector) {
      TweenLite.selector = selector;
      return selector(e);
    }

    if (!_doc) {
      //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
      _doc = window.document;
    }

    return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
  };

  var _lazyTweens = [],
      _lazyLookup = {},
      _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
      _relExp = /[\+-]=-?[\.\d]/,
      //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
  _setRatio = function _setRatio(v) {
    var pt = this._firstPT,
        min = 0.000001,
        val;

    while (pt) {
      val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;

      if (pt.m) {
        val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
      } else if (val < min) if (val > -min && !pt.blob) {
        //prevents issues with converting very small numbers to strings in the browser
        val = 0;
      }

      if (!pt.f) {
        pt.t[pt.p] = val;
      } else if (pt.fp) {
        pt.t[pt.p](pt.fp, val);
      } else {
        pt.t[pt.p](val);
      }

      pt = pt._next;
    }
  },
      _blobRound = function _blobRound(v) {
    return (v * 1000 | 0) / 1000 + "";
  },
      //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
  _blobDif = function _blobDif(start, end, filter, pt) {
    var a = [],
        charIndex = 0,
        s = "",
        color = 0,
        startNums,
        endNums,
        num,
        i,
        l,
        nonNumbers,
        currentNum;
    a.start = start;
    a.end = end;
    start = a[0] = start + ""; //ensure values are strings

    end = a[1] = end + "";

    if (filter) {
      filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    a.length = 0;
    startNums = start.match(_numbersExp) || [];
    endNums = end.match(_numbersExp) || [];

    if (pt) {
      pt._next = null;
      pt.blob = 1;
      a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
    }

    l = endNums.length;

    for (i = 0; i < l; i++) {
      currentNum = endNums[i];
      nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
      s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.

      charIndex += nonNumbers.length;

      if (color) {
        //sense rgba() values and round them.
        color = (color + 1) % 5;
      } else if (nonNumbers.substr(-5) === "rgba(") {
        color = 1;
      }

      if (currentNum === startNums[i] || startNums.length <= i) {
        s += currentNum;
      } else {
        if (s) {
          a.push(s);
          s = "";
        }

        num = parseFloat(startNums[i]);
        a.push(num);
        a._firstPT = {
          _next: a._firstPT,
          t: a,
          p: a.length - 1,
          s: num,
          c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
          f: 0,
          m: color && color < 4 ? Math.round : _blobRound
        }; //limiting to 3 decimal places and casting as a string can really help performance when array.join() is called!
        //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
      }

      charIndex += currentNum.length;
    }

    s += end.substr(charIndex);

    if (s) {
      a.push(s);
    }

    a.setRatio = _setRatio;

    if (_relExp.test(end)) {
      //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
      a.end = null;
    }

    return a;
  },
      //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
  _addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
    if (typeof end === "function") {
      end = end(index || 0, target);
    }

    var type = _typeof(target[prop]),
        getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
        s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
        isRelative = typeof end === "string" && end.charAt(1) === "=",
        pt = {
      t: target,
      p: prop,
      s: s,
      f: type === "function",
      pg: 0,
      n: overwriteProp || prop,
      m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
      pr: 0,
      c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
    },
        blob;

    if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
      if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
        //a blob (string that has multiple numbers in it)
        pt.fp = funcParam;
        blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
        pt = {
          t: blob,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 2,
          pg: 0,
          n: overwriteProp || prop,
          pr: 0,
          m: 0
        }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
      } else {
        pt.s = parseFloat(s);

        if (!isRelative) {
          pt.c = parseFloat(end) - pt.s || 0;
        }
      }
    }

    if (pt.c) {
      //only add it to the linked list if there's a change.
      if (pt._next = this._firstPT) {
        pt._next._prev = pt;
      }

      this._firstPT = pt;
      return pt;
    }
  },
      _internals = TweenLite._internals = {
    isArray: _isArray,
    isSelector: _isSelector,
    lazyTweens: _lazyTweens,
    blobDif: _blobDif
  },
      //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
  _plugins = TweenLite._plugins = {},
      _tweenLookup = _internals.tweenLookup = {},
      _tweenLookupNum = 0,
      _reservedProps = _internals.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1,
    stagger: 1
  },
      _overwriteLookup = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    "true": 1,
    "false": 0
  },
      _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
      _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
      _nextGCFrame = 30,
      _lazyRender = _internals.lazyRender = function () {
    var l = _lazyTweens.length,
        i,
        tween;
    _lazyLookup = {};

    for (i = 0; i < l; i++) {
      tween = _lazyTweens[i];

      if (tween && tween._lazy !== false) {
        tween.render(tween._lazy[0], tween._lazy[1], true);
        tween._lazy = false;
      }
    }

    _lazyTweens.length = 0;
  };

  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

  Animation._updateRoot = TweenLite.render = function () {
    var i, a, p;

    if (_lazyTweens.length) {
      //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
      _lazyRender();
    }

    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);

    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);

    if (_lazyTweens.length) {
      _lazyRender();
    }

    if (_ticker.frame >= _nextGCFrame) {
      //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
      _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);

      for (p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;

        while (--i > -1) {
          if (a[i]._gc) {
            a.splice(i, 1);
          }
        }

        if (a.length === 0) {
          delete _tweenLookup[p];
        }
      } //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly


      p = _rootTimeline._first;
      if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
        while (p && p._paused) {
          p = p._next;
        }

        if (!p) {
          _ticker.sleep();
        }
      }
    }
  };

  _ticker.addEventListener("tick", Animation._updateRoot);

  var _register = function _register(target, tween, scrub) {
    var id = target._gsTweenID,
        a,
        i;

    if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
      _tweenLookup[id] = {
        target: target,
        tweens: []
      };
    }

    if (tween) {
      a = _tweenLookup[id].tweens;
      a[i = a.length] = tween;

      if (scrub) {
        while (--i > -1) {
          if (a[i] === tween) {
            a.splice(i, 1);
          }
        }
      }
    }

    return _tweenLookup[id].tweens;
  },
      _onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
    var func = overwrittenTween.vars.onOverwrite,
        r1,
        r2;

    if (func) {
      r1 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    func = TweenLite.onOverwrite;

    if (func) {
      r2 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    return r1 !== false && r2 !== false;
  },
      _applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
    var i, changed, curTween, l;

    if (mode === 1 || mode >= 4) {
      l = siblings.length;

      for (i = 0; i < l; i++) {
        if ((curTween = siblings[i]) !== tween) {
          if (!curTween._gc) {
            if (curTween._kill(null, target, tween)) {
              changed = true;
            }
          }
        } else if (mode === 5) {
          break;
        }
      }

      return changed;
    } //NOTE: Add tiny amount to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)


    var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = tween._duration === 0,
        globalStart;
    i = siblings.length;

    while (--i > -1) {
      if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {//ignore
      } else if (curTween._timeline !== tween._timeline) {
        globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);

        if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
          overlaps[oCount++] = curTween;
        }
      } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= _tinyNum * 2)) {
        overlaps[oCount++] = curTween;
      }
    }

    i = oCount;

    while (--i > -1) {
      curTween = overlaps[i];
      l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278

      if (mode === 2) if (curTween._kill(props, target, tween)) {
        changed = true;
      }

      if (mode !== 2 || !curTween._firstPT && curTween._initted && l) {
        if (mode !== 2 && !_onOverwrite(curTween, tween)) {
          continue;
        }

        if (curTween._enabled(false, false)) {
          //if all property tweens have been overwritten, kill the tween.
          changed = true;
        }
      }
    }

    return changed;
  },
      _checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
    var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;

    while (tl._timeline) {
      t += tl._startTime;
      ts *= tl._timeScale;

      if (tl._paused) {
        return -100;
      }

      tl = tl._timeline;
    }

    t /= ts;
    return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
  }; //---- TweenLite instance methods -----------------------------------------------------------------------------


  p._init = function () {
    var v = this.vars,
        op = this._overwrittenProps,
        dur = this._duration,
        immediate = !!v.immediateRender,
        ease = v.ease,
        startAt = this._startAt,
        i,
        initPlugins,
        pt,
        p,
        startVars,
        l;

    if (v.startAt) {
      if (startAt) {
        startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.

        startAt.kill();
      }

      startVars = {};

      for (p in v.startAt) {
        //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
        startVars[p] = v.startAt[p];
      }

      startVars.data = "isStart";
      startVars.overwrite = false;
      startVars.immediateRender = true;
      startVars.lazy = immediate && v.lazy !== false;
      startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).

      startVars.onUpdate = v.onUpdate;
      startVars.onUpdateParams = v.onUpdateParams;
      startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
      this._startAt = TweenLite.to(this.target || {}, 0, startVars);

      if (immediate) {
        if (this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if (dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (startAt) {
        startAt.render(-1, true);
        startAt.kill();
        this._startAt = null;
      } else {
        if (this._time !== 0) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediate = false;
        }

        pt = {};

        for (p in v) {
          //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if (!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }

        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.

        pt.lazy = immediate && v.lazy !== false;
        pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)

        this._startAt = TweenLite.to(this.target, 0, pt);

        if (!immediate) {
          this._startAt._init(); //ensures that the initial values are recorded


          this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.


          if (this.vars.immediateRender) {
            this._startAt = null;
          }
        } else if (this._time === 0) {
          return;
        }
      }
    }

    this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;

    if (v.easeParams instanceof Array && ease.config) {
      this._ease = ease.config.apply(ease, v.easeParams);
    }

    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;

    if (this._targets) {
      l = this._targets.length;

      for (i = 0; i < l; i++) {
        if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
    }

    if (initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite

    }

    if (op) if (!this._firstPT) if (typeof this.target !== "function") {
      //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
      this._enabled(false, false);
    }

    if (v.runBackwards) {
      pt = this._firstPT;

      while (pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }

    this._onUpdate = v.onUpdate;
    this._initted = true;
  };

  p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
    var p, i, initPlugins, plugin, pt, v;

    if (target == null) {
      return false;
    }

    if (_lazyLookup[target._gsTweenID]) {
      _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

    }

    if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
      //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
      _autoCSS(this.vars, target);
    }

    for (p in this.vars) {
      v = this.vars[p];

      if (_reservedProps[p]) {
        if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
          this.vars[p] = v = this._swapSelfInParams(v, this);
        }
      } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        //m - mod           [function | 0]
        this._firstPT = pt = {
          _next: this._firstPT,
          t: plugin,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: p,
          pg: 1,
          pr: plugin._priority,
          m: 0
        };
        i = plugin._overwriteProps.length;

        while (--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }

        if (plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }

        if (plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }

        if (pt._next) {
          pt._next._prev = pt;
        }
      } else {
        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
      }
    }

    if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
      //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
      this._kill(propLookup, target);

      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
      //zero duration tweens don't lazy render by default; everything else does.
      _lazyLookup[target._gsTweenID] = true;
    }
    return initPlugins;
  };

  p.render = function (time, suppressEvents, force) {
    var self = this,
        prevTime = self._time,
        duration = self._duration,
        prevRawPrevTime = self._rawPrevTime,
        isComplete,
        callback,
        pt,
        rawPrevTime;

    if (time >= duration - _tinyNum && time >= 0) {
      //to work around occasional floating point math artifacts.
      self._totalTime = self._time = duration;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;

      if (!self._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = force || self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }

      if (duration === 0) if (self._initted || !self.vars.lazy || force) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        if (self._startTime === self._timeline._duration) {
          //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
          time = 0;
        }

        if (prevRawPrevTime < 0 || time <= 0 && time >= -_tinyNum || prevRawPrevTime === _tinyNum && self.data !== "isPause") if (prevRawPrevTime !== time) {
          //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
          force = true;

          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < _tinyNum) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      self._totalTime = self._time = 0;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;

      if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
        callback = "onReverseComplete";
        isComplete = self._reversed;
      }

      if (time > -_tinyNum) {
        time = 0;
      } else if (time < 0) {
        self._active = false;
        if (duration === 0) if (self._initted || !self.vars.lazy || force) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && self.data === "isPause")) {
            force = true;
          }

          self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      }

      if (!self._initted || self._startAt && self._startAt.progress()) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
        force = true;
      }
    } else {
      self._totalTime = self._time = time;

      if (self._easeType) {
        var r = time / duration,
            type = self._easeType,
            pow = self._easePower;

        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }

        if (type === 3) {
          r *= 2;
        }

        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }

        self.ratio = type === 1 ? 1 - r : type === 2 ? r : time / duration < 0.5 ? r / 2 : 1 - r / 2;
      } else {
        self.ratio = self._ease.getRatio(time / duration);
      }
    }

    if (self._time === prevTime && !force) {
      return;
    } else if (!self._initted) {
      self._init();

      if (!self._initted || self._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if (!force && self._firstPT && (self.vars.lazy !== false && self._duration || self.vars.lazy && !self._duration)) {
        self._time = self._totalTime = prevTime;
        self._rawPrevTime = prevRawPrevTime;

        _lazyTweens.push(self);

        self._lazy = [time, suppressEvents];
        return;
      } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.


      if (self._time && !isComplete) {
        self.ratio = self._ease.getRatio(self._time / duration);
      } else if (isComplete && self._ease._calcEnd) {
        self.ratio = self._ease.getRatio(self._time === 0 ? 0 : 1);
      }
    }

    if (self._lazy !== false) {
      //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
      self._lazy = false;
    }

    if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {
      self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }

    if (prevTime === 0) {
      if (self._startAt) {
        if (time >= 0) {
          self._startAt.render(time, true, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }

      if (self.vars.onStart) if (self._time !== 0 || duration === 0) if (!suppressEvents) {
        self._callback("onStart");
      }
    }

    pt = self._firstPT;

    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * self.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * self.ratio + pt.s;
      }

      pt = pt._next;
    }

    if (self._onUpdate) {
      if (time < 0) if (self._startAt && time !== -0.0001) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

      }
      if (!suppressEvents) if (self._time !== prevTime || isComplete || force) {
        self._callback("onUpdate");
      }
    }

    if (callback) if (!self._gc || force) {
      //check _gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && self._startAt && !self._onUpdate && time !== -0.0001) {
        //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
        self._startAt.render(time, true, force);
      }

      if (isComplete) {
        if (self._timeline.autoRemoveChildren) {
          self._enabled(false, false);
        }

        self._active = false;
      }

      if (!suppressEvents && self.vars[callback]) {
        self._callback(callback);
      }

      if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        self._rawPrevTime = 0;
      }
    }
  };

  p._kill = function (vars, target, overwritingTween) {
    if (vars === "all") {
      vars = null;
    }

    if (vars == null) if (target == null || target === this.target) {
      this._lazy = false;
      return this._enabled(false, false);
    }
    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
    var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
        firstPT = this._firstPT,
        i,
        overwrittenProps,
        p,
        pt,
        propLookup,
        changed,
        killProps,
        record,
        killed;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;

      while (--i > -1) {
        if (this._kill(vars, target[i], overwritingTween)) {
          changed = true;
        }
      }
    } else {
      if (this._targets) {
        i = this._targets.length;

        while (--i > -1) {
          if (target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if (target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }

      if (propLookup) {
        killProps = vars || propLookup;
        record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (_typeof(vars) !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)

        if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
          for (p in killProps) {
            if (propLookup[p]) {
              if (!killed) {
                killed = [];
              }

              killed.push(p);
            }
          }

          if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
            //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
            return false;
          }
        }

        for (p in killProps) {
          if (pt = propLookup[p]) {
            if (simultaneousOverwrite) {
              //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
              if (pt.f) {
                pt.t[pt.p](pt.s);
              } else {
                pt.t[pt.p] = pt.s;
              }

              changed = true;
            }

            if (pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }

            if (!pt.pg || pt.t._overwriteProps.length === 0) {
              if (pt._prev) {
                pt._prev._next = pt._next;
              } else if (pt === this._firstPT) {
                this._firstPT = pt._next;
              }

              if (pt._next) {
                pt._next._prev = pt._prev;
              }

              pt._next = pt._prev = null;
            }

            delete propLookup[p];
          }

          if (record) {
            overwrittenProps[p] = 1;
          }
        }

        if (!this._firstPT && this._initted && firstPT) {
          //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }

    return changed;
  };

  p.invalidate = function () {
    if (this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }

    var t = this._time;
    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
    this._propLookup = this._targets ? {} : [];
    Animation.prototype.invalidate.call(this);

    if (this.vars.immediateRender) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(t, false, this.vars.lazy !== false);
    }

    return this;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (enabled && this._gc) {
      var targets = this._targets,
          i;

      if (targets) {
        i = targets.length;

        while (--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }

    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);

    if (this._notifyPluginsOfEnabled) if (this._firstPT) {
      return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
    }
    return false;
  }; //----TweenLite static methods -----------------------------------------------------


  TweenLite.to = function (target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };

  TweenLite.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenLite(target, duration, vars);
  };

  TweenLite.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenLite(target, duration, toVars);
  };

  TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      callbackScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      immediateRender: false,
      lazy: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };

  TweenLite.set = function (target, vars) {
    return new TweenLite(target, 0, vars);
  };

  TweenLite.getTweensOf = function (target, onlyActive) {
    if (target == null) {
      return [];
    }

    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var i, a, j, t;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      a = [];

      while (--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }

      i = a.length; //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)

      while (--i > -1) {
        t = a[i];
        j = i;

        while (--j > -1) {
          if (t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else if (target._gsTweenID) {
      a = _register(target).concat();
      i = a.length;

      while (--i > -1) {
        if (a[i]._gc || onlyActive && !a[i].isActive()) {
          a.splice(i, 1);
        }
      }
    }

    return a || [];
  };

  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
    if (_typeof(onlyActive) === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)

      onlyActive = false;
    }

    var a = TweenLite.getTweensOf(target, onlyActive),
        i = a.length;

    while (--i > -1) {
      a[i]._kill(vars, target);
    }
  };
  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */


  var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);

  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.19.0";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = _addPropTween;
  p.setRatio = _setRatio;

  p._kill = function (lookup) {
    var a = this._overwriteProps,
        pt = this._firstPT,
        i;

    if (lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;

      while (--i > -1) {
        if (lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }

    while (pt) {
      if (lookup[pt.n] != null) {
        if (pt._next) {
          pt._next._prev = pt._prev;
        }

        if (pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }

      pt = pt._next;
    }

    return false;
  };

  p._mod = p._roundProps = function (lookup) {
    var pt = this._firstPT,
        val;

    while (pt) {
      val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];

      if (val && typeof val === "function") {
        //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        if (pt.f === 2) {
          pt.t._applyPT.m = val;
        } else {
          pt.m = val;
        }
      }

      pt = pt._next;
    }
  };

  TweenLite._onPluginEvent = function (type, tween) {
    var pt = tween._firstPT,
        changed,
        pt2,
        first,
        last,
        next;

    if (type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while (pt) {
        next = pt._next;
        pt2 = first;

        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }

        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }

        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }

        pt = next;
      }

      pt = tween._firstPT = first;
    }

    while (pt) {
      if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
        changed = true;
      }
      pt = pt._next;
    }

    return changed;
  };

  TweenPlugin.activate = function (plugins) {
    var i = plugins.length;

    while (--i > -1) {
      if (plugins[i].API === TweenPlugin.API) {
        _plugins[new plugins[i]()._propName] = plugins[i];
      }
    }

    return true;
  }; //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.


  _gsDefine.plugin = function (config) {
    if (!config || !config.propName || !config.init || !config.API) {
      throw "illegal plugin definition.";
    }

    var propName = config.propName,
        priority = config.priority || 0,
        overwriteProps = config.overwriteProps,
        map = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    },
        Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
      TweenPlugin.call(this, propName, priority);
      this._overwriteProps = overwriteProps || [];
    }, config.global === true),
        p = Plugin.prototype = new TweenPlugin(propName),
        prop;

    p.constructor = Plugin;
    Plugin.API = config.API;

    for (prop in map) {
      if (typeof config[prop] === "function") {
        p[map[prop]] = config[prop];
      }
    }

    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  }; //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.


  a = window._gsQueue;

  if (a) {
    for (i = 0; i < a.length; i++) {
      a[i]();
    }

    for (p in _defLookup) {
      if (!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: " + p);
      }
    }
  }

  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

  return TweenLite;
}(_gsScope, "TweenLite");
var globals = _gsScope.GreenSockGlobals;
var nonGlobals = globals.com.greensock;

var SimpleTimeline = nonGlobals.core.SimpleTimeline;
var Animation = nonGlobals.core.Animation;
var Ease = globals.Ease;
var Linear = globals.Linear;
var Power0 = Linear;
var Power1 = globals.Power1;
var Power2 = globals.Power2;
var Power3 = globals.Power3;
var Power4 = globals.Power4;
var TweenPlugin = globals.TweenPlugin;
var EventDispatcher = nonGlobals.events.EventDispatcher;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)(module), __webpack_require__(2)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Swiper 6.1.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: August 17, 2020
 */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function () {
  'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }
  /**
   * SSR Window 3.0.0-alpha.4
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2020, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: May 20, 2020
   */

  /* eslint-disable no-param-reassign */


  function isObject(obj) {
    return obj !== null && _typeof(obj) === 'object' && 'constructor' in obj && obj.constructor === Object;
  }

  function extend(target, src) {
    if (target === void 0) {
      target = {};
    }

    if (src === void 0) {
      src = {};
    }

    Object.keys(src).forEach(function (key) {
      if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }

  var ssrDocument = {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
      blur: function blur() {},
      nodeName: ''
    },
    querySelector: function querySelector() {
      return null;
    },
    querySelectorAll: function querySelectorAll() {
      return [];
    },
    getElementById: function getElementById() {
      return null;
    },
    createEvent: function createEvent() {
      return {
        initEvent: function initEvent() {}
      };
    },
    createElement: function createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function setAttribute() {},
        getElementsByTagName: function getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS: function createElementNS() {
      return {};
    },
    importNode: function importNode() {
      return null;
    },
    location: {
      hash: '',
      host: '',
      hostname: '',
      href: '',
      origin: '',
      pathname: '',
      protocol: '',
      search: ''
    }
  };

  function getDocument() {
    var doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }

  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ''
    },
    location: {
      hash: '',
      host: '',
      hostname: '',
      href: '',
      origin: '',
      pathname: '',
      protocol: '',
      search: ''
    },
    history: {
      replaceState: function replaceState() {},
      pushState: function pushState() {},
      go: function go() {},
      back: function back() {}
    },
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
      return {
        getPropertyValue: function getPropertyValue() {
          return '';
        }
      };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {},
    matchMedia: function matchMedia() {
      return {};
    },
    requestAnimationFrame: function requestAnimationFrame(callback) {
      if (typeof setTimeout === 'undefined') {
        callback();
        return null;
      }

      return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function cancelAnimationFrame(id) {
      if (typeof setTimeout === 'undefined') {
        return;
      }

      clearTimeout(id);
    }
  };

  function getWindow() {
    var win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
  }
  /**
   * Dom7 3.0.0-alpha.7
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * https://framework7.io/docs/dom7.html
   *
   * Copyright 2020, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: July 14, 2020
   */


  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }
  /* eslint-disable no-proto */


  function makeReactive(obj) {
    var proto = obj.__proto__;
    Object.defineProperty(obj, '__proto__', {
      get: function get() {
        return proto;
      },
      set: function set(value) {
        proto.__proto__ = value;
      }
    });
  }

  var Dom7 = /*#__PURE__*/function (_Array) {
    _inheritsLoose(Dom7, _Array);

    function Dom7(items) {
      var _this;

      _this = _Array.call.apply(_Array, [this].concat(items)) || this;
      makeReactive(_assertThisInitialized(_this));
      return _this;
    }

    return Dom7;
  }( /*#__PURE__*/_wrapNativeSuper(Array));

  function arrayFlat(arr) {
    if (arr === void 0) {
      arr = [];
    }

    var res = [];
    arr.forEach(function (el) {
      if (Array.isArray(el)) {
        res.push.apply(res, arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }

  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }

  function arrayUnique(arr) {
    var uniqueArray = [];

    for (var i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
    }

    return uniqueArray;
  }

  function qsa(selector, context) {
    if (typeof selector !== 'string') {
      return [selector];
    }

    var a = [];
    var res = context.querySelectorAll(selector);

    for (var i = 0; i < res.length; i += 1) {
      a.push(res[i]);
    }

    return a;
  }

  function $(selector, context) {
    var window = getWindow();
    var document = getDocument();
    var arr = [];

    if (!context && selector instanceof Dom7) {
      return selector;
    }

    if (!selector) {
      return new Dom7(arr);
    }

    if (typeof selector === 'string') {
      var html = selector.trim();

      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        var toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        var tempParent = document.createElement(toCreate);
        tempParent.innerHTML = html;

        for (var i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        arr = qsa(selector.trim(), context || document);
      } // arr = qsa(selector, document);

    } else if (selector.nodeType || selector === window || selector === document) {
      arr.push(selector);
    } else if (Array.isArray(selector)) {
      if (selector instanceof Dom7) return selector;
      arr = selector;
    }

    return new Dom7(arrayUnique(arr));
  }

  $.fn = Dom7.prototype;

  function addClass() {
    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
      classes[_key] = arguments[_key];
    }

    var classNames = arrayFlat(classes.map(function (c) {
      return c.split(' ');
    }));
    this.forEach(function (el) {
      var _el$classList;

      (_el$classList = el.classList).add.apply(_el$classList, classNames);
    });
    return this;
  }

  function removeClass() {
    for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      classes[_key2] = arguments[_key2];
    }

    var classNames = arrayFlat(classes.map(function (c) {
      return c.split(' ');
    }));
    this.forEach(function (el) {
      var _el$classList2;

      (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
    });
    return this;
  }

  function toggleClass() {
    for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      classes[_key3] = arguments[_key3];
    }

    var classNames = arrayFlat(classes.map(function (c) {
      return c.split(' ');
    }));
    this.forEach(function (el) {
      classNames.forEach(function (className) {
        el.classList.toggle(className);
      });
    });
  }

  function hasClass() {
    for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      classes[_key4] = arguments[_key4];
    }

    var classNames = arrayFlat(classes.map(function (c) {
      return c.split(' ');
    }));
    return arrayFilter(this, function (el) {
      return classNames.filter(function (className) {
        return el.classList.contains(className);
      }).length > 0;
    }).length > 0;
  }

  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) return this[0].getAttribute(attrs);
      return undefined;
    } // Set attrs


    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        for (var attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    return this;
  }

  function removeAttr(attr) {
    for (var i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }

    return this;
  }

  function transform(transform) {
    for (var i = 0; i < this.length; i += 1) {
      this[i].style.transform = transform;
    }

    return this;
  }

  function transition(duration) {
    for (var i = 0; i < this.length; i += 1) {
      this[i].style.transition = typeof duration !== 'string' ? duration + "ms" : duration;
    }

    return this;
  }

  function on() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];

    if (typeof args[1] === 'function') {
      eventType = args[0];
      listener = args[1];
      capture = args[2];
      targetSelector = undefined;
    }

    if (!capture) capture = false;

    function handleLiveEvent(e) {
      var target = e.target;
      if (!target) return;
      var eventData = e.target.dom7EventData || [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
        var _parents = $(target).parents(); // eslint-disable-line


        for (var k = 0; k < _parents.length; k += 1) {
          if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
        }
      }
    }

    function handleEvent(e) {
      var eventData = e && e.target ? e.target.dom7EventData || [] : [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      listener.apply(this, eventData);
    }

    var events = eventType.split(' ');
    var j;

    for (var i = 0; i < this.length; i += 1) {
      var el = this[i];

      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          var event = events[j];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
          el.dom7Listeners[event].push({
            listener: listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          var _event = events[j];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

          el.dom7LiveListeners[_event].push({
            listener: listener,
            proxyListener: handleLiveEvent
          });

          el.addEventListener(_event, handleLiveEvent, capture);
        }
      }
    }

    return this;
  }

  function off() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];

    if (typeof args[1] === 'function') {
      eventType = args[0];
      listener = args[1];
      capture = args[2];
      targetSelector = undefined;
    }

    if (!capture) capture = false;
    var events = eventType.split(' ');

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];
        var handlers = void 0;

        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }

        if (handlers && handlers.length) {
          for (var k = handlers.length - 1; k >= 0; k -= 1) {
            var handler = handlers[k];

            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }

    return this;
  }

  function trigger() {
    var window = getWindow();

    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    var events = args[0].split(' ');
    var eventData = args[1];

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];

        if (window.CustomEvent) {
          var evt = new window.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter(function (data, dataIndex) {
            return dataIndex > 0;
          });
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }

    return this;
  }

  function transitionEnd(callback) {
    var dom = this;

    function fireCallBack(e) {
      if (e.target !== this) return;
      callback.call(this, e);
      dom.off('transitionend', fireCallBack);
    }

    if (callback) {
      dom.on('transitionend', fireCallBack);
    }

    return this;
  }

  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        var _styles = this.styles();

        return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
      }

      return this[0].offsetWidth;
    }

    return null;
  }

  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        var _styles2 = this.styles();

        return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
      }

      return this[0].offsetHeight;
    }

    return null;
  }

  function offset() {
    if (this.length > 0) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var box = el.getBoundingClientRect();
      var body = document.body;
      var clientTop = el.clientTop || body.clientTop || 0;
      var clientLeft = el.clientLeft || body.clientLeft || 0;
      var scrollTop = el === window ? window.scrollY : el.scrollTop;
      var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }

    return null;
  }

  function styles() {
    var window = getWindow();
    if (this[0]) return window.getComputedStyle(this[0], null);
    return {};
  }

  function css(props, value) {
    var window = getWindow();
    var i;

    if (arguments.length === 1) {
      if (typeof props === 'string') {
        // .css('width')
        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        // .css({ width: '100px' })
        for (i = 0; i < this.length; i += 1) {
          for (var _prop in props) {
            this[i].style[_prop] = props[_prop];
          }
        }

        return this;
      }
    }

    if (arguments.length === 2 && typeof props === 'string') {
      // .css('width', '100px')
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }

      return this;
    }

    return this;
  }

  function each(callback) {
    if (!callback) return this;
    this.forEach(function (el, index) {
      callback.apply(el, [el, index]);
    });
    return this;
  }

  function filter(callback) {
    var result = arrayFilter(this, callback);
    return $(result);
  }

  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : null;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }

    return this;
  }

  function text(text) {
    if (typeof text === 'undefined') {
      return this[0] ? this[0].textContent.trim() : null;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }

    return this;
  }

  function is(selector) {
    var window = getWindow();
    var document = getDocument();
    var el = this[0];
    var compareWith;
    var i;
    if (!el || typeof selector === 'undefined') return false;

    if (typeof selector === 'string') {
      if (el.matches) return el.matches(selector);
      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      if (el.msMatchesSelector) return el.msMatchesSelector(selector);
      compareWith = $(selector);

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    if (selector === document) {
      return el === document;
    }

    if (selector === window) {
      return el === window;
    }

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }

      return false;
    }

    return false;
  }

  function index() {
    var child = this[0];
    var i;

    if (child) {
      i = 0; // eslint-disable-next-line

      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }

      return i;
    }

    return undefined;
  }

  function eq(index) {
    if (typeof index === 'undefined') return this;
    var length = this.length;

    if (index > length - 1) {
      return $([]);
    }

    if (index < 0) {
      var returnIndex = length + index;
      if (returnIndex < 0) return $([]);
      return $([this[returnIndex]]);
    }

    return $([this[index]]);
  }

  function append() {
    var newChild;
    var document = getDocument();

    for (var k = 0; k < arguments.length; k += 1) {
      newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

      for (var i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (var j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }

  function prepend(newChild) {
    var document = getDocument();
    var i;
    var j;

    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }

    return this;
  }

  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return $([this[0].nextElementSibling]);
        }

        return $([]);
      }

      if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function nextAll(selector) {
    var nextEls = [];
    var el = this[0];
    if (!el) return $([]);

    while (el.nextElementSibling) {
      var _next = el.nextElementSibling; // eslint-disable-line

      if (selector) {
        if ($(_next).is(selector)) nextEls.push(_next);
      } else nextEls.push(_next);

      el = _next;
    }

    return $(nextEls);
  }

  function prev(selector) {
    if (this.length > 0) {
      var el = this[0];

      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return $([el.previousElementSibling]);
        }

        return $([]);
      }

      if (el.previousElementSibling) return $([el.previousElementSibling]);
      return $([]);
    }

    return $([]);
  }

  function prevAll(selector) {
    var prevEls = [];
    var el = this[0];
    if (!el) return $([]);

    while (el.previousElementSibling) {
      var _prev = el.previousElementSibling; // eslint-disable-line

      if (selector) {
        if ($(_prev).is(selector)) prevEls.push(_prev);
      } else prevEls.push(_prev);

      el = _prev;
    }

    return $(prevEls);
  }

  function parent(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }

    return $(parents);
  }

  function parents(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var _parent = this[i].parentNode; // eslint-disable-line

      while (_parent) {
        if (selector) {
          if ($(_parent).is(selector)) parents.push(_parent);
        } else {
          parents.push(_parent);
        }

        _parent = _parent.parentNode;
      }
    }

    return $(parents);
  }

  function closest(selector) {
    var closest = this; // eslint-disable-line

    if (typeof selector === 'undefined') {
      return $([]);
    }

    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }

    return closest;
  }

  function find(selector) {
    var foundElements = [];

    for (var i = 0; i < this.length; i += 1) {
      var found = this[i].querySelectorAll(selector);

      for (var j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }

    return $(foundElements);
  }

  function children(selector) {
    var children = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var childNodes = this[i].children;

      for (var j = 0; j < childNodes.length; j += 1) {
        if (!selector || $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }

    return $(children);
  }

  function remove() {
    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
    }

    return this;
  }

  var Methods = {
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    attr: attr,
    removeAttr: removeAttr,
    transform: transform,
    transition: transition,
    on: on,
    off: off,
    trigger: trigger,
    transitionEnd: transitionEnd,
    outerWidth: outerWidth,
    outerHeight: outerHeight,
    styles: styles,
    offset: offset,
    css: css,
    each: each,
    html: html,
    text: text,
    is: is,
    index: index,
    eq: eq,
    append: append,
    prepend: prepend,
    next: next,
    nextAll: nextAll,
    prev: prev,
    prevAll: prevAll,
    parent: parent,
    parents: parents,
    closest: closest,
    find: find,
    children: children,
    filter: filter,
    remove: remove
  };
  Object.keys(Methods).forEach(function (methodName) {
    $.fn[methodName] = Methods[methodName];
  });

  function deleteProps(obj) {
    var object = obj;
    Object.keys(object).forEach(function (key) {
      try {
        object[key] = null;
      } catch (e) {// no getter for object
      }

      try {
        delete object[key];
      } catch (e) {// something got wrong
      }
    });
  }

  function nextTick(callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return setTimeout(callback, delay);
  }

  function now() {
    return Date.now();
  }

  function getTranslate(el, axis) {
    if (axis === void 0) {
      axis = 'x';
    }

    var window = getWindow();
    var matrix;
    var curTransform;
    var transformMatrix;
    var curStyle = window.getComputedStyle(el, null);

    if (window.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;

      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(function (a) {
          return a.replace(',', '.');
        }).join(', ');
      } // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case


      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
    }

    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
    }

    return curTransform || 0;
  }

  function isObject$1(o) {
    return _typeof(o) === 'object' && o !== null && o.constructor && o.constructor === Object;
  }

  function extend$1() {
    var to = Object(arguments.length <= 0 ? undefined : arguments[0]);

    for (var i = 1; i < arguments.length; i += 1) {
      var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

      if (nextSource !== undefined && nextSource !== null) {
        var keysArray = Object.keys(Object(nextSource));

        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

          if (desc !== undefined && desc.enumerable) {
            if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
              extend$1(to[nextKey], nextSource[nextKey]);
            } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
              to[nextKey] = {};
              extend$1(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }

    return to;
  }

  function bindModuleMethods(instance, obj) {
    Object.keys(obj).forEach(function (key) {
      if (isObject$1(obj[key])) {
        Object.keys(obj[key]).forEach(function (subKey) {
          if (typeof obj[key][subKey] === 'function') {
            obj[key][subKey] = obj[key][subKey].bind(instance);
          }
        });
      }

      instance[key] = obj[key];
    });
  }

  var support;

  function calcSupport() {
    var window = getWindow();
    var document = getDocument();
    return {
      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
      pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
      observer: function checkObserver() {
        return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
      }(),
      passiveListener: function checkPassiveListener() {
        var supportsPassive = false;

        try {
          var opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get: function get() {
              supportsPassive = true;
            }
          });
          window.addEventListener('testPassiveListener', null, opts);
        } catch (e) {// No support
        }

        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return 'ongesturestart' in window;
      }()
    };
  }

  function getSupport() {
    if (!support) {
      support = calcSupport();
    }

    return support;
  }

  var device;

  function calcDevice(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        userAgent = _ref.userAgent;

    var support = getSupport();
    var window = getWindow();
    var platform = window.navigator.platform;
    var ua = userAgent || window.navigator.userAgent;
    var device = {
      ios: false,
      android: false
    };
    var screenWidth = window.screen.width;
    var screenHeight = window.screen.height;
    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    var windows = platform === 'Win32';
    var macos = platform === 'MacIntel'; // iPadOs 13 fix

    var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768'];

    if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, '13_0_0'];
      macos = false;
    } // Android


    if (android && !windows) {
      device.os = 'android';
      device.android = true;
    }

    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    } // Export object


    return device;
  }

  function getDevice(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    if (!device) {
      device = calcDevice(overrides);
    }

    return device;
  }

  var browser;

  function calcBrowser() {
    var window = getWindow();

    function isSafari() {
      var ua = window.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }

    return {
      isEdge: !!window.navigator.userAgent.match(/Edge/g),
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
    };
  }

  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }

    return browser;
  }

  var Resize = {
    name: 'resize',
    create: function create() {
      var swiper = this;
      extend$1(swiper, {
        resize: {
          resizeHandler: function resizeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            swiper.emit('beforeResize');
            swiper.emit('resize');
          },
          orientationChangeHandler: function orientationChangeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            swiper.emit('orientationchange');
          }
        }
      });
    },
    on: {
      init: function init(swiper) {
        var window = getWindow(); // Emit resize

        window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

        window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      },
      destroy: function destroy(swiper) {
        var window = getWindow();
        window.removeEventListener('resize', swiper.resize.resizeHandler);
        window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      }
    }
  };
  var Observer = {
    attach: function attach(target, options) {
      if (options === void 0) {
        options = {};
      }

      var window = getWindow();
      var swiper = this;
      var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
      var observer = new ObserverFunc(function (mutations) {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          swiper.emit('observerUpdate', mutations[0]);
          return;
        }

        var observerUpdate = function observerUpdate() {
          swiper.emit('observerUpdate', mutations[0]);
        };

        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(observerUpdate);
        } else {
          window.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      swiper.observer.observers.push(observer);
    },
    init: function init() {
      var swiper = this;
      if (!swiper.support.observer || !swiper.params.observer) return;

      if (swiper.params.observeParents) {
        var containerParents = swiper.$el.parents();

        for (var i = 0; i < containerParents.length; i += 1) {
          swiper.observer.attach(containerParents[i]);
        }
      } // Observe container


      swiper.observer.attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      }); // Observe wrapper

      swiper.observer.attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.observer.observers.forEach(function (observer) {
        observer.disconnect();
      });
      swiper.observer.observers = [];
    }
  };
  var Observer$1 = {
    name: 'observer',
    params: {
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        observer: _extends(_extends({}, Observer), {}, {
          observers: []
        })
      });
    },
    on: {
      init: function init(swiper) {
        swiper.observer.init();
      },
      destroy: function destroy(swiper) {
        swiper.observer.destroy();
      }
    }
  };
  var modular = {
    useParams: function useParams(instanceParams) {
      var instance = this;
      if (!instance.modules) return;
      Object.keys(instance.modules).forEach(function (moduleName) {
        var module = instance.modules[moduleName]; // Extend params

        if (module.params) {
          extend$1(instanceParams, module.params);
        }
      });
    },
    useModules: function useModules(modulesParams) {
      if (modulesParams === void 0) {
        modulesParams = {};
      }

      var instance = this;
      if (!instance.modules) return;
      Object.keys(instance.modules).forEach(function (moduleName) {
        var module = instance.modules[moduleName];
        var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

        if (module.on && instance.on) {
          Object.keys(module.on).forEach(function (moduleEventName) {
            instance.on(moduleEventName, module.on[moduleEventName]);
          });
        } // Module create callback


        if (module.create) {
          module.create.bind(instance)(moduleParams);
        }
      });
    }
  };
  /* eslint-disable no-underscore-dangle */

  var eventsEmitter = {
    on: function on(events, handler, priority) {
      var self = this;
      if (typeof handler !== 'function') return self;
      var method = priority ? 'unshift' : 'push';
      events.split(' ').forEach(function (event) {
        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
        self.eventsListeners[event][method](handler);
      });
      return self;
    },
    once: function once(events, handler, priority) {
      var self = this;
      if (typeof handler !== 'function') return self;

      function onceHandler() {
        self.off(events, onceHandler);

        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        handler.apply(self, args);
      }

      onceHandler.__emitterProxy = handler;
      return self.on(events, onceHandler, priority);
    },
    onAny: function onAny(handler, priority) {
      var self = this;
      if (typeof handler !== 'function') return self;
      var method = priority ? 'unshift' : 'push';

      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method](handler);
      }

      return self;
    },
    offAny: function offAny(handler) {
      var self = this;
      if (!self.eventsAnyListeners) return self;
      var index = self.eventsAnyListeners.indexOf(handler);

      if (index >= 0) {
        self.eventsAnyListeners.splice(index, 1);
      }

      return self;
    },
    off: function off(events, handler) {
      var self = this;
      if (!self.eventsListeners) return self;
      events.split(' ').forEach(function (event) {
        if (typeof handler === 'undefined') {
          self.eventsListeners[event] = [];
        } else if (self.eventsListeners[event]) {
          self.eventsListeners[event].forEach(function (eventHandler, index) {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event].splice(index, 1);
            }
          });
        }
      });
      return self;
    },
    emit: function emit() {
      var self = this;
      if (!self.eventsListeners) return self;
      var events;
      var data;
      var context;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (typeof args[0] === 'string' || Array.isArray(args[0])) {
        events = args[0];
        data = args.slice(1, args.length);
        context = self;
      } else {
        events = args[0].events;
        data = args[0].data;
        context = args[0].context || self;
      }

      data.unshift(context);
      var eventsArray = Array.isArray(events) ? events : events.split(' ');
      eventsArray.forEach(function (event) {
        if (self.eventsListeners && self.eventsListeners[event]) {
          var handlers = [];
          self.eventsListeners[event].forEach(function (eventHandler) {
            handlers.push(eventHandler);
          });
          handlers.forEach(function (eventHandler) {
            eventHandler.apply(context, data);
          });
        }
      });
      return self;
    }
  };

  function updateSize() {
    var swiper = this;
    var width;
    var height;
    var $el = swiper.$el;

    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }

    if (typeof swiper.params.height !== 'undefined' && swiper.params.width !== null) {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }

    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    } // Subtract paddings


    width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
    height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    extend$1(swiper, {
      width: width,
      height: height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    var swiper = this;
    var window = getWindow();
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl,
        swiperSize = swiper.size,
        rtl = swiper.rtlTranslate,
        wrongRTL = swiper.wrongRTL;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    var slides = $wrapperEl.children("." + swiper.params.slideClass);
    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    var snapGrid = [];
    var slidesGrid = [];
    var slidesSizesGrid = [];

    function slidesForMargin(slideEl, slideIndex) {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }

    var offsetBefore = params.slidesOffsetBefore;

    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    var offsetAfter = params.slidesOffsetAfter;

    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    var previousSnapGridLength = swiper.snapGrid.length;
    var previousSlidesGridLength = swiper.snapGrid.length;
    var spaceBetween = params.spaceBetween;
    var slidePosition = -offsetBefore;
    var prevSlideSize = 0;
    var index = 0;

    if (typeof swiperSize === 'undefined') {
      return;
    }

    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    }

    swiper.virtualSize = -spaceBetween; // reset margins

    if (rtl) slides.css({
      marginLeft: '',
      marginTop: ''
    });else slides.css({
      marginRight: '',
      marginBottom: ''
    });
    var slidesNumberEvenToRows;

    if (params.slidesPerColumn > 1) {
      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
      }

      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
      }
    } // Calc slides


    var slideSize;
    var slidesPerColumn = params.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

    for (var i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      var slide = slides.eq(i);

      if (params.slidesPerColumn > 1) {
        // Set slides order
        var newSlideOrderIndex = void 0;
        var column = void 0;
        var row = void 0;

        if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
          var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
          var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
          var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
          newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
          slide.css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex
          });
        } else if (params.slidesPerColumnFill === 'column') {
          column = Math.floor(i / slidesPerColumn);
          row = i - column * slidesPerColumn;

          if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
            row += 1;

            if (row >= slidesPerColumn) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }

        slide.css("margin-" + (swiper.isHorizontal() ? 'top' : 'left'), row !== 0 && params.spaceBetween && params.spaceBetween + "px");
      }

      if (slide.css('display') === 'none') continue; // eslint-disable-line

      if (params.slidesPerView === 'auto') {
        var slideStyles = window.getComputedStyle(slide[0], null);
        var currentTransform = slide[0].style.transform;
        var currentWebKitTransform = slide[0].style.webkitTransform;

        if (currentTransform) {
          slide[0].style.transform = 'none';
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }

        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          if (swiper.isHorizontal()) {
            var width = parseFloat(slideStyles.getPropertyValue('width') || 0);
            var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left') || 0);
            var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right') || 0);
            var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left') || 0);
            var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right') || 0);
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
            }
          } else {
            var height = parseFloat(slideStyles.getPropertyValue('height') || 0);
            var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top') || 0);
            var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom') || 0);
            var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top') || 0);
            var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom') || 0);

            var _boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (_boxSizing && _boxSizing === 'border-box') {
              slideSize = height + marginTop + marginBottom;
            } else {
              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
            }
          }
        }

        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }

        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);

        if (slides[i]) {
          if (swiper.isHorizontal()) {
            slides[i].style.width = slideSize + "px";
          } else {
            slides[i].style.height = slideSize + "px";
          }
        }
      }

      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }

      slidesSizesGrid.push(slideSize);

      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }

    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    var newSlidesGrid;

    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({
        width: swiper.virtualSize + params.spaceBetween + "px"
      });
    }

    if (params.setWrapperSize) {
      if (swiper.isHorizontal()) $wrapperEl.css({
        width: swiper.virtualSize + params.spaceBetween + "px"
      });else $wrapperEl.css({
        height: swiper.virtualSize + params.spaceBetween + "px"
      });
    }

    if (params.slidesPerColumn > 1) {
      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
      if (swiper.isHorizontal()) $wrapperEl.css({
        width: swiper.virtualSize + params.spaceBetween + "px"
      });else $wrapperEl.css({
        height: swiper.virtualSize + params.spaceBetween + "px"
      });

      if (params.centeredSlides) {
        newSlidesGrid = [];

        for (var _i = 0; _i < snapGrid.length; _i += 1) {
          var slidesGridItem = snapGrid[_i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
        }

        snapGrid = newSlidesGrid;
      }
    } // Remove last grid elements depending on width


    if (!params.centeredSlides) {
      newSlidesGrid = [];

      for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
        var _slidesGridItem = snapGrid[_i2];
        if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

        if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(_slidesGridItem);
        }
      }

      snapGrid = newSlidesGrid;

      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }

    if (snapGrid.length === 0) snapGrid = [0];

    if (params.spaceBetween !== 0) {
      if (swiper.isHorizontal()) {
        if (rtl) slides.filter(slidesForMargin).css({
          marginLeft: spaceBetween + "px"
        });else slides.filter(slidesForMargin).css({
          marginRight: spaceBetween + "px"
        });
      } else slides.filter(slidesForMargin).css({
        marginBottom: spaceBetween + "px"
      });
    }

    if (params.centeredSlides && params.centeredSlidesBounds) {
      var allSlidesSize = 0;
      slidesSizesGrid.forEach(function (slideSizeValue) {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      var maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map(function (snap) {
        if (snap < 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }

    if (params.centerInsufficientSlides) {
      var _allSlidesSize = 0;
      slidesSizesGrid.forEach(function (slideSizeValue) {
        _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      _allSlidesSize -= params.spaceBetween;

      if (_allSlidesSize < swiperSize) {
        var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
        snapGrid.forEach(function (snap, snapIndex) {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach(function (snap, snapIndex) {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    extend$1(swiper, {
      slides: slides,
      snapGrid: snapGrid,
      slidesGrid: slidesGrid,
      slidesSizesGrid: slidesSizesGrid
    });

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }

    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit('snapGridLengthChange');
    }

    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateSlidesOffset();
    }
  }

  function updateAutoHeight(speed) {
    var swiper = this;
    var activeSlides = [];
    var newHeight = 0;
    var i;

    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    } // Find slides currently in view


    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        swiper.visibleSlides.each(function (slide) {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          var index = swiper.activeIndex + i;
          if (index > swiper.slides.length) break;
          activeSlides.push(swiper.slides.eq(index)[0]);
        }
      }
    } else {
      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
    } // Find new height from highest slide in view


    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        var height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    } // Update Height


    if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
  }

  function updateSlidesOffset() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress(translate) {
    if (translate === void 0) {
      translate = this && this.translate || 0;
    }

    var swiper = this;
    var params = swiper.params;
    var slides = swiper.slides,
        rtl = swiper.rtlTranslate;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    var offsetCenter = -translate;
    if (rtl) offsetCenter = translate; // Visible Slides

    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (var i = 0; i < slides.length; i += 1) {
      var slide = slides[i];
      var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

      if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
      }

      slide.progress = rtl ? -slideProgress : slideProgress;
    }

    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress(translate) {
    var swiper = this;

    if (typeof translate === 'undefined') {
      var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }

    var params = swiper.params;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    var progress = swiper.progress,
        isBeginning = swiper.isBeginning,
        isEnd = swiper.isEnd;
    var wasBeginning = isBeginning;
    var wasEnd = isEnd;

    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }

    extend$1(swiper, {
      progress: progress,
      isBeginning: isBeginning,
      isEnd: isEnd
    });
    if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }

    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }

    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    var swiper = this;
    var slides = swiper.slides,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex,
        realIndex = swiper.realIndex;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
    var activeSlide;

    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
    } else {
      activeSlide = slides.eq(activeIndex);
    } // Active classes


    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      }
    } // Next Slide


    var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    } // Prev Slide


    var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }

    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      }

      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      }
    }

    swiper.emitSlidesClasses();
  }

  function updateActiveIndex(newActiveIndex) {
    var swiper = this;
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    var slidesGrid = swiper.slidesGrid,
        snapGrid = swiper.snapGrid,
        params = swiper.params,
        previousIndex = swiper.activeIndex,
        previousRealIndex = swiper.realIndex,
        previousSnapIndex = swiper.snapIndex;
    var activeIndex = newActiveIndex;
    var snapIndex;

    if (typeof activeIndex === 'undefined') {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      } // Normalize slideIndex


      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
      }
    }

    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }

    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }

      return;
    } // Get real index


    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    extend$1(swiper, {
      snapIndex: snapIndex,
      realIndex: realIndex,
      previousIndex: previousIndex,
      activeIndex: activeIndex
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');

    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }

    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide(e) {
    var swiper = this;
    var params = swiper.params;
    var slide = $(e.target).closest("." + params.slideClass)[0];
    var slideFound = false;

    if (slide) {
      for (var i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) slideFound = true;
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;

      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = $(slide).index();
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }

    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update = {
    updateSize: updateSize,
    updateSlides: updateSlides,
    updateAutoHeight: updateAutoHeight,
    updateSlidesOffset: updateSlidesOffset,
    updateSlidesProgress: updateSlidesProgress,
    updateProgress: updateProgress,
    updateSlidesClasses: updateSlidesClasses,
    updateActiveIndex: updateActiveIndex,
    updateClickedSlide: updateClickedSlide
  };

  function getSwiperTranslate(axis) {
    if (axis === void 0) {
      axis = this.isHorizontal() ? 'x' : 'y';
    }

    var swiper = this;
    var params = swiper.params,
        rtl = swiper.rtlTranslate,
        translate = swiper.translate,
        $wrapperEl = swiper.$wrapperEl;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }

    if (params.cssMode) {
      return translate;
    }

    var currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    var swiper = this;
    var rtl = swiper.rtlTranslate,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        wrapperEl = swiper.wrapperEl,
        progress = swiper.progress;
    var x = 0;
    var y = 0;
    var z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
    }

    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
    if (translate === void 0) {
      translate = 0;
    }

    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    if (translateBounds === void 0) {
      translateBounds = true;
    }

    var swiper = this;
    var params = swiper.params,
        wrapperEl = swiper.wrapperEl;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    var minTranslate = swiper.minTranslate();
    var maxTranslate = swiper.maxTranslate();
    var newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

    swiper.updateProgress(newTranslate);

    if (params.cssMode) {
      var isH = swiper.isHorizontal();

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          var _wrapperEl$scrollTo;

          wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        }
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;

            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
      }
    }

    return true;
  }

  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate: setTranslate,
    minTranslate: minTranslate,
    maxTranslate: maxTranslate,
    translateTo: translateTo
  };

  function setTransition(duration, byController) {
    var swiper = this;

    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }

    swiper.emit('setTransition', duration, byController);
  }

  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var activeIndex = swiper.activeIndex,
        params = swiper.params,
        previousIndex = swiper.previousIndex;
    if (params.cssMode) return;

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
    }

    swiper.emit('transitionStart');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionStart');
        return;
      }

      swiper.emit('slideChangeTransitionStart');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionStart');
      } else {
        swiper.emit('slidePrevTransitionStart');
      }
    }
  }

  function transitionEnd$1(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var activeIndex = swiper.activeIndex,
        previousIndex = swiper.previousIndex,
        params = swiper.params;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
    }

    swiper.emit('transitionEnd');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionEnd');
        return;
      }

      swiper.emit('slideChangeTransitionEnd');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionEnd');
      } else {
        swiper.emit('slidePrevTransitionEnd');
      }
    }
  }

  var transition$1 = {
    setTransition: setTransition,
    transitionStart: transitionStart,
    transitionEnd: transitionEnd$1
  };

  function slideTo(index, speed, runCallbacks, internal) {
    if (index === void 0) {
      index = 0;
    }

    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    var params = swiper.params,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        previousIndex = swiper.previousIndex,
        activeIndex = swiper.activeIndex,
        rtl = swiper.rtlTranslate,
        wrapperEl = swiper.wrapperEl;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    var translate = -snapGrid[snapIndex]; // Update progress

    swiper.updateProgress(translate); // Normalize slideIndex

    if (params.normalizeSlideIndex) {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
          slideIndex = i;
        }
      }
    } // Directions locks


    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }

      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }

    var direction;
    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex); // Update Height

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      swiper.updateSlidesClasses();

      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }

      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }

      return false;
    }

    if (params.cssMode) {
      var isH = swiper.isHorizontal();
      var t = -translate;

      if (rtl) {
        t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
      }

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          var _wrapperEl$scrollTo;

          wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        }
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
    }

    return true;
  }

  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
      index = 0;
    }

    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var newIndex = index;

    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var params = swiper.params,
        animating = swiper.animating;
    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    var params = swiper.params,
        animating = swiper.animating,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        rtlTranslate = swiper.rtlTranslate;

    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    var translate = rtlTranslate ? swiper.translate : -swiper.translate;

    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }

    var normalizedTranslate = normalize(translate);
    var normalizedSnapGrid = snapGrid.map(function (val) {
      return normalize(val);
    });
    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

    if (typeof prevSnap === 'undefined' && params.cssMode) {
      snapGrid.forEach(function (snap) {
        if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
      });
    }

    var prevIndex;

    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    }

    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    var swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (speed === void 0) {
      speed = this.params.speed;
    }

    if (runCallbacks === void 0) {
      runCallbacks = true;
    }

    if (threshold === void 0) {
      threshold = 0.5;
    }

    var swiper = this;
    var index = swiper.activeIndex;
    var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      var currentSnap = swiper.snapGrid[snapIndex];
      var nextSnap = swiper.snapGrid[snapIndex + 1];

      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      var prevSnap = swiper.snapGrid[snapIndex - 1];
      var _currentSnap = swiper.snapGrid[snapIndex];

      if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }

    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    var swiper = this;
    var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl;
    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    var slideToIndex = swiper.clickedIndex;
    var realIndex;

    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo: slideTo,
    slideToLoop: slideToLoop,
    slideNext: slideNext,
    slidePrev: slidePrev,
    slideReset: slideReset,
    slideToClosest: slideToClosest,
    slideToClickedSlide: slideToClickedSlide
  };

  function loopCreate() {
    var swiper = this;
    var document = getDocument();
    var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
    var slides = $wrapperEl.children("." + params.slideClass);

    if (params.loopFillGroupWithBlank) {
      var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

      if (blankSlidesNum !== params.slidesPerGroup) {
        for (var i = 0; i < blankSlidesNum; i += 1) {
          var blankNode = $(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
          $wrapperEl.append(blankNode);
        }

        slides = $wrapperEl.children("." + params.slideClass);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;

    if (swiper.loopedSlides > slides.length) {
      swiper.loopedSlides = slides.length;
    }

    var prependSlides = [];
    var appendSlides = [];
    slides.each(function (el, index) {
      var slide = $(el);

      if (index < swiper.loopedSlides) {
        appendSlides.push(el);
      }

      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
        prependSlides.push(el);
      }

      slide.attr('data-swiper-slide-index', index);
    });

    for (var _i = 0; _i < appendSlides.length; _i += 1) {
      $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }

    for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
      $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix() {
    var swiper = this;
    swiper.emit('beforeLoopFix');
    var activeIndex = swiper.activeIndex,
        slides = swiper.slides,
        loopedSlides = swiper.loopedSlides,
        allowSlidePrev = swiper.allowSlidePrev,
        allowSlideNext = swiper.allowSlideNext,
        snapGrid = swiper.snapGrid,
        rtl = swiper.rtlTranslate;
    var newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    var snapTranslate = -snapGrid[activeIndex];
    var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      var slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;

      var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (_slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }

    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
  }

  function loopDestroy() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        slides = swiper.slides;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate: loopCreate,
    loopFix: loopFix,
    loopDestroy: loopDestroy
  };

  function setGrabCursor(moving) {
    var swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    var el = swiper.el;
    el.style.cursor = 'move';
    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor() {
    var swiper = this;

    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }

    swiper.el.style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor: setGrabCursor,
    unsetGrabCursor: unsetGrabCursor
  };

  function appendSlide(slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params;

    if (params.loop) {
      swiper.loopDestroy();
    }

    if (_typeof(slides) === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.append(slides[i]);
      }
    } else {
      $wrapperEl.append(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && swiper.support.observer)) {
      swiper.update();
    }
  }

  function prependSlide(slides) {
    var swiper = this;
    var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;

    if (params.loop) {
      swiper.loopDestroy();
    }

    var newActiveIndex = activeIndex + 1;

    if (_typeof(slides) === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.prepend(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && swiper.support.observer)) {
      swiper.update();
    }

    swiper.slideTo(newActiveIndex, 0, false);
  }

  function addSlide(index, slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var baseLength = swiper.slides.length;

    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }

    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }

    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    var slidesBuffer = [];

    for (var i = baseLength - 1; i >= index; i -= 1) {
      var currentSlide = swiper.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }

    if (_typeof(slides) === 'object' && 'length' in slides) {
      for (var _i = 0; _i < slides.length; _i += 1) {
        if (slides[_i]) $wrapperEl.append(slides[_i]);
      }

      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }

    for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
      $wrapperEl.append(slidesBuffer[_i2]);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && swiper.support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeSlide(slidesIndexes) {
    var swiper = this;
    var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var newActiveIndex = activeIndexBuffer;
    var indexToRemove;

    if (_typeof(slidesIndexes) === 'object' && 'length' in slidesIndexes) {
      for (var i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      newActiveIndex = Math.max(newActiveIndex, 0);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && swiper.support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeAllSlides() {
    var swiper = this;
    var slidesIndexes = [];

    for (var i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }

    swiper.removeSlide(slidesIndexes);
  }

  var manipulation = {
    appendSlide: appendSlide,
    prependSlide: prependSlide,
    addSlide: addSlide,
    removeSlide: removeSlide,
    removeAllSlides: removeAllSlides
  };

  function onTouchStart(event) {
    var swiper = this;
    var document = getDocument();
    var window = getWindow();
    var data = swiper.touchEventsData;
    var params = swiper.params,
        touches = swiper.touches;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }

    var e = event;
    if (e.originalEvent) e = e.originalEvent;
    var $targetEl = $(e.target);

    if (params.touchEventsTarget === 'wrapper') {
      if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }

    data.isTouchEvent = e.type === 'touchstart';
    if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
    if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;

    if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
      swiper.allowClick = true;
      return;
    }

    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    var startX = touches.currentX;
    var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.screen.width - edgeSwipeThreshold)) {
      return;
    }

    extend$1(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;

    if (e.type !== 'touchstart') {
      var preventDefault = true;
      if ($targetEl.is(data.formElements)) preventDefault = false;

      if (document.activeElement && $(document.activeElement).is(data.formElements) && document.activeElement !== $targetEl[0]) {
        document.activeElement.blur();
      }

      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

      if (params.touchStartForcePreventDefault || shouldPreventDefault) {
        e.preventDefault();
      }
    }

    swiper.emit('touchStart', e);
  }

  function onTouchMove(event) {
    var document = getDocument();
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate;
    var e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      return;
    }

    if (data.isTouchEvent && e.type !== 'touchmove') return;
    var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
    var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }

    if (!swiper.allowTouchMove) {
      // isMoved = true;
      swiper.allowClick = false;

      if (data.isTouched) {
        extend$1(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }

      return;
    }

    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }

    if (data.isTouchEvent && document.activeElement) {
      if (e.target === document.activeElement && $(e.target).is(data.formElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }

    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    var diffX = touches.currentX - touches.startX;
    var diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

    if (typeof data.isScrolling === 'undefined') {
      var touchAngle;

      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }

    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }

    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }

    if (!data.startMoving) {
      return;
    }

    swiper.allowClick = false;

    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }

    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop) {
        swiper.loopFix();
      }

      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);

      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }

      data.allowMomentumBounce = false; // Grab Cursor

      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }

      swiper.emit('sliderFirstMove', e);
    }

    swiper.emit('sliderMove', e);
    data.isMoved = true;
    var diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;
    var disableParentSwiper = true;
    var resistanceRatio = params.resistanceRatio;

    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }

    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    } // Directions locks


    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    } // Threshold


    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger || params.cssMode) return; // Update active index in free mode

    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    if (params.freeMode) {
      // Velocity
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
          time: data.touchStartTime
        });
      }

      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
        time: now()
      });
    } // Update progress


    swiper.updateProgress(data.currentTranslate); // Update translate

    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate,
        $wrapperEl = swiper.$wrapperEl,
        slidesGrid = swiper.slidesGrid,
        snapGrid = swiper.snapGrid;
    var e = event;
    if (e.originalEvent) e = e.originalEvent;

    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }

    data.allowTouchCallbacks = false;

    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }

      data.isMoved = false;
      data.startMoving = false;
      return;
    } // Return Grab Cursor


    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    } // Time diff


    var touchEndTime = now();
    var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

    if (swiper.allowClick) {
      swiper.updateClickedSlide(e);
      swiper.emit('tap click', e);

      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }

    data.lastClickTime = now();
    nextTick(function () {
      if (!swiper.destroyed) swiper.allowClick = true;
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }

    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    var currentPos;

    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.cssMode) {
      return;
    }

    if (params.freeMode) {
      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }

        return;
      }

      if (params.freeModeMomentum) {
        if (data.velocities.length > 1) {
          var lastMoveEvent = data.velocities.pop();
          var velocityEvent = data.velocities.pop();
          var distance = lastMoveEvent.position - velocityEvent.position;
          var time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;

          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
            swiper.velocity = 0;
          } // this implies that the user stopped moving a finger then released.
          // There would be no events with distance zero, so the last event is stale.


          if (time > 150 || now() - lastMoveEvent.time > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }

        swiper.velocity *= params.freeModeMomentumVelocityRatio;
        data.velocities.length = 0;
        var momentumDuration = 1000 * params.freeModeMomentumRatio;
        var momentumDistance = swiper.velocity * momentumDuration;
        var newPosition = swiper.translate + momentumDistance;
        if (rtl) newPosition = -newPosition;
        var doBounce = false;
        var afterBouncePosition;
        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
        var needsLoopFix;

        if (newPosition < swiper.maxTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }

            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }

          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }

            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }

          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (params.freeModeSticky) {
          var nextSlide;

          for (var j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }

          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }

          newPosition = -newPosition;
        }

        if (needsLoopFix) {
          swiper.once('transitionEnd', function () {
            swiper.loopFix();
          });
        } // Fix duration


        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }

          if (params.freeModeSticky) {
            // If freeModeSticky is active and the user ends a swipe with a slow-velocity
            // event, then durations can be 20+ seconds to slide one (or zero!) slides.
            // It's easy to see this when simulating touch with mouse events. To fix this,
            // limit single-slide swipes to the default slide duration. This also has the
            // nice side effect of matching slide speed if the user stopped moving before
            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
            // For faster swipes, also apply limits (albeit higher ones).
            var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
            var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        }

        if (params.freeModeMomentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
            swiper.emit('momentumBounce');
            swiper.setTransition(params.speed);
            setTimeout(function () {
              swiper.setTranslate(afterBouncePosition);
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }, 0);
          });
        } else if (swiper.velocity) {
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);

          if (!swiper.animating) {
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      return;
    } // Find current slide


    var stopIndex = 0;
    var groupSize = swiper.slidesSizesGrid[0];

    for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (typeof slidesGrid[i + _increment] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
          stopIndex = i;
          groupSize = slidesGrid[i + _increment] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    } // Find current slide size


    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
      }

      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(stopIndex + increment);
        }

        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    var swiper = this;
    var params = swiper.params,
        el = swiper.el;
    if (el && el.offsetWidth === 0) return; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    } // Save locks


    var allowSlideNext = swiper.allowSlideNext,
        allowSlidePrev = swiper.allowSlidePrev,
        snapGrid = swiper.snapGrid; // Disable locks on resize

    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();

    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }

    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    } // Return locks after resize


    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    var swiper = this;

    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e.preventDefault();

      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll() {
    var swiper = this;
    var wrapperEl = swiper.wrapperEl,
        rtlTranslate = swiper.rtlTranslate;
    swiper.previousTranslate = swiper.translate;

    if (swiper.isHorizontal()) {
      if (rtlTranslate) {
        swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollLeft;
      }
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    } // eslint-disable-next-line


    if (swiper.translate === -0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }

    swiper.emit('setTranslate', swiper.translate, false);
  }

  var dummyEventAttached = false;

  function dummyEventListener() {}

  function attachEvents() {
    var swiper = this;
    var document = getDocument();
    var params = swiper.params,
        touchEvents = swiper.touchEvents,
        el = swiper.el,
        wrapperEl = swiper.wrapperEl,
        device = swiper.device,
        support = swiper.support;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);

    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }

    swiper.onClick = onClick.bind(swiper);
    var capture = !!params.nested; // Touch Events

    if (!support.touch && support.pointerEvents) {
      el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (support.touch) {
        var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture: capture
        } : capture);
        el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }

        if (!dummyEventAttached) {
          document.addEventListener('touchstart', dummyEventListener);
          dummyEventAttached = true;
        }
      }

      if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
        el.addEventListener('mousedown', swiper.onTouchStart, false);
        document.addEventListener('mousemove', swiper.onTouchMove, capture);
        document.addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el.addEventListener('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl.addEventListener('scroll', swiper.onScroll);
    } // Resize handler


    if (params.updateOnWindowResize) {
      swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
      swiper.on('observerUpdate', onResize, true);
    }
  }

  function detachEvents() {
    var swiper = this;
    var document = getDocument();
    var params = swiper.params,
        touchEvents = swiper.touchEvents,
        el = swiper.el,
        wrapperEl = swiper.wrapperEl,
        device = swiper.device,
        support = swiper.support;
    var capture = !!params.nested; // Touch Events

    if (!support.touch && support.pointerEvents) {
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (support.touch) {
        var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      }

      if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
        el.removeEventListener('mousedown', swiper.onTouchStart, false);
        document.removeEventListener('mousemove', swiper.onTouchMove, capture);
        document.removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el.removeEventListener('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl.removeEventListener('scroll', swiper.onScroll);
    } // Resize handler


    swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
  }

  var events = {
    attachEvents: attachEvents,
    detachEvents: detachEvents
  };

  function setBreakpoint() {
    var swiper = this;
    var activeIndex = swiper.activeIndex,
        initialized = swiper.initialized,
        _swiper$loopedSlides = swiper.loopedSlides,
        loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
        params = swiper.params,
        $el = swiper.$el;
    var breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

    var breakpoint = swiper.getBreakpoint(breakpoints);

    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");

        if (breakpointParams.slidesPerColumnFill === 'column') {
          $el.addClass(params.containerModifierClass + "multirow-column");
        }

        swiper.emitContainerClasses();
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      extend$1(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });
      swiper.currentBreakpoint = breakpoint;

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }
  }

  function getBreakpoints(breakpoints) {
    var window = getWindow(); // Get breakpoint for window width

    if (!breakpoints) return undefined;
    var breakpoint = false;
    var points = Object.keys(breakpoints).map(function (point) {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        var minRatio = parseFloat(point.substr(1));
        var value = window.innerHeight * minRatio;
        return {
          value: value,
          point: point
        };
      }

      return {
        value: point,
        point: point
      };
    });
    points.sort(function (a, b) {
      return parseInt(a.value, 10) - parseInt(b.value, 10);
    });

    for (var i = 0; i < points.length; i += 1) {
      var _points$i = points[i],
          point = _points$i.point,
          value = _points$i.value;

      if (value <= window.innerWidth) {
        breakpoint = point;
      }
    }

    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint: setBreakpoint,
    getBreakpoint: getBreakpoints
  };

  function addClasses() {
    var swiper = this;
    var classNames = swiper.classNames,
        params = swiper.params,
        rtl = swiper.rtl,
        $el = swiper.$el,
        device = swiper.device;
    var suffixes = [];
    suffixes.push('initialized');
    suffixes.push(params.direction);

    if (params.freeMode) {
      suffixes.push('free-mode');
    }

    if (params.autoHeight) {
      suffixes.push('autoheight');
    }

    if (rtl) {
      suffixes.push('rtl');
    }

    if (params.slidesPerColumn > 1) {
      suffixes.push('multirow');

      if (params.slidesPerColumnFill === 'column') {
        suffixes.push('multirow-column');
      }
    }

    if (device.android) {
      suffixes.push('android');
    }

    if (device.ios) {
      suffixes.push('ios');
    }

    if (params.cssMode) {
      suffixes.push('css-mode');
    }

    suffixes.forEach(function (suffix) {
      classNames.push(params.containerModifierClass + suffix);
    });
    $el.addClass(classNames.join(' '));
    swiper.emitContainerClasses();
  }

  function removeClasses() {
    var swiper = this;
    var $el = swiper.$el,
        classNames = swiper.classNames;
    $el.removeClass(classNames.join(' '));
    swiper.emitContainerClasses();
  }

  var classes = {
    addClasses: addClasses,
    removeClasses: removeClasses
  };

  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    var window = getWindow();
    var image;

    function onReady() {
      if (callback) callback();
    }

    var isPicture = $(imageEl).parent('picture')[0];

    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image = new window.Image();
        image.onload = onReady;
        image.onerror = onReady;

        if (sizes) {
          image.sizes = sizes;
        }

        if (srcset) {
          image.srcset = srcset;
        }

        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages() {
    var swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');

    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
      if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) swiper.update();
        swiper.emit('imagesReady');
      }
    }

    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
      var imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
    }
  }

  var images = {
    loadImage: loadImage,
    preloadImages: preloadImages
  };

  function checkOverflow() {
    var swiper = this;
    var params = swiper.params;
    var wasLocked = swiper.isLocked;
    var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

    if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
      swiper.isLocked = lastSlidePosition <= swiper.size;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }

    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked; // events

    if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
      if (swiper.navigation) swiper.navigation.update();
    }
  }

  var checkOverflow$1 = {
    checkOverflow: checkOverflow
  };
  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Free mode
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: false,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    // NS
    containerModifierClass: 'swiper-container-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };
  var prototypes = {
    modular: modular,
    eventsEmitter: eventsEmitter,
    update: update,
    translate: translate,
    transition: transition$1,
    slide: slide,
    loop: loop,
    grabCursor: grabCursor,
    manipulation: manipulation,
    events: events,
    breakpoints: breakpoints,
    checkOverflow: checkOverflow$1,
    classes: classes,
    images: images
  };
  var extendedDefaults = {};

  var Swiper = /*#__PURE__*/function () {
    function Swiper() {
      var el;
      var params;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
        params = args[0];
      } else {
        el = args[0];
        params = args[1];
      }

      if (!params) params = {};
      params = extend$1({}, params);
      if (el && !params.el) params.el = el; // Swiper Instance

      var swiper = this;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      Object.keys(prototypes).forEach(function (prototypeGroup) {
        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
          if (!Swiper.prototype[protoMethod]) {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
          }
        });
      });

      if (typeof swiper.modules === 'undefined') {
        swiper.modules = {};
      }

      Object.keys(swiper.modules).forEach(function (moduleName) {
        var module = swiper.modules[moduleName];

        if (module.params) {
          var moduleParamName = Object.keys(module.params)[0];
          var moduleParams = module.params[moduleParamName];
          if (_typeof(moduleParams) !== 'object' || moduleParams === null) return;
          if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

          if (params[moduleParamName] === true) {
            params[moduleParamName] = {
              enabled: true
            };
          }

          if (_typeof(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {
            params[moduleParamName].enabled = true;
          }

          if (!params[moduleParamName]) params[moduleParamName] = {
            enabled: false
          };
        }
      }); // Extend defaults with modules params

      var swiperParams = extend$1({}, defaults);
      swiper.useParams(swiperParams); // Extend defaults with passed params

      swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend$1({}, swiper.params);
      swiper.passedParams = extend$1({}, params); // add event listeners

      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach(function (eventName) {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      } // Save Dom lib


      swiper.$ = $; // Find el

      var $el = $(swiper.params.el);
      el = $el[0];

      if (!el) {
        return undefined;
      }

      if ($el.length > 1) {
        var swipers = [];
        $el.each(function (containerEl) {
          var newParams = extend$1({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }

      el.swiper = swiper; // Find Wrapper

      var $wrapperEl;

      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        $wrapperEl = $(el.shadowRoot.querySelector("." + swiper.params.wrapperClass)); // Children needs to return slot items

        $wrapperEl.children = function (options) {
          return $el.children(options);
        };
      } else {
        $wrapperEl = $el.children("." + swiper.params.wrapperClass);
      } // Extend Swiper


      extend$1(swiper, {
        $el: $el,
        el: el,
        $wrapperEl: $wrapperEl,
        wrapperEl: $wrapperEl[0],
        // Classes
        classNames: [],
        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal: function isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },
        isVertical: function isVertical() {
          return swiper.params.direction === 'vertical';
        },
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box',
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
          var desktop = ['mousedown', 'mousemove', 'mouseup'];

          if (swiper.support.pointerEvents) {
            desktop = ['pointerdown', 'pointermove', 'pointerup'];
          }

          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          formElements: 'input, select, option, textarea, button, video, label',
          // Last click time
          lastClickTime: now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      }); // Install Modules

      swiper.useModules();
      swiper.emit('_swiper'); // Init

      if (swiper.params.init) {
        swiper.init();
      } // Return app instance


      return swiper;
    }

    var _proto = Swiper.prototype;

    _proto.emitContainerClasses = function emitContainerClasses() {
      var swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      var classes = swiper.el.className.split(' ').filter(function (className) {
        return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit('_containerClasses', classes.join(' '));
    };

    _proto.emitSlidesClasses = function emitSlidesClasses() {
      var swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      swiper.slides.each(function (slideEl) {
        var classes = slideEl.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        });
        swiper.emit('_slideClass', slideEl, classes.join(' '));
      });
    };

    _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
      var swiper = this;
      var params = swiper.params,
          slides = swiper.slides,
          slidesGrid = swiper.slidesGrid,
          swiperSize = swiper.size,
          activeIndex = swiper.activeIndex;
      var spv = 1;

      if (params.centeredSlides) {
        var slideSize = slides[activeIndex].swiperSlideSize;
        var breakLoop;

        for (var i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }

        for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
          if (slides[_i] && !breakLoop) {
            slideSize += slides[_i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
          if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
            spv += 1;
          }
        }
      }

      return spv;
    };

    _proto.update = function update() {
      var swiper = this;
      if (!swiper || swiper.destroyed) return;
      var snapGrid = swiper.snapGrid,
          params = swiper.params; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      var translated;

      if (swiper.params.freeMode) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    };

    _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) {
        needUpdate = true;
      }

      var swiper = this;
      var currentDirection = swiper.params.direction;

      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }

      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }

      swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.each(function (slideEl) {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();
      return swiper;
    };

    _proto.init = function init() {
      var swiper = this;
      if (swiper.initialized) return;
      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
    };

    _proto.destroy = function destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) {
        deleteInstance = true;
      }

      if (cleanStyles === void 0) {
        cleanStyles = true;
      }

      var swiper = this;
      var params = swiper.params,
          $el = swiper.$el,
          $wrapperEl = swiper.$wrapperEl,
          slides = swiper.slides;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(function (eventName) {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    };

    Swiper.extendDefaults = function extendDefaults(newDefaults) {
      extend$1(extendedDefaults, newDefaults);
    };

    Swiper.installModule = function installModule(module) {
      if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
      var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
      Swiper.prototype.modules[name] = module;
    };

    Swiper.use = function use(module) {
      if (Array.isArray(module)) {
        module.forEach(function (m) {
          return Swiper.installModule(m);
        });
        return Swiper;
      }

      Swiper.installModule(module);
      return Swiper;
    };

    _createClass(Swiper, null, [{
      key: "extendedDefaults",
      get: function get() {
        return extendedDefaults;
      }
    }, {
      key: "defaults",
      get: function get() {
        return defaults;
      }
    }]);

    return Swiper;
  }();

  Swiper.use([Resize, Observer$1]);
  var Virtual = {
    update: function update(force) {
      var swiper = this;
      var _swiper$params = swiper.params,
          slidesPerView = _swiper$params.slidesPerView,
          slidesPerGroup = _swiper$params.slidesPerGroup,
          centeredSlides = _swiper$params.centeredSlides;
      var _swiper$params$virtua = swiper.params.virtual,
          addSlidesBefore = _swiper$params$virtua.addSlidesBefore,
          addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
      var _swiper$virtual = swiper.virtual,
          previousFrom = _swiper$virtual.from,
          previousTo = _swiper$virtual.to,
          slides = _swiper$virtual.slides,
          previousSlidesGrid = _swiper$virtual.slidesGrid,
          renderSlide = _swiper$virtual.renderSlide,
          previousOffset = _swiper$virtual.offset;
      swiper.updateActiveIndex();
      var activeIndex = swiper.activeIndex || 0;
      var offsetProp;
      if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
      var slidesAfter;
      var slidesBefore;

      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
        slidesBefore = slidesPerGroup + addSlidesBefore;
      }

      var from = Math.max((activeIndex || 0) - slidesBefore, 0);
      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
      extend$1(swiper.virtual, {
        from: from,
        to: to,
        offset: offset,
        slidesGrid: swiper.slidesGrid
      });

      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        if (swiper.lazy && swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      }

      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.css(offsetProp, offset + "px");
        }

        swiper.updateProgress();
        return;
      }

      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset: offset,
          from: from,
          to: to,
          slides: function getSlides() {
            var slidesToRender = [];

            for (var i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }

            return slidesToRender;
          }()
        });

        if (swiper.params.virtual.renderExternalUpdate) {
          onRendered();
        }

        return;
      }

      var prependIndexes = [];
      var appendIndexes = [];

      if (force) {
        swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
      } else {
        for (var i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + i + "\"]").remove();
          }
        }
      }

      for (var _i = 0; _i < slides.length; _i += 1) {
        if (_i >= from && _i <= to) {
          if (typeof previousTo === 'undefined' || force) {
            appendIndexes.push(_i);
          } else {
            if (_i > previousTo) appendIndexes.push(_i);
            if (_i < previousFrom) prependIndexes.push(_i);
          }
        }
      }

      appendIndexes.forEach(function (index) {
        swiper.$wrapperEl.append(renderSlide(slides[index], index));
      });
      prependIndexes.sort(function (a, b) {
        return b - a;
      }).forEach(function (index) {
        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
      });
      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, offset + "px");
      onRendered();
    },
    renderSlide: function renderSlide(slide, index) {
      var swiper = this;
      var params = swiper.params.virtual;

      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }

      var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $("<div class=\"" + swiper.params.slideClass + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>");
      if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
      if (params.cache) swiper.virtual.cache[index] = $slideEl;
      return $slideEl;
    },
    appendSlide: function appendSlide(slides) {
      var swiper = this;

      if (_typeof(slides) === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.push(slides[i]);
        }
      } else {
        swiper.virtual.slides.push(slides);
      }

      swiper.virtual.update(true);
    },
    prependSlide: function prependSlide(slides) {
      var swiper = this;
      var activeIndex = swiper.activeIndex;
      var newActiveIndex = activeIndex + 1;
      var numberOfNewSlides = 1;

      if (Array.isArray(slides)) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper.virtual.slides.unshift(slides);
      }

      if (swiper.params.virtual.cache) {
        var cache = swiper.virtual.cache;
        var newCache = {};
        Object.keys(cache).forEach(function (cachedIndex) {
          var $cachedEl = cache[cachedIndex];
          var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

          if (cachedElIndex) {
            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
          }

          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
        });
        swiper.virtual.cache = newCache;
      }

      swiper.virtual.update(true);
      swiper.slideTo(newActiveIndex, 0);
    },
    removeSlide: function removeSlide(slidesIndexes) {
      var swiper = this;
      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
      var activeIndex = swiper.activeIndex;

      if (Array.isArray(slidesIndexes)) {
        for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          swiper.virtual.slides.splice(slidesIndexes[i], 1);

          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes[i]];
          }

          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        swiper.virtual.slides.splice(slidesIndexes, 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes];
        }

        if (slidesIndexes < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }

      swiper.virtual.update(true);
      swiper.slideTo(activeIndex, 0);
    },
    removeAllSlides: function removeAllSlides() {
      var swiper = this;
      swiper.virtual.slides = [];

      if (swiper.params.virtual.cache) {
        swiper.virtual.cache = {};
      }

      swiper.virtual.update(true);
      swiper.slideTo(0, 0);
    }
  };
  var Virtual$1 = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: true,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        virtual: _extends(_extends({}, Virtual), {}, {
          slides: swiper.params.virtual.slides,
          cache: {}
        })
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (!swiper.params.virtual.enabled) return;
        swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
        var overwriteParams = {
          watchSlidesProgress: true
        };
        extend$1(swiper.params, overwriteParams);
        extend$1(swiper.originalParams, overwriteParams);

        if (!swiper.params.initialSlide) {
          swiper.virtual.update();
        }
      },
      setTranslate: function setTranslate(swiper) {
        if (!swiper.params.virtual.enabled) return;
        swiper.virtual.update();
      }
    }
  };
  var Keyboard = {
    handle: function handle(event) {
      var swiper = this;
      var window = getWindow();
      var document = getDocument();
      var rtl = swiper.rtlTranslate;
      var e = event;
      if (e.originalEvent) e = e.originalEvent; // jquery fix

      var kc = e.keyCode || e.charCode;
      var pageUpDown = swiper.params.keyboard.pageUpDown;
      var isPageUp = pageUpDown && kc === 33;
      var isPageDown = pageUpDown && kc === 34;
      var isArrowLeft = kc === 37;
      var isArrowRight = kc === 39;
      var isArrowUp = kc === 38;
      var isArrowDown = kc === 40; // Directions locks

      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
        return false;
      }

      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
        return false;
      }

      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return undefined;
      }

      if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
        return undefined;
      }

      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
        var inView = false; // Check that swiper should be inside of visible area of window

        if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
          return undefined;
        }

        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var swiperOffset = swiper.$el.offset();
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

        for (var i = 0; i < swiperCoord.length; i += 1) {
          var point = swiperCoord[i];

          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            inView = true;
          }
        }

        if (!inView) return undefined;
      }

      if (swiper.isHorizontal()) {
        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
          if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        }

        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
      } else {
        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
          if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        }

        if (isPageDown || isArrowDown) swiper.slideNext();
        if (isPageUp || isArrowUp) swiper.slidePrev();
      }

      swiper.emit('keyPress', kc);
      return undefined;
    },
    enable: function enable() {
      var swiper = this;
      var document = getDocument();
      if (swiper.keyboard.enabled) return;
      $(document).on('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = true;
    },
    disable: function disable() {
      var swiper = this;
      var document = getDocument();
      if (!swiper.keyboard.enabled) return;
      $(document).off('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = false;
    }
  };
  var Keyboard$1 = {
    name: 'keyboard',
    params: {
      keyboard: {
        enabled: false,
        onlyInViewport: true,
        pageUpDown: true
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        keyboard: _extends({
          enabled: false
        }, Keyboard)
      });
    },
    on: {
      init: function init(swiper) {
        if (swiper.params.keyboard.enabled) {
          swiper.keyboard.enable();
        }
      },
      destroy: function destroy(swiper) {
        if (swiper.keyboard.enabled) {
          swiper.keyboard.disable();
        }
      }
    }
  };

  function isEventSupported() {
    var document = getDocument();
    var eventName = 'onwheel';
    var isSupported = (eventName in document);

    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true) {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  var Mousewheel = {
    lastScrollTime: now(),
    lastEventBeforeSnap: undefined,
    recentWheelEvents: [],
    event: function event() {
      var window = getWindow();
      if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
      return isEventSupported() ? 'wheel' : 'mousewheel';
    },
    normalize: function normalize(e) {
      // Reasonable defaults
      var PIXEL_STEP = 10;
      var LINE_HEIGHT = 40;
      var PAGE_HEIGHT = 800;
      var sX = 0;
      var sY = 0; // spinX, spinY

      var pX = 0;
      var pY = 0; // pixelX, pixelY
      // Legacy

      if ('detail' in e) {
        sY = e.detail;
      }

      if ('wheelDelta' in e) {
        sY = -e.wheelDelta / 120;
      }

      if ('wheelDeltaY' in e) {
        sY = -e.wheelDeltaY / 120;
      }

      if ('wheelDeltaX' in e) {
        sX = -e.wheelDeltaX / 120;
      } // side scrolling on FF with DOMMouseScroll


      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in e) {
        pY = e.deltaY;
      }

      if ('deltaX' in e) {
        pX = e.deltaX;
      }

      if (e.shiftKey && !pX) {
        // if user scrolls with shift he wants horizontal scroll
        pX = pY;
        pY = 0;
      }

      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) {
          // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      } // Fall-back if spin cannot be determined


      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }

      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }

      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    },
    handleMouseEnter: function handleMouseEnter() {
      var swiper = this;
      swiper.mouseEntered = true;
    },
    handleMouseLeave: function handleMouseLeave() {
      var swiper = this;
      swiper.mouseEntered = false;
    },
    handle: function handle(event) {
      var e = event;
      var swiper = this;
      var params = swiper.params.mousewheel;

      if (swiper.params.cssMode) {
        e.preventDefault();
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarget !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarget);
      }

      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
      if (e.originalEvent) e = e.originalEvent; // jquery fix

      var delta = 0;
      var rtlFactor = swiper.rtlTranslate ? -1 : 1;
      var data = Mousewheel.normalize(e);

      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }

      if (delta === 0) return true;
      if (params.invert) delta = -delta;

      if (!swiper.params.freeMode) {
        // Register the new event in a variable which stores the relevant data
        var newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event
        }; // Keep the most recent events

        var recentWheelEvents = swiper.mousewheel.recentWheelEvents;

        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift(); // only store the last N events
        }

        var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
        recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
        //   If direction has changed or
        //   if the scroll is quicker than the previous one:
        //     Animate the slider.
        // Else (this is the first time the wheel is moved):
        //     Animate the slider.

        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
            swiper.mousewheel.animateSlider(newEvent);
          }
        } else {
          swiper.mousewheel.animateSlider(newEvent);
        } // If it's time to release the scroll:
        //   Return now so you don't hit the preventDefault.


        if (swiper.mousewheel.releaseScroll(newEvent)) {
          return true;
        }
      } else {
        // Freemode or scrollContainer:
        // If we recently snapped after a momentum scroll, then ignore wheel events
        // to give time for the deceleration to finish. Stop ignoring after 500 msecs
        // or if it's a new scroll (larger delta or inverse sign as last event before
        // an end-of-momentum snap).
        var _newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
        var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;

        if (!ignoreWheelEvents) {
          swiper.mousewheel.lastEventBeforeSnap = undefined;

          if (swiper.params.loop) {
            swiper.loopFix();
          }

          var position = swiper.getTranslate() + delta * params.sensitivity;
          var wasBeginning = swiper.isBeginning;
          var wasEnd = swiper.isEnd;
          if (position >= swiper.minTranslate()) position = swiper.minTranslate();
          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
          swiper.setTransition(0);
          swiper.setTranslate(position);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();

          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
            swiper.updateSlidesClasses();
          }

          if (swiper.params.freeModeSticky) {
            // When wheel scrolling starts with sticky (aka snap) enabled, then detect
            // the end of a momentum scroll by storing recent (N=15?) wheel events.
            // 1. do all N events have decreasing or same (absolute value) delta?
            // 2. did all N events arrive in the last M (M=500?) msecs?
            // 3. does the earliest event have an (absolute value) delta that's
            //    at least P (P=1?) larger than the most recent event's delta?
            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
            // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
            // Snap immediately and ignore remaining wheel events in this scroll.
            // See comment above for "remaining wheel events in this scroll" determination.
            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
            clearTimeout(swiper.mousewheel.timeout);
            swiper.mousewheel.timeout = undefined;
            var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;

            if (_recentWheelEvents.length >= 15) {
              _recentWheelEvents.shift(); // only store the last N events

            }

            var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;

            var firstEvent = _recentWheelEvents[0];

            _recentWheelEvents.push(_newEvent);

            if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
              _recentWheelEvents.splice(0);
            } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
              // We're at the end of the deceleration of a momentum scroll, so there's no need
              // to wait for more events. Snap ASAP on the next tick.
              // Also, because there's some remaining momentum we'll bias the snap in the
              // direction of the ongoing scroll because it's better UX for the scroll to snap
              // in the same direction as the scroll instead of reversing to snap.  Therefore,
              // if it's already scrolled more than 20% in the current direction, keep going.
              var snapToThreshold = delta > 0 ? 0.8 : 0.2;
              swiper.mousewheel.lastEventBeforeSnap = _newEvent;

              _recentWheelEvents.splice(0);

              swiper.mousewheel.timeout = nextTick(function () {
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 0); // no delay; move on next tick
            }

            if (!swiper.mousewheel.timeout) {
              // if we get here, then we haven't detected the end of a momentum scroll, so
              // we'll consider a scroll "complete" when there haven't been any wheel events
              // for 500ms.
              swiper.mousewheel.timeout = nextTick(function () {
                var snapToThreshold = 0.5;
                swiper.mousewheel.lastEventBeforeSnap = _newEvent;

                _recentWheelEvents.splice(0);

                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 500);
            }
          } // Emit event


          if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay

          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
        }
      }

      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      return false;
    },
    animateSlider: function animateSlider(newEvent) {
      var swiper = this;
      var window = getWindow();

      if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
        // Prevent if delta of wheel scroll delta is below configured threshold
        return false;
      }

      if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
        // Prevent if time between scrolls is below configured threshold
        return false;
      } // If the movement is NOT big enough and
      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
      //   Don't go any further (avoid insignificant scroll movement).


      if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {
        // Return false as a default
        return true;
      } // If user is scrolling towards the end:
      //   If the slider hasn't hit the latest slide or
      //   if the slider is a loop and
      //   if the slider isn't moving right now:
      //     Go to next slide and
      //     emit a scroll event.
      // Else (the user is scrolling towards the beginning) and
      // if the slider hasn't hit the first slide or
      // if the slider is a loop and
      // if the slider isn't moving right now:
      //   Go to prev slide and
      //   emit a scroll event.


      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          swiper.emit('scroll', newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        swiper.emit('scroll', newEvent.raw);
      } // If you got here is because an animation has been triggered so store the current time


      swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default

      return false;
    },
    releaseScroll: function releaseScroll(newEvent) {
      var swiper = this;
      var params = swiper.params.mousewheel;

      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }

      return false;
    },
    enable: function enable() {
      var swiper = this;
      var event = Mousewheel.event();

      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
        return true;
      }

      if (!event) return false;
      if (swiper.mousewheel.enabled) return false;
      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarget !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarget);
      }

      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
      target.on(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = true;
      return true;
    },
    disable: function disable() {
      var swiper = this;
      var event = Mousewheel.event();

      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
        return true;
      }

      if (!event) return false;
      if (!swiper.mousewheel.enabled) return false;
      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarget !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarget);
      }

      target.off(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = false;
      return true;
    }
  };
  var Mousewheel$1 = {
    name: 'mousewheel',
    params: {
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarget: 'container',
        thresholdDelta: null,
        thresholdTime: null
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        mousewheel: {
          enabled: false,
          lastScrollTime: now(),
          lastEventBeforeSnap: undefined,
          recentWheelEvents: [],
          enable: Mousewheel.enable,
          disable: Mousewheel.disable,
          handle: Mousewheel.handle,
          handleMouseEnter: Mousewheel.handleMouseEnter,
          handleMouseLeave: Mousewheel.handleMouseLeave,
          animateSlider: Mousewheel.animateSlider,
          releaseScroll: Mousewheel.releaseScroll
        }
      });
    },
    on: {
      init: function init(swiper) {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          swiper.mousewheel.disable();
        }

        if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
      },
      destroy: function destroy(swiper) {
        if (swiper.params.cssMode) {
          swiper.mousewheel.enable();
        }

        if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
      }
    }
  };
  var Navigation = {
    update: function update() {
      // Update Navigation Buttons
      var swiper = this;
      var params = swiper.params.navigation;
      if (swiper.params.loop) return;
      var _swiper$navigation = swiper.navigation,
          $nextEl = _swiper$navigation.$nextEl,
          $prevEl = _swiper$navigation.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          $prevEl.addClass(params.disabledClass);
        } else {
          $prevEl.removeClass(params.disabledClass);
        }

        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          $nextEl.addClass(params.disabledClass);
        } else {
          $nextEl.removeClass(params.disabledClass);
        }

        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    },
    onPrevClick: function onPrevClick(e) {
      var swiper = this;
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop) return;
      swiper.slidePrev();
    },
    onNextClick: function onNextClick(e) {
      var swiper = this;
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop) return;
      swiper.slideNext();
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.navigation;
      if (!(params.nextEl || params.prevEl)) return;
      var $nextEl;
      var $prevEl;

      if (params.nextEl) {
        $nextEl = $(params.nextEl);

        if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
          $nextEl = swiper.$el.find(params.nextEl);
        }
      }

      if (params.prevEl) {
        $prevEl = $(params.prevEl);

        if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
          $prevEl = swiper.$el.find(params.prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', swiper.navigation.onNextClick);
      }

      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', swiper.navigation.onPrevClick);
      }

      extend$1(swiper.navigation, {
        $nextEl: $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl: $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var _swiper$navigation2 = swiper.navigation,
          $nextEl = _swiper$navigation2.$nextEl,
          $prevEl = _swiper$navigation2.$prevEl;

      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', swiper.navigation.onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }

      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', swiper.navigation.onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }
  };
  var Navigation$1 = {
    name: 'navigation',
    params: {
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        navigation: _extends({}, Navigation)
      });
    },
    on: {
      init: function init(swiper) {
        swiper.navigation.init();
        swiper.navigation.update();
      },
      toEdge: function toEdge(swiper) {
        swiper.navigation.update();
      },
      fromEdge: function fromEdge(swiper) {
        swiper.navigation.update();
      },
      destroy: function destroy(swiper) {
        swiper.navigation.destroy();
      },
      click: function click(swiper, e) {
        var _swiper$navigation3 = swiper.navigation,
            $nextEl = _swiper$navigation3.$nextEl,
            $prevEl = _swiper$navigation3.$prevEl;

        if (swiper.params.navigation.hideOnClick && !$(e.target).is($prevEl) && !$(e.target).is($nextEl)) {
          var isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            swiper.emit('navigationShow');
          } else {
            swiper.emit('navigationHide');
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      }
    }
  };
  var Pagination = {
    update: function update() {
      // Render || Update Pagination bullets/items
      var swiper = this;
      var rtl = swiper.rtl;
      var params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el; // Current/Total

      var current;
      var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }

        if (current > total - 1) current -= total;
        if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      } // Types


      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        var bullets = swiper.pagination.bullets;
        var firstIndex;
        var lastIndex;
        var midIndex;

        if (params.dynamicBullets) {
          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

            if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (swiper.pagination.dynamicBulletIndex < 0) {
              swiper.pagination.dynamicBulletIndex = 0;
            }
          }

          firstIndex = current - swiper.pagination.dynamicBulletIndex;
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }

        bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

        if ($el.length > 1) {
          bullets.each(function (bullet) {
            var $bullet = $(bullet);
            var bulletIndex = $bullet.index();

            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }

            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(params.bulletActiveClass + "-main");
              }

              if (bulletIndex === firstIndex) {
                $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              }

              if (bulletIndex === lastIndex) {
                $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            }
          });
        } else {
          var $bullet = bullets.eq(current);
          var bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);

          if (params.dynamicBullets) {
            var $firstDisplayedBullet = bullets.eq(firstIndex);
            var $lastDisplayedBullet = bullets.eq(lastIndex);

            for (var i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(params.bulletActiveClass + "-main");
            }

            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                  bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
                }

                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
              } else {
                $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            } else {
              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          }
        }

        if (params.dynamicBullets) {
          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
          var offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
        }
      }

      if (params.type === 'fraction') {
        $el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1));
        $el.find("." + params.totalClass).text(params.formatFractionTotal(total));
      }

      if (params.type === 'progressbar') {
        var progressbarDirection;

        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }

        var scale = (current + 1) / total;
        var scaleX = 1;
        var scaleY = 1;

        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }

        $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
      }

      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        swiper.emit('paginationRender', $el[0]);
      } else {
        swiper.emit('paginationUpdate', $el[0]);
      }

      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    },
    render: function render() {
      // Render Container
      var swiper = this;
      var params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el;
      var paginationHTML = '';

      if (params.type === 'bullets') {
        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        for (var i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
          }
        }

        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find("." + params.bulletClass);
      }

      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
        }

        $el.html(paginationHTML);
      }

      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
        }

        $el.html(paginationHTML);
      }

      if (params.type !== 'custom') {
        swiper.emit('paginationRender', swiper.pagination.$el[0]);
      }
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.pagination;
      if (!params.el) return;
      var $el = $(params.el);
      if ($el.length === 0) return;

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
        $el = swiper.$el.find(params.el);
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass("" + params.modifierClass + params.type + "-dynamic");
        swiper.pagination.dynamicBulletIndex = 0;

        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }

      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', "." + params.bulletClass, function onClick(e) {
          e.preventDefault();
          var index = $(this).index() * swiper.params.slidesPerGroup;
          if (swiper.params.loop) index += swiper.loopedSlides;
          swiper.slideTo(index);
        });
      }

      extend$1(swiper.pagination, {
        $el: $el,
        el: $el[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      var $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

      if (params.clickable) {
        $el.off('click', "." + params.bulletClass);
      }
    }
  };
  var Pagination$1 = {
    name: 'pagination',
    params: {
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: function formatFractionCurrent(number) {
          return number;
        },
        formatFractionTotal: function formatFractionTotal(number) {
          return number;
        },
        bulletClass: 'swiper-pagination-bullet',
        bulletActiveClass: 'swiper-pagination-bullet-active',
        modifierClass: 'swiper-pagination-',
        // NEW
        currentClass: 'swiper-pagination-current',
        totalClass: 'swiper-pagination-total',
        hiddenClass: 'swiper-pagination-hidden',
        progressbarFillClass: 'swiper-pagination-progressbar-fill',
        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
        clickableClass: 'swiper-pagination-clickable',
        // NEW
        lockClass: 'swiper-pagination-lock'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        pagination: _extends({
          dynamicBulletIndex: 0
        }, Pagination)
      });
    },
    on: {
      init: function init(swiper) {
        swiper.pagination.init();
        swiper.pagination.render();
        swiper.pagination.update();
      },
      activeIndexChange: function activeIndexChange(swiper) {
        if (swiper.params.loop) {
          swiper.pagination.update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          swiper.pagination.update();
        }
      },
      snapIndexChange: function snapIndexChange(swiper) {
        if (!swiper.params.loop) {
          swiper.pagination.update();
        }
      },
      slidesLengthChange: function slidesLengthChange(swiper) {
        if (swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      snapGridLengthChange: function snapGridLengthChange(swiper) {
        if (!swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      destroy: function destroy(swiper) {
        swiper.pagination.destroy();
      },
      click: function click(swiper, e) {
        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(e.target).hasClass(swiper.params.pagination.bulletClass)) {
          var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            swiper.emit('paginationShow');
          } else {
            swiper.emit('paginationHide');
          }

          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      }
    }
  };
  var Scrollbar = {
    setTranslate: function setTranslate() {
      var swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      var scrollbar = swiper.scrollbar,
          rtl = swiper.rtlTranslate,
          progress = swiper.progress;
      var dragSize = scrollbar.dragSize,
          trackSize = scrollbar.trackSize,
          $dragEl = scrollbar.$dragEl,
          $el = scrollbar.$el;
      var params = swiper.params.scrollbar;
      var newSize = dragSize;
      var newPos = (trackSize - dragSize) * progress;

      if (rtl) {
        newPos = -newPos;

        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }

      if (swiper.isHorizontal()) {
        $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
        $dragEl[0].style.width = newSize + "px";
      } else {
        $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
        $dragEl[0].style.height = newSize + "px";
      }

      if (params.hide) {
        clearTimeout(swiper.scrollbar.timeout);
        $el[0].style.opacity = 1;
        swiper.scrollbar.timeout = setTimeout(function () {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize: function updateSize() {
      var swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      var scrollbar = swiper.scrollbar;
      var $dragEl = scrollbar.$dragEl,
          $el = scrollbar.$el;
      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      var divider = swiper.size / swiper.virtualSize;
      var moveDivider = divider * (trackSize / swiper.size);
      var dragSize;

      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = dragSize + "px";
      } else {
        $dragEl[0].style.height = dragSize + "px";
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }

      if (swiper.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }

      extend$1(scrollbar, {
        trackSize: trackSize,
        divider: divider,
        moveDivider: moveDivider,
        dragSize: dragSize
      });
      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    },
    getPointerPosition: function getPointerPosition(e) {
      var swiper = this;

      if (swiper.isHorizontal()) {
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
      }

      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
    },
    setDragPosition: function setDragPosition(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar,
          rtl = swiper.rtlTranslate;
      var $el = scrollbar.$el,
          dragSize = scrollbar.dragSize,
          trackSize = scrollbar.trackSize,
          dragStartPos = scrollbar.dragStartPos;
      var positionRatio;
      positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);

      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    },
    onDragStart: function onDragStart(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el,
          $dragEl = scrollbar.$dragEl;
      swiper.scrollbar.isTouched = true;
      swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      scrollbar.setDragPosition(e);
      clearTimeout(swiper.scrollbar.dragTimeout);
      $el.transition(0);

      if (params.hide) {
        $el.css('opacity', 1);
      }

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', 'none');
      }

      swiper.emit('scrollbarDragStart', e);
    },
    onDragMove: function onDragMove(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el,
          $dragEl = scrollbar.$dragEl;
      if (!swiper.scrollbar.isTouched) return;
      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      scrollbar.setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      swiper.emit('scrollbarDragMove', e);
    },
    onDragEnd: function onDragEnd(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;
      if (!swiper.scrollbar.isTouched) return;
      swiper.scrollbar.isTouched = false;

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', '');
        $wrapperEl.transition('');
      }

      if (params.hide) {
        clearTimeout(swiper.scrollbar.dragTimeout);
        swiper.scrollbar.dragTimeout = nextTick(function () {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }

      swiper.emit('scrollbarDragEnd', e);

      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    },
    enableDraggable: function enableDraggable() {
      var swiper = this;
      if (!swiper.params.scrollbar.el) return;
      var document = getDocument();
      var scrollbar = swiper.scrollbar,
          touchEventsTouch = swiper.touchEventsTouch,
          touchEventsDesktop = swiper.touchEventsDesktop,
          params = swiper.params,
          support = swiper.support;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!support.touch) {
        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        document.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        document.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    disableDraggable: function disableDraggable() {
      var swiper = this;
      if (!swiper.params.scrollbar.el) return;
      var document = getDocument();
      var scrollbar = swiper.scrollbar,
          touchEventsTouch = swiper.touchEventsTouch,
          touchEventsDesktop = swiper.touchEventsDesktop,
          params = swiper.params,
          support = swiper.support;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!support.touch) {
        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        document.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        document.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    init: function init() {
      var swiper = this;
      if (!swiper.params.scrollbar.el) return;
      var scrollbar = swiper.scrollbar,
          $swiperEl = swiper.$el;
      var params = swiper.params.scrollbar;
      var $el = $(params.el);

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

      if ($dragEl.length === 0) {
        $dragEl = $("<div class=\"" + swiper.params.scrollbar.dragClass + "\"></div>");
        $el.append($dragEl);
      }

      extend$1(scrollbar, {
        $el: $el,
        el: $el[0],
        $dragEl: $dragEl,
        dragEl: $dragEl[0]
      });

      if (params.draggable) {
        scrollbar.enableDraggable();
      }
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.scrollbar.disableDraggable();
    }
  };
  var Scrollbar$1 = {
    name: 'scrollbar',
    params: {
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        scrollbar: _extends({
          isTouched: false,
          timeout: null,
          dragTimeout: null
        }, Scrollbar)
      });
    },
    on: {
      init: function init(swiper) {
        swiper.scrollbar.init();
        swiper.scrollbar.updateSize();
        swiper.scrollbar.setTranslate();
      },
      update: function update(swiper) {
        swiper.scrollbar.updateSize();
      },
      resize: function resize(swiper) {
        swiper.scrollbar.updateSize();
      },
      observerUpdate: function observerUpdate(swiper) {
        swiper.scrollbar.updateSize();
      },
      setTranslate: function setTranslate(swiper) {
        swiper.scrollbar.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        swiper.scrollbar.setTransition(duration);
      },
      destroy: function destroy(swiper) {
        swiper.scrollbar.destroy();
      }
    }
  };
  var Parallax = {
    setTransform: function setTransform(el, progress) {
      var swiper = this;
      var rtl = swiper.rtl;
      var $el = $(el);
      var rtlFactor = rtl ? -1 : 1;
      var p = $el.attr('data-swiper-parallax') || '0';
      var x = $el.attr('data-swiper-parallax-x');
      var y = $el.attr('data-swiper-parallax-y');
      var scale = $el.attr('data-swiper-parallax-scale');
      var opacity = $el.attr('data-swiper-parallax-opacity');

      if (x || y) {
        x = x || '0';
        y = y || '0';
      } else if (swiper.isHorizontal()) {
        x = p;
        y = '0';
      } else {
        y = p;
        x = '0';
      }

      if (x.indexOf('%') >= 0) {
        x = parseInt(x, 10) * progress * rtlFactor + "%";
      } else {
        x = x * progress * rtlFactor + "px";
      }

      if (y.indexOf('%') >= 0) {
        y = parseInt(y, 10) * progress + "%";
      } else {
        y = y * progress + "px";
      }

      if (typeof opacity !== 'undefined' && opacity !== null) {
        var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        $el[0].style.opacity = currentOpacity;
      }

      if (typeof scale === 'undefined' || scale === null) {
        $el.transform("translate3d(" + x + ", " + y + ", 0px)");
      } else {
        var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
      }
    },
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el,
          slides = swiper.slides,
          progress = swiper.progress,
          snapGrid = swiper.snapGrid;
      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
        swiper.parallax.setTransform(el, progress);
      });
      slides.each(function (slideEl, slideIndex) {
        var slideProgress = slideEl.progress;

        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }

        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
          swiper.parallax.setTransform(el, slideProgress);
        });
      });
    },
    setTransition: function setTransition(duration) {
      if (duration === void 0) {
        duration = this.params.speed;
      }

      var swiper = this;
      var $el = swiper.$el;
      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (parallaxEl) {
        var $parallaxEl = $(parallaxEl);
        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
    }
  };
  var Parallax$1 = {
    name: 'parallax',
    params: {
      parallax: {
        enabled: false
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        parallax: _extends({}, Parallax)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      init: function init(swiper) {
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTranslate();
      },
      setTranslate: function setTranslate(swiper) {
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTransition(duration);
      }
    }
  };
  var Zoom = {
    // Calc Scale From Multi-touches
    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) return 1;
      var x1 = e.targetTouches[0].pageX;
      var y1 = e.targetTouches[0].pageY;
      var x2 = e.targetTouches[1].pageX;
      var y2 = e.targetTouches[1].pageY;
      var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      return distance;
    },
    // Events
    onGestureStart: function onGestureStart(e) {
      var swiper = this;
      var support = swiper.support;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;

      if (!support.gestures) {
        if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureTouched = true;
        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = $(e.target).closest("." + swiper.params.slideClass);
        if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = undefined;
          return;
        }
      }

      if (gesture.$imageEl) {
        gesture.$imageEl.transition(0);
      }

      swiper.zoom.isScaling = true;
    },
    onGestureChange: function onGestureChange(e) {
      var swiper = this;
      var support = swiper.support;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!support.gestures) {
        if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureMoved = true;
        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        if (e.type === 'gesturechange') zoom.onGestureStart(e);
        return;
      }

      if (support.gestures) {
        zoom.scale = e.scale * zoom.currentScale;
      } else {
        zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
      }

      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
      }

      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
      }

      gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    onGestureEnd: function onGestureEnd(e) {
      var swiper = this;
      var device = swiper.device;
      var support = swiper.support;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!support.gestures) {
        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
          return;
        }

        if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
          return;
        }

        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
      zoom.currentScale = zoom.scale;
      zoom.isScaling = false;
      if (zoom.scale === 1) gesture.$slideEl = undefined;
    },
    onTouchStart: function onTouchStart(e) {
      var swiper = this;
      var device = swiper.device;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture,
          image = zoom.image;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      if (image.isTouched) return;
      if (device.android && e.cancelable) e.preventDefault();
      image.isTouched = true;
      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove: function onTouchMove(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture,
          image = zoom.image,
          velocity = zoom.velocity;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      swiper.allowClick = false;
      if (!image.isTouched || !gesture.$slideEl) return;

      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
        image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);

        if (swiper.rtl) {
          image.startX = -image.startX;
          image.startY = -image.startY;
        }
      } // Define if we need image drag


      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;
      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!image.isMoved && !zoom.isScaling) {
        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          return;
        }

        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          return;
        }
      }

      if (e.cancelable) {
        e.preventDefault();
      }

      e.stopPropagation();
      image.isMoved = true;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
      }

      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
      }

      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
      }

      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
      } // Velocity


      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
      if (!velocity.prevTime) velocity.prevTime = Date.now();
      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTouchEnd: function onTouchEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture,
          image = zoom.image,
          velocity = zoom.velocity;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }

      image.isTouched = false;
      image.isMoved = false;
      var momentumDurationX = 300;
      var momentumDurationY = 300;
      var momentumDistanceX = velocity.x * momentumDurationX;
      var newPositionX = image.currentX + momentumDistanceX;
      var momentumDistanceY = velocity.y * momentumDurationY;
      var newPositionY = image.currentY + momentumDistanceY; // Fix duration

      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY; // Define if we need image drag

      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTransitionEnd: function onTransitionEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
        if (gesture.$imageEl) {
          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
        }

        if (gesture.$imageWrapEl) {
          gesture.$imageWrapEl.transform('translate3d(0,0,0)');
        }

        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$slideEl = undefined;
        gesture.$imageEl = undefined;
        gesture.$imageWrapEl = undefined;
      }
    },
    // Toggle Zoom
    toggle: function toggle(e) {
      var swiper = this;
      var zoom = swiper.zoom;

      if (zoom.scale && zoom.scale !== 1) {
        // Zoom Out
        zoom.out();
      } else {
        // Zoom In
        zoom["in"](e);
      }
    },
    "in": function _in(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture,
          image = zoom.image;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      gesture.$slideEl.addClass("" + params.zoomedSlideClass);
      var touchX;
      var touchY;
      var offsetX;
      var offsetY;
      var diffX;
      var diffY;
      var translateX;
      var translateY;
      var imageWidth;
      var imageHeight;
      var scaledWidth;
      var scaledHeight;
      var translateMinX;
      var translateMinY;
      var translateMaxX;
      var translateMaxY;
      var slideWidth;
      var slideHeight;

      if (typeof image.touchesStart.x === 'undefined' && e) {
        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }

      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (e) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left;
        offsetY = gesture.$slideEl.offset().top;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;

        if (translateX < translateMinX) {
          translateX = translateMinX;
        }

        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }

        if (translateY < translateMinY) {
          translateY = translateMinY;
        }

        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }

      gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
      gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    out: function out() {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
      gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
      gesture.$slideEl = undefined;
    },
    toggleGestures: function toggleGestures(method) {
      var swiper = this;
      var zoom = swiper.zoom;
      var selector = zoom.slideSelector,
          passive = zoom.passiveListener;
      swiper.$wrapperEl[method]('gesturestart', selector, zoom.onGestureStart, passive);
      swiper.$wrapperEl[method]('gesturechange', selector, zoom.onGestureChange, passive);
      swiper.$wrapperEl[method]('gestureend', selector, zoom.onGestureEnd, passive);
    },
    enableGestures: function enableGestures() {
      if (this.zoom.gesturesEnabled) return;
      this.zoom.gesturesEnabled = true;
      this.zoom.toggleGestures('on');
    },
    disableGestures: function disableGestures() {
      if (!this.zoom.gesturesEnabled) return;
      this.zoom.gesturesEnabled = false;
      this.zoom.toggleGestures('off');
    },
    // Attach/Detach Events
    enable: function enable() {
      var swiper = this;
      var support = swiper.support;
      var zoom = swiper.zoom;
      if (zoom.enabled) return;
      zoom.enabled = true;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      var activeListenerWithCapture = support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      var slideSelector = "." + swiper.params.slideClass;
      swiper.zoom.passiveListener = passiveListener;
      swiper.zoom.slideSelector = slideSelector; // Scale image

      if (support.gestures) {
        swiper.$wrapperEl.on(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    },
    disable: function disable() {
      var swiper = this;
      var zoom = swiper.zoom;
      if (!zoom.enabled) return;
      var support = swiper.support;
      swiper.zoom.enabled = false;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      var activeListenerWithCapture = support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      var slideSelector = "." + swiper.params.slideClass; // Scale image

      if (support.gestures) {
        swiper.$wrapperEl.off(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    }
  };
  var Zoom$1 = {
    name: 'zoom',
    params: {
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: 'swiper-zoom-container',
        zoomedSlideClass: 'swiper-slide-zoomed'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        zoom: _extends({
          enabled: false,
          scale: 1,
          currentScale: 1,
          isScaling: false,
          gesture: {
            $slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            $imageEl: undefined,
            $imageWrapEl: undefined,
            maxRatio: 3
          },
          image: {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
          },
          velocity: {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
          }
        }, Zoom)
      });
      var scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get: function get() {
          return scale;
        },
        set: function set(value) {
          if (scale !== value) {
            var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
            var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
            swiper.emit('zoomChange', value, imageEl, slideEl);
          }

          scale = value;
        }
      });
    },
    on: {
      init: function init(swiper) {
        if (swiper.params.zoom.enabled) {
          swiper.zoom.enable();
        }
      },
      destroy: function destroy(swiper) {
        swiper.zoom.disable();
      },
      touchStart: function touchStart(swiper, e) {
        if (!swiper.zoom.enabled) return;
        swiper.zoom.onTouchStart(e);
      },
      touchEnd: function touchEnd(swiper, e) {
        if (!swiper.zoom.enabled) return;
        swiper.zoom.onTouchEnd(e);
      },
      doubleTap: function doubleTap(swiper, e) {
        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          swiper.zoom.toggle(e);
        }
      },
      transitionEnd: function transitionEnd(swiper) {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          swiper.zoom.onTransitionEnd();
        }
      },
      slideChange: function slideChange(swiper) {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          swiper.zoom.onTransitionEnd();
        }
      }
    }
  };
  var Lazy = {
    loadInSlide: function loadInSlide(index, loadInDuplicate) {
      if (loadInDuplicate === void 0) {
        loadInDuplicate = true;
      }

      var swiper = this;
      var params = swiper.params.lazy;
      if (typeof index === 'undefined') return;
      if (swiper.slides.length === 0) return;
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
      var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images.push($slideEl[0]);
      }

      if ($images.length === 0) return;
      $images.each(function (imageEl) {
        var $imageEl = $(imageEl);
        $imageEl.addClass(params.loadingClass);
        var background = $imageEl.attr('data-background');
        var src = $imageEl.attr('data-src');
        var srcset = $imageEl.attr('data-srcset');
        var sizes = $imageEl.attr('data-sizes');
        var $pictureEl = $imageEl.parent('picture');
        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

          if (background) {
            $imageEl.css('background-image', "url(\"" + background + "\")");
            $imageEl.removeAttr('data-background');
          } else {
            if (srcset) {
              $imageEl.attr('srcset', srcset);
              $imageEl.removeAttr('data-srcset');
            }

            if (sizes) {
              $imageEl.attr('sizes', sizes);
              $imageEl.removeAttr('data-sizes');
            }

            if ($pictureEl.length) {
              $pictureEl.children('source').each(function (sourceEl) {
                var $source = $(sourceEl);

                if ($source.attr('data-srcset')) {
                  $source.attr('srcset', $source.attr('data-srcset'));
                  $source.removeAttr('data-srcset');
                }
              });
            }

            if (src) {
              $imageEl.attr('src', src);
              $imageEl.removeAttr('data-src');
            }
          }

          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find("." + params.preloaderClass).remove();

          if (swiper.params.loop && loadInDuplicate) {
            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
              swiper.lazy.loadInSlide(originalSlide.index(), false);
            } else {
              var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
            }
          }

          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        });
        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
      });
    },
    load: function load() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          swiperParams = swiper.params,
          slides = swiper.slides,
          activeIndex = swiper.activeIndex;
      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      var params = swiperParams.lazy;
      var slidesPerView = swiperParams.slidesPerView;

      if (slidesPerView === 'auto') {
        slidesPerView = 0;
      }

      function slideExist(index) {
        if (isVirtual) {
          if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
            return true;
          }
        } else if (slides[index]) return true;

        return false;
      }

      function slideIndex(slideEl) {
        if (isVirtual) {
          return $(slideEl).attr('data-swiper-slide-index');
        }

        return $(slideEl).index();
      }

      if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;

      if (swiper.params.watchSlidesVisibility) {
        $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (slideEl) {
          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
          swiper.lazy.loadInSlide(index);
        });
      } else if (slidesPerView > 1) {
        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        swiper.lazy.loadInSlide(activeIndex);
      }

      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          var amount = params.loadPrevNextAmount;
          var spv = slidesPerView;
          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

          for (var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1) {
            if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
          } // Prev Slides


          for (var _i2 = minIndex; _i2 < activeIndex; _i2 += 1) {
            if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
          }
        } else {
          var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
          if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
          var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
          if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
        }
      }
    }
  };
  var Lazy$1 = {
    name: 'lazy',
    params: {
      lazy: {
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        elementClass: 'swiper-lazy',
        loadingClass: 'swiper-lazy-loading',
        loadedClass: 'swiper-lazy-loaded',
        preloaderClass: 'swiper-lazy-preloader'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        lazy: _extends({
          initialImageLoaded: false
        }, Lazy)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      },
      init: function init(swiper) {
        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
          swiper.lazy.load();
        }
      },
      scroll: function scroll(swiper) {
        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
          swiper.lazy.load();
        }
      },
      resize: function resize(swiper) {
        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      scrollbarDragMove: function scrollbarDragMove(swiper) {
        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      transitionStart: function transitionStart(swiper) {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
            swiper.lazy.load();
          }
        }
      },
      transitionEnd: function transitionEnd(swiper) {
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          swiper.lazy.load();
        }
      },
      slideChange: function slideChange(swiper) {
        if (swiper.params.lazy.enabled && swiper.params.cssMode) {
          swiper.lazy.load();
        }
      }
    }
  };
  var Controller = {
    LinearSpline: function LinearSpline(x, y) {
      var binarySearch = function search() {
        var maxIndex;
        var minIndex;
        var guess;
        return function (array, val) {
          minIndex = -1;
          maxIndex = array.length;

          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;

            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }

          return maxIndex;
        };
      }();

      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
      // (x1,y1) is the known point before given value,
      // (x3,y3) is the known point after given value.

      var i1;
      var i3;

      this.interpolate = function interpolate(x2) {
        if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };

      return this;
    },
    // xxx: for now i will just save one spline function to to
    getInterpolateFunction: function getInterpolateFunction(c) {
      var swiper = this;

      if (!swiper.controller.spline) {
        swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
      }
    },
    setTranslate: function setTranslate(_setTranslate, byController) {
      var swiper = this;
      var controlled = swiper.controller.control;
      var multiplier;
      var controlledTranslate;
      var Swiper = swiper.constructor;

      function setControlledTranslate(c) {
        // this will create an Interpolate function based on the snapGrids
        // x is the Grid of the scrolled scroller and y will be the controlled scroller
        // it makes sense to create this only once and recall it for the interpolation
        // the function does a lot of value caching for performance
        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

        if (swiper.params.controller.by === 'slide') {
          swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
          // but it did not work out

          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
        }

        if (!controlledTranslate || swiper.params.controller.by === 'container') {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
        }

        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }

        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }

      if (Array.isArray(controlled)) {
        for (var i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    },
    setTransition: function setTransition(duration, byController) {
      var swiper = this;
      var Swiper = swiper.constructor;
      var controlled = swiper.controller.control;
      var i;

      function setControlledTransition(c) {
        c.setTransition(duration, swiper);

        if (duration !== 0) {
          c.transitionStart();

          if (c.params.autoHeight) {
            nextTick(function () {
              c.updateAutoHeight();
            });
          }

          c.$wrapperEl.transitionEnd(function () {
            if (!controlled) return;

            if (c.params.loop && swiper.params.controller.by === 'slide') {
              c.loopFix();
            }

            c.transitionEnd();
          });
        }
      }

      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }
  };
  var Controller$1 = {
    name: 'controller',
    params: {
      controller: {
        control: undefined,
        inverse: false,
        by: 'slide' // or 'container'

      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        controller: _extends({
          control: swiper.params.controller.control
        }, Controller)
      });
    },
    on: {
      update: function update(swiper) {
        if (!swiper.controller.control) return;

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      resize: function resize(swiper) {
        if (!swiper.controller.control) return;

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      observerUpdate: function observerUpdate(swiper) {
        if (!swiper.controller.control) return;

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      setTranslate: function setTranslate(swiper, translate, byController) {
        if (!swiper.controller.control) return;
        swiper.controller.setTranslate(translate, byController);
      },
      setTransition: function setTransition(swiper, duration, byController) {
        if (!swiper.controller.control) return;
        swiper.controller.setTransition(duration, byController);
      }
    }
  };
  var A11y = {
    makeElFocusable: function makeElFocusable($el) {
      $el.attr('tabIndex', '0');
      return $el;
    },
    makeElNotFocusable: function makeElNotFocusable($el) {
      $el.attr('tabIndex', '-1');
      return $el;
    },
    addElRole: function addElRole($el, role) {
      $el.attr('role', role);
      return $el;
    },
    addElLabel: function addElLabel($el, label) {
      $el.attr('aria-label', label);
      return $el;
    },
    disableEl: function disableEl($el) {
      $el.attr('aria-disabled', true);
      return $el;
    },
    enableEl: function enableEl($el) {
      $el.attr('aria-disabled', false);
      return $el;
    },
    onEnterKey: function onEnterKey(e) {
      var swiper = this;
      var params = swiper.params.a11y;
      if (e.keyCode !== 13) return;
      var $targetEl = $(e.target);

      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }

        if (swiper.isEnd) {
          swiper.a11y.notify(params.lastSlideMessage);
        } else {
          swiper.a11y.notify(params.nextSlideMessage);
        }
      }

      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }

        if (swiper.isBeginning) {
          swiper.a11y.notify(params.firstSlideMessage);
        } else {
          swiper.a11y.notify(params.prevSlideMessage);
        }
      }

      if (swiper.pagination && $targetEl.is("." + swiper.params.pagination.bulletClass)) {
        $targetEl[0].click();
      }
    },
    notify: function notify(message) {
      var swiper = this;
      var notification = swiper.a11y.liveRegion;
      if (notification.length === 0) return;
      notification.html('');
      notification.html(message);
    },
    updateNavigation: function updateNavigation() {
      var swiper = this;
      if (swiper.params.loop || !swiper.navigation) return;
      var _swiper$navigation = swiper.navigation,
          $nextEl = _swiper$navigation.$nextEl,
          $prevEl = _swiper$navigation.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          swiper.a11y.disableEl($prevEl);
          swiper.a11y.makeElNotFocusable($prevEl);
        } else {
          swiper.a11y.enableEl($prevEl);
          swiper.a11y.makeElFocusable($prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          swiper.a11y.disableEl($nextEl);
          swiper.a11y.makeElNotFocusable($nextEl);
        } else {
          swiper.a11y.enableEl($nextEl);
          swiper.a11y.makeElFocusable($nextEl);
        }
      }
    },
    updatePagination: function updatePagination() {
      var swiper = this;
      var params = swiper.params.a11y;

      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.bullets.each(function (bulletEl) {
          var $bulletEl = $(bulletEl);
          swiper.a11y.makeElFocusable($bulletEl);
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        });
      }
    },
    init: function init() {
      var swiper = this;
      swiper.$el.append(swiper.a11y.liveRegion); // Navigation

      var params = swiper.params.a11y;
      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        swiper.a11y.makeElFocusable($nextEl);
        swiper.a11y.addElRole($nextEl, 'button');
        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
        $nextEl.on('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        swiper.a11y.makeElFocusable($prevEl);
        swiper.a11y.addElRole($prevEl, 'button');
        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
        $prevEl.on('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.on('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    },
    destroy: function destroy() {
      var swiper = this;
      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        $nextEl.off('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        $prevEl.off('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.off('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    }
  };
  var A11y$1 = {
    name: 'a11y',
    params: {
      a11y: {
        enabled: true,
        notificationClass: 'swiper-notification',
        prevSlideMessage: 'Previous slide',
        nextSlideMessage: 'Next slide',
        firstSlideMessage: 'This is the first slide',
        lastSlideMessage: 'This is the last slide',
        paginationBulletMessage: 'Go to slide {{index}}'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        a11y: _extends(_extends({}, A11y), {}, {
          liveRegion: $("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
        })
      });
    },
    on: {
      init: function init(swiper) {
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.init();
        swiper.a11y.updateNavigation();
      },
      toEdge: function toEdge(swiper) {
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updateNavigation();
      },
      fromEdge: function fromEdge(swiper) {
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updateNavigation();
      },
      paginationUpdate: function paginationUpdate(swiper) {
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updatePagination();
      },
      destroy: function destroy(swiper) {
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.destroy();
      }
    }
  };
  var History = {
    init: function init() {
      var swiper = this;
      var window = getWindow();
      if (!swiper.params.history) return;

      if (!window.history || !window.history.pushState) {
        swiper.params.history.enabled = false;
        swiper.params.hashNavigation.enabled = true;
        return;
      }

      var history = swiper.history;
      history.initialized = true;
      history.paths = History.getPathValues(swiper.params.url);
      if (!history.paths.key && !history.paths.value) return;
      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    destroy: function destroy() {
      var swiper = this;
      var window = getWindow();

      if (!swiper.params.history.replaceState) {
        window.removeEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    setHistoryPopState: function setHistoryPopState() {
      var swiper = this;
      swiper.history.paths = History.getPathValues(swiper.params.url);
      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
    },
    getPathValues: function getPathValues(urlOverride) {
      var window = getWindow();
      var location;

      if (urlOverride) {
        location = new URL(urlOverride);
      } else {
        location = window.location;
      }

      var pathArray = location.pathname.slice(1).split('/').filter(function (part) {
        return part !== '';
      });
      var total = pathArray.length;
      var key = pathArray[total - 2];
      var value = pathArray[total - 1];
      return {
        key: key,
        value: value
      };
    },
    setHistory: function setHistory(key, index) {
      var swiper = this;
      var window = getWindow();
      if (!swiper.history.initialized || !swiper.params.history.enabled) return;
      var location;

      if (swiper.params.url) {
        location = new URL(swiper.params.url);
      } else {
        location = window.location;
      }

      var slide = swiper.slides.eq(index);
      var value = History.slugify(slide.attr('data-history'));

      if (!location.pathname.includes(key)) {
        value = key + "/" + value;
      }

      var currentState = window.history.state;

      if (currentState && currentState.value === value) {
        return;
      }

      if (swiper.params.history.replaceState) {
        window.history.replaceState({
          value: value
        }, null, value);
      } else {
        window.history.pushState({
          value: value
        }, null, value);
      }
    },
    slugify: function slugify(text) {
      return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    },
    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
      var swiper = this;

      if (value) {
        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHistory = History.slugify(slide.attr('data-history'));

          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, runCallbacks);
          }
        }
      } else {
        swiper.slideTo(0, speed, runCallbacks);
      }
    }
  };
  var History$1 = {
    name: 'history',
    params: {
      history: {
        enabled: false,
        replaceState: false,
        key: 'slides'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        history: _extends({}, History)
      });
    },
    on: {
      init: function init(swiper) {
        if (swiper.params.history.enabled) {
          swiper.history.init();
        }
      },
      destroy: function destroy(swiper) {
        if (swiper.params.history.enabled) {
          swiper.history.destroy();
        }
      },
      transitionEnd: function transitionEnd(swiper) {
        if (swiper.history.initialized) {
          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      },
      slideChange: function slideChange(swiper) {
        if (swiper.history.initialized && swiper.params.cssMode) {
          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      }
    }
  };
  var HashNavigation = {
    onHashCange: function onHashCange() {
      var swiper = this;
      var document = getDocument();
      swiper.emit('hashChange');
      var newHash = document.location.hash.replace('#', '');
      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

      if (newHash !== activeSlideHash) {
        var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-hash=\"" + newHash + "\"]").index();
        if (typeof newIndex === 'undefined') return;
        swiper.slideTo(newIndex);
      }
    },
    setHash: function setHash() {
      var swiper = this;
      var window = getWindow();
      var document = getDocument();
      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;

      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
        window.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr('data-hash') || false);
        swiper.emit('hashSet');
      } else {
        var slide = swiper.slides.eq(swiper.activeIndex);
        var hash = slide.attr('data-hash') || slide.attr('data-history');
        document.location.hash = hash || '';
        swiper.emit('hashSet');
      }
    },
    init: function init() {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
      swiper.hashNavigation.initialized = true;
      var hash = document.location.hash.replace('#', '');

      if (hash) {
        var speed = 0;

        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHash = slide.attr('data-hash') || slide.attr('data-history');

          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
          }
        }
      }

      if (swiper.params.hashNavigation.watchState) {
        $(window).on('hashchange', swiper.hashNavigation.onHashCange);
      }
    },
    destroy: function destroy() {
      var swiper = this;
      var window = getWindow();

      if (swiper.params.hashNavigation.watchState) {
        $(window).off('hashchange', swiper.hashNavigation.onHashCange);
      }
    }
  };
  var HashNavigation$1 = {
    name: 'hash-navigation',
    params: {
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        hashNavigation: _extends({
          initialized: false
        }, HashNavigation)
      });
    },
    on: {
      init: function init(swiper) {
        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.init();
        }
      },
      destroy: function destroy(swiper) {
        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.destroy();
        }
      },
      transitionEnd: function transitionEnd(swiper) {
        if (swiper.hashNavigation.initialized) {
          swiper.hashNavigation.setHash();
        }
      },
      slideChange: function slideChange(swiper) {
        if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
          swiper.hashNavigation.setHash();
        }
      }
    }
  };
  var Autoplay = {
    run: function run() {
      var swiper = this;
      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      var delay = swiper.params.autoplay.delay;

      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }

      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = nextTick(function () {
        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.isBeginning) {
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else {
            swiper.autoplay.stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isEnd) {
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }

        if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
      }, delay);
    },
    start: function start() {
      var swiper = this;
      if (typeof swiper.autoplay.timeout !== 'undefined') return false;
      if (swiper.autoplay.running) return false;
      swiper.autoplay.running = true;
      swiper.emit('autoplayStart');
      swiper.autoplay.run();
      return true;
    },
    stop: function stop() {
      var swiper = this;
      if (!swiper.autoplay.running) return false;
      if (typeof swiper.autoplay.timeout === 'undefined') return false;

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = undefined;
      }

      swiper.autoplay.running = false;
      swiper.emit('autoplayStop');
      return true;
    },
    pause: function pause(speed) {
      var swiper = this;
      if (!swiper.autoplay.running) return;
      if (swiper.autoplay.paused) return;
      if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.paused = true;

      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
      } else {
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
      }
    },
    onVisibilityChange: function onVisibilityChange() {
      var swiper = this;
      var document = getDocument();

      if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
        swiper.autoplay.pause();
      }

      if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
        swiper.autoplay.run();
        swiper.autoplay.paused = false;
      }
    },
    onTransitionEnd: function onTransitionEnd(e) {
      var swiper = this;
      if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
      if (e.target !== swiper.$wrapperEl[0]) return;
      swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
      swiper.autoplay.paused = false;

      if (!swiper.autoplay.running) {
        swiper.autoplay.stop();
      } else {
        swiper.autoplay.run();
      }
    }
  };
  var Autoplay$1 = {
    name: 'autoplay',
    params: {
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        autoplay: _extends(_extends({}, Autoplay), {}, {
          running: false,
          paused: false
        })
      });
    },
    on: {
      init: function init(swiper) {
        if (swiper.params.autoplay.enabled) {
          swiper.autoplay.start();
          var document = getDocument();
          document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        }
      },
      beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            swiper.autoplay.stop();
          }
        }
      },
      sliderFirstMove: function sliderFirstMove(swiper) {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.pause();
          }
        }
      },
      touchEnd: function touchEnd(swiper) {
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.run();
        }
      },
      destroy: function destroy(swiper) {
        if (swiper.autoplay.running) {
          swiper.autoplay.stop();
        }

        var document = getDocument();
        document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    }
  };
  var Fade = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = swiper.slides.eq(i);
        var offset = $slideEl[0].swiperSlideOffset;
        var tx = -offset;
        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }

        var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        $slideEl.css({
          opacity: slideOpacity
        }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides,
          $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false;
        slides.transitionEnd(function () {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFade = {
    name: 'effect-fade',
    params: {
      fadeEffect: {
        crossFade: false
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        fadeEffect: _extends({}, Fade)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (swiper.params.effect !== 'fade') return;
        swiper.classNames.push(swiper.params.containerModifierClass + "fade");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        extend$1(swiper.params, overwriteParams);
        extend$1(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate(swiper) {
        if (swiper.params.effect !== 'fade') return;
        swiper.fadeEffect.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        if (swiper.params.effect !== 'fade') return;
        swiper.fadeEffect.setTransition(duration);
      }
    }
  };
  var Cube = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el,
          $wrapperEl = swiper.$wrapperEl,
          slides = swiper.slides,
          swiperWidth = swiper.width,
          swiperHeight = swiper.height,
          rtl = swiper.rtlTranslate,
          swiperSize = swiper.size,
          browser = swiper.browser;
      var params = swiper.params.cubeEffect;
      var isHorizontal = swiper.isHorizontal();
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var wrapperRotate = 0;
      var $cubeShadowEl;

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }

          $cubeShadowEl.css({
            height: swiperWidth + "px"
          });
        } else {
          $cubeShadowEl = $el.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideIndex = i;

        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
        }

        var slideAngle = slideIndex * 90;
        var round = Math.floor(slideAngle / 360);

        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }

        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        var tx = 0;
        var ty = 0;
        var tz = 0;

        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }

        if (rtl) {
          tx = -tx;
        }

        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }

        var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";

        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;
          if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
        }

        $slideEl.transform(transform);

        if (params.slideShadows) {
          // Set shadows
          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }
      }

      $wrapperEl.css({
        '-webkit-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-moz-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-ms-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        'transform-origin': "50% 50% -" + swiperSize / 2 + "px"
      });

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
        } else {
          var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          var scale1 = params.shadowScale;
          var scale2 = params.shadowScale / multiplier;
          var offset = params.shadowOffset;
          $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
        }
      }

      var zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
      $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var $el = swiper.$el,
          slides = swiper.slides;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        $el.find('.swiper-cube-shadow').transition(duration);
      }
    }
  };
  var EffectCube = {
    name: 'effect-cube',
    params: {
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        cubeEffect: _extends({}, Cube)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (swiper.params.effect !== 'cube') return;
        swiper.classNames.push(swiper.params.containerModifierClass + "cube");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true
        };
        extend$1(swiper.params, overwriteParams);
        extend$1(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate(swiper) {
        if (swiper.params.effect !== 'cube') return;
        swiper.cubeEffect.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        if (swiper.params.effect !== 'cube') return;
        swiper.cubeEffect.setTransition(duration);
      }
    }
  };
  var Flip = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides,
          rtl = swiper.rtlTranslate;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var progress = $slideEl[0].progress;

        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }

        var offset = $slideEl[0].swiperSlideOffset;
        var rotate = -180 * progress;
        var rotateY = rotate;
        var rotateX = 0;
        var tx = -offset;
        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

        if (swiper.params.flipEffect.slideShadows) {
          // Set shadows
          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }

        $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides,
          activeIndex = swiper.activeIndex,
          $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false; // eslint-disable-next-line

        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return; // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;

          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFlip = {
    name: 'effect-flip',
    params: {
      flipEffect: {
        slideShadows: true,
        limitRotation: true
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        flipEffect: _extends({}, Flip)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (swiper.params.effect !== 'flip') return;
        swiper.classNames.push(swiper.params.containerModifierClass + "flip");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        extend$1(swiper.params, overwriteParams);
        extend$1(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate(swiper) {
        if (swiper.params.effect !== 'flip') return;
        swiper.flipEffect.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        if (swiper.params.effect !== 'flip') return;
        swiper.flipEffect.setTransition(duration);
      }
    }
  };
  var Coverflow = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var swiperWidth = swiper.width,
          swiperHeight = swiper.height,
          slides = swiper.slides,
          slidesSizesGrid = swiper.slidesSizesGrid;
      var params = swiper.params.coverflowEffect;
      var isHorizontal = swiper.isHorizontal();
      var transform = swiper.translate;
      var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
      var rotate = isHorizontal ? params.rotate : -params.rotate;
      var translate = params.depth; // Each slide offset from center

      for (var i = 0, length = slides.length; i < length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideSize = slidesSizesGrid[i];
        var slideOffset = $slideEl[0].swiperSlideOffset;
        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

        var translateZ = -translate * Math.abs(offsetMultiplier);
        var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
          stretch = parseFloat(params.stretch) / 100 * slideSize;
        }

        var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
        var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
        var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

        if (Math.abs(translateX) < 0.001) translateX = 0;
        if (Math.abs(translateY) < 0.001) translateY = 0;
        if (Math.abs(translateZ) < 0.001) translateZ = 0;
        if (Math.abs(rotateY) < 0.001) rotateY = 0;
        if (Math.abs(rotateX) < 0.001) rotateX = 0;
        if (Math.abs(scale) < 0.001) scale = 0;
        var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + scale + ")";
        $slideEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

        if (params.slideShadows) {
          // Set shadows
          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append($shadowBeforeEl);
          }

          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append($shadowAfterEl);
          }

          if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
        }
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    }
  };
  var EffectCoverflow = {
    name: 'effect-coverflow',
    params: {
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: true
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        coverflowEffect: _extends({}, Coverflow)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        if (swiper.params.effect !== 'coverflow') return;
        swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      setTranslate: function setTranslate(swiper) {
        if (swiper.params.effect !== 'coverflow') return;
        swiper.coverflowEffect.setTranslate();
      },
      setTransition: function setTransition(swiper, duration) {
        if (swiper.params.effect !== 'coverflow') return;
        swiper.coverflowEffect.setTransition(duration);
      }
    }
  };
  var Thumbs = {
    init: function init() {
      var swiper = this;
      var thumbsParams = swiper.params.thumbs;
      if (swiper.thumbs.initialized) return false;
      swiper.thumbs.initialized = true;
      var SwiperClass = swiper.constructor;

      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        extend$1(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        extend$1(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (isObject$1(thumbsParams.swiper)) {
        swiper.thumbs.swiper = new SwiperClass(extend$1({}, thumbsParams.swiper, {
          watchSlidesVisibility: true,
          watchSlidesProgress: true,
          slideToClickedSlide: false
        }));
        swiper.thumbs.swiperCreated = true;
      }

      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
      return true;
    },
    onThumbClick: function onThumbClick() {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      var clickedIndex = thumbsSwiper.clickedIndex;
      var clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
      var slideToIndex;

      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      } else {
        slideToIndex = clickedIndex;
      }

      if (swiper.params.loop) {
        var currentIndex = swiper.activeIndex;

        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          currentIndex = swiper.activeIndex;
        }

        var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
        var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
        if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
      }

      swiper.slideTo(slideToIndex);
    },
    update: function update(initial) {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
      var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
      var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
        var currentThumbsIndex = thumbsSwiper.activeIndex;
        var newThumbsIndex;
        var direction;

        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix(); // eslint-disable-next-line

            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          } // Find actual thumbs index to slide to


          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
          if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;else newThumbsIndex = prevThumbsIndex;
          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
        } else {
          newThumbsIndex = swiper.realIndex;
          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
        }

        if (useOffset) {
          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
        }

        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - slidesPerView + 1;
          }

          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
        }
      } // Activate thumbs


      var thumbsToActivate = 1;
      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }

      if (!swiper.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }

      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.removeClass(thumbActiveClass);

      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (var i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
        }
      } else {
        for (var _i = 0; _i < thumbsToActivate; _i += 1) {
          thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
        }
      }
    }
  };
  var Thumbs$1 = {
    name: 'thumbs',
    params: {
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: 'swiper-slide-thumb-active',
        thumbsContainerClass: 'swiper-container-thumbs'
      }
    },
    create: function create() {
      var swiper = this;
      bindModuleMethods(swiper, {
        thumbs: _extends({
          swiper: null,
          initialized: false
        }, Thumbs)
      });
    },
    on: {
      beforeInit: function beforeInit(swiper) {
        var thumbs = swiper.params.thumbs;
        if (!thumbs || !thumbs.swiper) return;
        swiper.thumbs.init();
        swiper.thumbs.update(true);
      },
      slideChange: function slideChange(swiper) {
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      update: function update(swiper) {
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      resize: function resize(swiper) {
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      observerUpdate: function observerUpdate(swiper) {
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      setTransition: function setTransition(swiper, duration) {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        thumbsSwiper.setTransition(duration);
      },
      beforeDestroy: function beforeDestroy(swiper) {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;

        if (swiper.thumbs.swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      }
    }
  }; // Swiper Class

  var components = [Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y$1, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1];
  Swiper.use(components);
  return Swiper;
});

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/* 
 *************************************
 * Scroll Lock
 * @https://gist.github.com/barneycarroll/6550066
 * @return {Void}
 *************************************
 */

/*
	 // Locks the page
	$.scrollLock( true );
	
	// Unlocks the page
	$.scrollLock( false );
*/
(function ($) {
  'use strict';

  $.scrollLock = function scrollLockClosure() {
    var $html = $('html'),
        // State: unlocked by default
    locked = false,
        // State: scroll to revert to
    prevScroll = {
      scrollLeft: $(window).scrollLeft(),
      scrollTop: $(window).scrollTop()
    },
        // State: styles to revert to
    prevStyles = {},
        lockStyles = {
      'overflow-y': 'scroll',
      'position': 'fixed',
      'width': '100%'
    }; // Instantiate cache in case someone tries to unlock before locking

    saveStyles(); // Save context's inline styles in cache

    function saveStyles() {
      var styleAttr = $html.attr('style'),
          styleStrs = [],
          styleHash = {};

      if (!styleAttr) {
        return;
      }

      styleStrs = styleAttr.split(/;\s/);
      $.each(styleStrs, function serializeStyleProp(styleString) {
        if (!styleString) {
          return;
        }

        var keyValue = styleString.split(/\s:\s/);

        if (keyValue.length < 2) {
          return;
        }

        styleHash[keyValue[0]] = keyValue[1];
      });
      $.extend(prevStyles, styleHash);
    }

    function lock() {
      var appliedLock = {}; // Duplicate execution will break DOM statefulness

      if (locked) {
        return;
      } // Save scroll state...


      prevScroll = {
        scrollLeft: $(window).scrollLeft(),
        scrollTop: $(window).scrollTop()
      }; // ...and styles

      saveStyles(); // Compose our applied CSS

      $.extend(appliedLock, lockStyles, {
        // And apply scroll state as styles
        'left': -prevScroll.scrollLeft + 'px',
        'top': -prevScroll.scrollTop + 'px'
      }); // Then lock styles...

      $html.css(appliedLock); // ...and scroll state

      $(window).scrollLeft(0).scrollTop(0);
      locked = true;
    }

    function unlock() {
      // Duplicate execution will break DOM statefulness
      if (!locked) {
        return;
      } // Revert styles


      $html.attr('style', $('<x>').css(prevStyles).attr('style') || ''); // Revert scroll values

      $(window).scrollLeft(prevScroll.scrollLeft).scrollTop(prevScroll.scrollTop);
      locked = false;
    }

    return function scrollLock(on) {
      // If an argument is passed, lock or unlock depending on truthiness
      if (arguments.length) {
        if (on) {
          lock();
        } else {
          unlock();
        }
      } // Otherwise, toggle
      else {
          if (locked) {
            unlock();
          } else {
            lock();
          }
        }
    };
  }();
})(jQuery);

/***/ }),
/* 4 */
/***/ (function(module, exports) {

/* 
 *************************************
 * Get all attributes of an element using jQuery
 *
 * @return {array}                        - Returns a new array.
 * @usage:
 
	$( '#demo' ).attr();  // { "data-a": "1", "id": "b" }

 *************************************
 */
(function (old) {
  $.fn.attr = function () {
    if (arguments.length === 0) {
      if (this.length === 0) {
        return null;
      }

      var obj = {};
      $.each(this[0].attributes, function () {
        if (this.specified) {
          obj[this.name] = this.value;
        }
      });
      return obj;
    }

    return old.apply(this, arguments);
  };
})($.fn.attr);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

/* 
 *************************************
 * Parallax Effect
 *
 * @param  {Number} speed       - The speed of movement between elements.
 * @param  {String} transition  - Transition time can simulate easing effect.
 * @param  {Object} bg            - Specify the background display. Default value: { enable: true, xPos: '50%' }
 * @return {Void}
 *
 *************************************
 */
(function ($) {
  'use strict';

  $.fn.UixParallax = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      speed: 0.25,
      offsetTop: 0,
      transition: 'all 0.4s cubic-bezier(0, 0, 0.34, 0.96) 0s',
      bg: {
        enable: true,
        xPos: '50%'
      }
    }, options);
    this.each(function () {
      var bgEff = settings.bg,
          $this = $(this),
          bgXpos = '50%',
          offsetTop = parseFloat(settings.offsetTop),
          speed = -parseFloat(settings.speed);

      if (bgEff) {
        bgEff = settings.bg.enable;
        bgXpos = settings.bg.xPos;
      } //Prohibit transition delay


      $this.css({
        'transition': 'none'
      }); // Please do not use scroll's off method in each

      $(window).on('scroll.UixParallax touchmove.UixParallax', function (e) {
        scrollUpdate();
      }); //Initialize the position of the background

      if (bgEff) {
        //background parallax
        TweenMax.set($this, {
          backgroundPosition: bgXpos + ' ' + (-$this[0].getBoundingClientRect().top * speed + -offsetTop) + 'px'
        });
      } else {
        //element parallax
        TweenMax.set($this, {
          y: 0
        });
      }

      function scrollUpdate() {
        var spyTop = $this[0].getBoundingClientRect().top;

        if (bgEff) {
          //background parallax
          TweenMax.set($this, {
            css: {
              'background-position': bgXpos + ' ' + (0 - (spyTop * speed + offsetTop)) + 'px',
              'transition': settings.transition
            }
          });
        } else {
          //element parallax
          TweenMax.set($this, {
            css: {
              'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - (spyTop * speed + offsetTop)) + ')',
              'transition': settings.transition
            }
          });
        }
      }
    });
  };
})(jQuery);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Render Custom Select
 *
 * @param  {String} selector             - The current selector.
 * @param  {String} targetWrapper        - Wrapper of the selector.
 * @param  {String} trigger              - Trigger of the selector.
 * @param  {String} itemsWrapper         - Selector's options container.
 * @param  {Element} item                 - Each option of the selector.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSelect = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: '.uix-controls__select',
      targetWrapper: '.uix-controls__select-wrapper',
      trigger: '.uix-controls__select-trigger',
      itemsWrapper: '.uix-controls__select__option-container',
      item: '.uix-controls__select__option'
    }, options);
    this.each(function () {
      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this);
        var classes = $this.attr('class'),
            id = $this.attr('id'),
            name = $this.attr('name'),
            labelText = $this.find('> span').html(),
            dataExist = $this.data('exist');
        var template = '';

        if (_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          template = '<div class="' + classes + ' js-uix-new">';
          template += '<span class="uix-controls__select-trigger">' + $this.find('select').attr('placeholder') + '</span><ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>';
          template += '<div role="presentation" class="uix-controls__select__option-container">';
          $this.find('select option').each(function (index) {
            var selected = '';

            if ($(this).is(':selected')) {
              selected = 'is-active';
            }

            template += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
          });
          template += '</div></div>';

          if (_typeof(labelText) != ( true ? "undefined" : undefined) && labelText != '') {
            template += '<span class="uix-controls__select-label">' + labelText + '</span>';
          }

          $this.wrap('<div class="' + settings.targetWrapper.replace('.', '') + ' ' + ($this.hasClass('uix-controls--line') ? 'uix-controls--line' : '') + ' ' + ($this.hasClass('is-fullwidth') ? 'is-fullwidth' : '') + ' ' + ($this.hasClass('is-disabled') ? 'is-disabled' : '') + '"></div>');
          $this.hide();
          $this.after(template); //Prevent the form from being initialized again

          $(this).data('exist', 1);
        }
      }); //Show/Hide Selector

      $(document).off('click.FORM_CUSTOM_SELECT').on('click.FORM_CUSTOM_SELECT', settings.trigger, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
            $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new');
        $selectCurWrapper.addClass('is-opened');
      }); //Do not add off() to this

      $(document.body).on('click', function (e) {
        if (e.target.className != '' && _typeof(e.target.className) != ( true ? "undefined" : undefined) && Object.prototype.toString.call(e.target.className) != '[object SVGAnimatedString]') {
          if (e.target.className.indexOf('uix-controls__select__option') < 0) {
            $(settings.selector + '.js-uix-new').removeClass('is-opened');
          }
        }
      }); //Set the default selector text

      $(settings.selector + '.js-uix-new').each(function (index) {
        $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
      }); //Change Event Here
      //Prevents the triggering of multiple change events

      $(document).off('click.FORM_CUSTOM_SELECT_ITEM').on('click.FORM_CUSTOM_SELECT_ITEM', settings.item, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
            $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new'),
            curVal = $(this).data('value'); //Close the selector

        $selectCurWrapper.removeClass('is-opened'); //Set the selector text

        $selectCurWrapper.find(settings.trigger).text($(this).html()).addClass('is-active'); //Activate this option

        $selectCurWrapper.find(settings.item).removeClass('is-active');
        $(this).addClass('is-active'); //Set select option 'selected', by value

        $selectWrapper.find('select').val(curVal);
        $selectWrapper.find('select option').removeAttr('selected');
        $selectWrapper.find('select option[value="' + curVal + '"]').attr('selected', 'selected').change();
      }); //Synchronize to the original select change event

      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this).find('select'),
            $cusSelect = $this.closest(settings.targetWrapper).find(settings.selector + '.js-uix-new');
        var newOptions = '';
        $this.closest(settings.targetWrapper).find('select option').each(function (index) {
          var selected = '';

          if ($(this).is(':selected')) {
            selected = 'is-active';
          }

          newOptions += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
        });
        $cusSelect.find(settings.itemsWrapper).html('<div>' + newOptions + '</div>'); //Set the default selector text

        $cusSelect.each(function (index) {
          $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 7 */
/***/ (function(module, exports) {

/* 
 *************************************
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 * 
 *************************************
 */
(function ($, window, undefined) {
  '$:nomunge';

  var str_hashchange = 'hashchange',
      doc = document,
      fake_onhashchange,
      special = $.event.special,
      doc_mode = doc.documentMode,
      supports_onhashchange = 'on' + str_hashchange in window && (doc_mode === undefined || doc_mode > 7);

  function get_fragment(url) {
    url = url || location.href;
    return '#' + url.replace(/^[^#]*#?(.*)$/, '$1');
  }

  ;

  $.fn[str_hashchange] = function (fn) {
    return fn ? this.bind(str_hashchange, fn) : this.trigger(str_hashchange);
  };

  $.fn[str_hashchange].delay = 50;
  special[str_hashchange] = $.extend(special[str_hashchange], {
    setup: function setup() {
      if (supports_onhashchange) {
        return false;
      }

      $(fake_onhashchange.start);
    },
    teardown: function teardown() {
      if (supports_onhashchange) {
        return false;
      }

      $(fake_onhashchange.stop);
    }
  });

  fake_onhashchange = function () {
    var self = {},
        timeout_id,
        last_hash = get_fragment(),
        fn_retval = function fn_retval(val) {
      return val;
    },
        history_set = fn_retval,
        history_get = fn_retval;

    self.start = function () {
      timeout_id || poll();
    };

    self.stop = function () {
      timeout_id && clearTimeout(timeout_id);
      timeout_id = undefined;
    };

    function poll() {
      var hash = get_fragment(),
          history_hash = history_get(last_hash);

      if (hash !== last_hash) {
        history_set(last_hash = hash, history_hash);
        $(window).trigger(str_hashchange);
      } else if (history_hash !== last_hash) {
        location.href = location.href.replace(/#.*/, '') + history_hash;
      }

      timeout_id = setTimeout(poll, $.fn[str_hashchange].delay);
    }

    ;
    $.browser.msie && !supports_onhashchange && function () {
      var iframe, iframe_src;

      self.start = function () {
        if (!iframe) {
          iframe_src = $.fn[str_hashchange].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide().one('load', function () {
            iframe_src || history_set(get_fragment());
            poll();
          }).attr('src', iframe_src || 'javascript:0').insertAfter('body')[0].contentWindow;

          doc.onpropertychange = function () {
            try {
              if (event.propertyName === 'title') {
                iframe.document.title = doc.title;
              }
            } catch (e) {}
          };
        }
      };

      self.stop = fn_retval;

      history_get = function history_get() {
        return get_fragment(iframe.location.href);
      };

      history_set = function history_set(hash, history_hash) {
        var iframe_doc = iframe.document,
            domain = $.fn[str_hashchange].domain;

        if (hash !== history_hash) {
          iframe_doc.title = doc.title;
          iframe_doc.open();
          domain && iframe_doc.write('<script>document.domain="' + domain + '"</script>');
          iframe_doc.close();
          iframe.location.hash = hash;
        }
      };
    }();
    return self;
  }();
})(jQuery, this);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/* 
 *************************************
 * Count To
 *
 * @param  {Number} fixed              - formats a number using fixed-point notation.
 * @param  {Number} from                 - the number the element should start at
 * @param  {Number} number               - the number the element should end at
 * @param  {Number} duration             - how long it should take to count between the target numbers
 * @param  {Number} refreshInterval      - how often the element should be updated
 * @param  {Boolean} dilimiter           - the number of decimal places to show
 * @param  {Function} onUpdate           - callback method for every time the element is updated
 * @param  {Function} onComplete         - callback method for when the element finishes updating,
 * @param  {Boolean} doubleDigits        - two digits are used by default
 * @return {Void}
 *
 *************************************
 */
(function ($) {
  $.fn.UixCountTo = function (options) {
    options = options || {};
    return $(this).each(function () {
      // set options for current element
      var settings = $.extend({}, $.fn.UixCountTo.defaults, {
        from: $(this).data('counter-start'),
        to: $(this).data('counter-number'),
        fixed: $(this).data('counter-fixed'),
        speed: $(this).data('counter-duration'),
        refreshInterval: $(this).data('counter-refresh-interval'),
        dilimiter: $(this).data('counter-dilimiter'),
        doubleDigits: $(this).data('counter-double-digits')
      }, options); // how many times to update the value, and how much to increment the value on each update

      var loops = Math.ceil(settings.speed / settings.refreshInterval),
          increment = (settings.to - settings.from) / loops; // references & variables that will change with each update

      var self = this,
          $self = $(this),
          loopCount = 0,
          value = settings.from,
          data = $self.data('count-to') || {};
      $self.data('count-to', data); // if an existing interval can be found, clear it first

      if (data.interval) {
        clearInterval(data.interval);
      }

      data.interval = setInterval(updateTimer, settings.refreshInterval); // initialize the element with the starting value

      render(value);

      function updateTimer() {
        value += increment;
        loopCount++;
        render(value);

        if (typeof settings.onUpdate == 'function') {
          settings.onUpdate.call(self, value);
        }

        if (loopCount >= loops) {
          // remove the interval
          $self.removeData('count-to');
          clearInterval(data.interval);
          value = settings.to;

          if (typeof settings.onComplete == 'function') {
            settings.onComplete.call(self, value);
          }
        }
      }

      function render(value) {
        var formattedValue = Number(value).toFixed(settings.fixed);

        if (settings.dilimiter && formattedValue > 0) {
          formattedValue = formattedValue.toString().replace(/\B(?=(?:\d{3})+\b)/g, ',');
        }

        if (settings.doubleDigits) {
          if (formattedValue < 10) {
            formattedValue = '0' + formattedValue;
          }
        }

        $self.html(formattedValue);
      }
    });
  };

  $.fn.UixCountTo.defaults = {
    fixed: 0,
    // formats a number using fixed-point notation.
    from: 0,
    // the number the element should start at
    number: 0,
    // the number the element should end at
    duration: 500,
    // how long it should take to count between the target numbers
    refreshInterval: 1,
    // how often the element should be updated
    dilimiter: true,
    // the number of decimal places to show
    onUpdate: null,
    // callback method for every time the element is updated
    onComplete: null,
    // callback method for when the element finishes updating,
    doubleDigits: false // two digits are used by default

  };
})(jQuery);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * jQuery FlexSlider v2.7.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
(function ($) {
  var focused = true; //FlexSlider: Object Instance

  $.flexslider = function (el, options) {
    var slider = $(el); // making variables public
    //if rtl value was not passed and html is in rtl..enable it by default.

    if (typeof options.rtl == 'undefined' && $('html').attr('dir') == 'rtl') {
      options.rtl = true;
    }

    slider.vars = $.extend({}, $.flexslider.defaults, options);
    var namespace = slider.vars.namespace,
        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
        touch = ("ontouchstart" in window || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
        // deprecating this idea, as devices are being released with both of these events
    eventType = "click touchend MSPointerUp keyup",
        watchedEvent = "",
        watchedEventClearTimer,
        vertical = slider.vars.direction === "vertical",
        reverse = slider.vars.reverse,
        carousel = slider.vars.itemWidth > 0,
        fade = slider.vars.animation === "fade",
        asNav = slider.vars.asNavFor !== "",
        methods = {}; // Store a reference to the slider object

    $.data(el, "flexslider", slider); // Private slider methods

    methods = {
      init: function init() {
        slider.animating = false; // Get current slide and make sure it is a number

        slider.currentSlide = parseInt(slider.vars.startAt ? slider.vars.startAt : 0, 10);

        if (isNaN(slider.currentSlide)) {
          slider.currentSlide = 0;
        }

        slider.animatingTo = slider.currentSlide;
        slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;
        slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length; // SYNC:

        slider.syncExists = $(slider.vars.sync).length > 0; // SLIDE:

        if (slider.vars.animation === "slide") {
          slider.vars.animation = "swing";
        }

        slider.prop = vertical ? "top" : slider.vars.rtl ? "marginRight" : "marginLeft";
        slider.args = {}; // SLIDESHOW:

        slider.manualPause = false;
        slider.stopped = false; //PAUSE WHEN INVISIBLE

        slider.started = false;
        slider.startTimeout = null; // TOUCH/USECSS:

        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && function () {
          var obj = document.createElement('div'),
              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];

          for (var i in props) {
            if (obj.style[props[i]] !== undefined) {
              slider.pfx = props[i].replace('Perspective', '').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }

          return false;
        }();

        slider.ensureAnimationEnd = ''; // CONTROLSCONTAINER:

        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer); // MANUAL:

        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls); // CUSTOM DIRECTION NAV:

        if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav); // RANDOMIZE:

        if (slider.vars.randomize) {
          slider.slides.sort(function () {
            return Math.round(Math.random()) - 0.5;
          });
          slider.container.empty().append(slider.slides);
        }

        slider.doMath(); // INIT

        slider.setup("init"); // CONTROLNAV:

        if (slider.vars.controlNav) {
          methods.controlNav.setup();
        } // DIRECTIONNAV:


        if (slider.vars.directionNav) {
          methods.directionNav.setup();
        } // KEYBOARD:


        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function (event) {
            var keycode = event.keyCode;

            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = slider.vars.rtl ? keycode === 37 ? slider.getTarget('next') : keycode === 39 ? slider.getTarget('prev') : false : keycode === 39 ? slider.getTarget('next') : keycode === 37 ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        } // MOUSEWHEEL:


        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function (event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = delta < 0 ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        } // PAUSEPLAY


        if (slider.vars.pausePlay) {
          methods.pausePlay.setup();
        } //PAUSE WHEN INVISIBLE


        if (slider.vars.slideshow && slider.vars.pauseInvisible) {
          methods.pauseInvisible.init();
        } // SLIDSESHOW


        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function () {
              if (!slider.manualPlay && !slider.manualPause) {
                slider.pause();
              }
            }, function () {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {
                slider.play();
              }
            });
          } // initialize animation
          //If we're visible, or we don't use PageVisibility API


          if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            slider.vars.initDelay > 0 ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        } // ASNAV:


        if (asNav) {
          methods.asNav.setup();
        } // TOUCH


        if (touch && slider.vars.touch) {
          methods.touch();
        } // FADE&&SMOOTHHEIGHT || SLIDE:


        if (!fade || fade && slider.vars.smoothHeight) {
          $(window).bind("resize orientationchange focus", methods.resize);
        }

        slider.find("img").attr("draggable", "false"); // API: start() Callback

        setTimeout(function () {
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function setup() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");

          if (!msGesture) {
            slider.slides.on(eventType, function (e) {
              e.preventDefault();
              var $slide = $(this),
                  target = $slide.index();
              var posFromX;

              if (slider.vars.rtl) {
                posFromX = -1 * ($slide.offset().right - $(slider).scrollLeft()); // Find position of slide relative to right of slider container
              } else {
                posFromX = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
              }

              if (posFromX <= 0 && $slide.hasClass(namespace + 'active-slide')) {
                slider.flexAnimate(slider.getTarget("prev"), true);
              } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                slider.direction = slider.currentItem < target ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
              }
            });
          } else {
            el._slider = slider;
            slider.slides.each(function () {
              var that = this;
              that._gesture = new MSGesture();
              that._gesture.target = that;
              that.addEventListener("MSPointerDown", function (e) {
                e.preventDefault();

                if (e.currentTarget._gesture) {
                  e.currentTarget._gesture.addPointer(e.pointerId);
                }
              }, false);
              that.addEventListener("MSGestureTap", function (e) {
                e.preventDefault();
                var $slide = $(this),
                    target = $slide.index();

                if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                  slider.direction = slider.currentItem < target ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
            });
          }
        }
      },
      controlNav: {
        setup: function setup() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else {
            // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function setupPaging() {
          var type = slider.vars.controlNav === "thumbnails" ? 'control-thumbs' : 'control-paging',
              j = 1,
              item,
              slide;
          slider.controlNavScaffold = $('<ol class="' + namespace + 'control-nav ' + namespace + type + '"></ol>');

          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);

              if (undefined === slide.attr('data-thumb-alt')) {
                slide.attr('data-thumb-alt', '');
              }

              var altText = '' !== slide.attr('data-thumb-alt') ? altText = ' alt="' + slide.attr('data-thumb-alt') + '"' : '';
              item = slider.vars.controlNav === "thumbnails" ? '<img src="' + slide.attr('data-thumb') + '"' + altText + '/>' : '<a href="#">' + j + '</a>';

              if ('thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions) {
                var captn = slide.attr('data-thumbcaption');

                if ('' !== captn && undefined !== captn) {
                  item += '<span class="' + namespace + 'caption">' + captn + '</span>';
                }
              }

              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          } // CONTROLSCONTAINER:


          slider.controlsContainer ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();
          methods.controlNav.active();
          slider.controlNavScaffold.delegate('a, img', eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = target > slider.currentSlide ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        setupManual: function setupManual() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();
          slider.controlNav.bind(eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                target > slider.currentSlide ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        set: function set() {
          var selector = slider.vars.controlNav === "thumbnails" ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, slider.controlsContainer ? slider.controlsContainer : slider);
        },
        active: function active() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function update(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a href="#">' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }

          methods.controlNav.set();
          slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function setup() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>'); // CUSTOM DIRECTION NAV:

          if (slider.customDirectionNav) {
            slider.directionNav = slider.customDirectionNav; // CONTROLSCONTAINER:
          } else if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }

          methods.directionNav.update();
          slider.directionNav.bind(eventType, function (event) {
            event.preventDefault();
            var target;

            if (watchedEvent === "" || watchedEvent === event.type) {
              target = $(this).hasClass(namespace + 'next') ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        update: function update() {
          var disabledClass = namespace + 'disabled';

          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function setup() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a href="#"></a></div>'); // CONTROLSCONTAINER:

          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }

          methods.pausePlay.update(slider.vars.slideshow ? namespace + 'pause' : namespace + 'play');
          slider.pausePlay.bind(eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        update: function update(state) {
          state === "play" ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function touch() {
        var startX,
            startY,
            offset,
            cwidth,
            dx,
            startT,
            onTouchStart,
            onTouchMove,
            _onTouchEnd,
            scrolling = false,
            localX = 0,
            localY = 0,
            accDx = 0;

        if (!msGesture) {
          onTouchStart = function onTouchStart(e) {
            if (slider.animating) {
              e.preventDefault();
            } else if (window.navigator.msPointerEnabled || e.touches.length === 1) {
              slider.pause(); // CAROUSEL:

              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date()); // CAROUSEL:
              // Local vars for X and Y points.

              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;
              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
              startX = vertical ? localY : localX;
              startY = vertical ? localX : localY;
              el.addEventListener('touchmove', onTouchMove, false);
              el.addEventListener('touchend', _onTouchEnd, false);
            }
          };

          onTouchMove = function onTouchMove(e) {
            // Local vars for X and Y points.
            localX = e.touches[0].pageX;
            localY = e.touches[0].pageY;
            dx = vertical ? startX - localY : (slider.vars.rtl ? -1 : 1) * (startX - localX);
            scrolling = vertical ? Math.abs(dx) < Math.abs(localX - startY) : Math.abs(dx) < Math.abs(localY - startY);
            var fxms = 500;

            if (!scrolling || Number(new Date()) - startT > fxms) {
              e.preventDefault();

              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);
                }

                slider.setProps(offset + dx, "setTouch");
              }
            }
          };

          _onTouchEnd = function onTouchEnd(e) {
            // finish the touch by undoing the touch session
            el.removeEventListener('touchmove', onTouchMove, false);

            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');

              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }

            el.removeEventListener('touchend', _onTouchEnd, false);
            startX = null;
            startY = null;
            dx = null;
            offset = null;
          };

          el.addEventListener('touchstart', onTouchStart, false);
        } else {
          var onMSPointerDown = function onMSPointerDown(e) {
            e.stopPropagation();

            if (slider.animating) {
              e.preventDefault();
            } else {
              slider.pause();

              el._gesture.addPointer(e.pointerId);

              accDx = 0;
              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date()); // CAROUSEL:

              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
            }
          };

          var onMSGestureChange = function onMSGestureChange(e) {
            e.stopPropagation();
            var slider = e.target._slider;

            if (!slider) {
              return;
            }

            var transX = -e.translationX,
                transY = -e.translationY; //Accumulate translations.

            accDx = accDx + (vertical ? transY : transX);
            dx = (slider.vars.rtl ? -1 : 1) * accDx;
            scrolling = vertical ? Math.abs(accDx) < Math.abs(-transX) : Math.abs(accDx) < Math.abs(-transY);

            if (e.detail === e.MSGESTURE_FLAG_INERTIA) {
              setImmediate(function () {
                el._gesture.stop();
              });
              return;
            }

            if (!scrolling || Number(new Date()) - startT > 500) {
              e.preventDefault();

              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = accDx / (slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0 ? Math.abs(accDx) / cwidth + 2 : 1);
                }

                slider.setProps(offset + dx, "setTouch");
              }
            }
          };

          var onMSGestureEnd = function onMSGestureEnd(e) {
            e.stopPropagation();
            var slider = e.target._slider;

            if (!slider) {
              return;
            }

            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');

              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }

            startX = null;
            startY = null;
            dx = null;
            offset = null;
            accDx = 0;
          };

          el.style.msTouchAction = "none";
          el._gesture = new MSGesture();
          el._gesture.target = el;
          el.addEventListener("MSPointerDown", onMSPointerDown, false);
          el._slider = slider;
          el.addEventListener("MSGestureChange", onMSGestureChange, false);
          el.addEventListener("MSGestureEnd", onMSGestureEnd, false);
        }
      },
      resize: function resize() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) {
            slider.doMath();
          }

          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) {
            //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          } else if (vertical) {
            //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }

            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function smoothHeight(dur) {
        if (!vertical || fade) {
          var $obj = fade ? slider : slider.viewport;
          dur ? $obj.animate({
            "height": slider.slides.eq(slider.animatingTo).innerHeight()
          }, dur) : $obj.innerHeight(slider.slides.eq(slider.animatingTo).innerHeight());
        }
      },
      sync: function sync(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
            target = slider.animatingTo;

        switch (action) {
          case "animate":
            $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);
            break;

          case "play":
            if (!$obj.playing && !$obj.asNav) {
              $obj.play();
            }

            break;

          case "pause":
            $obj.pause();
            break;
        }
      },
      uniqueID: function uniqueID($clone) {
        // Append _clone to current level and children elements with id attributes
        $clone.filter('[id]').add($clone.find('[id]')).each(function () {
          var $this = $(this);
          $this.attr('id', $this.attr('id') + '_clone');
        });
        return $clone;
      },
      pauseInvisible: {
        visProp: null,
        init: function init() {
          var visProp = methods.pauseInvisible.getHiddenProp();

          if (visProp) {
            var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
            document.addEventListener(evtname, function () {
              if (methods.pauseInvisible.isHidden()) {
                if (slider.startTimeout) {
                  clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                } else {
                  slider.pause(); //Or just pause
                }
              } else {
                if (slider.started) {
                  slider.play(); //Initiated before, just play
                } else {
                  if (slider.vars.initDelay > 0) {
                    setTimeout(slider.play, slider.vars.initDelay);
                  } else {
                    slider.play(); //Didn't init before: simply init or wait for it
                  }
                }
              }
            });
          }
        },
        isHidden: function isHidden() {
          var prop = methods.pauseInvisible.getHiddenProp();

          if (!prop) {
            return false;
          }

          return document[prop];
        },
        getHiddenProp: function getHiddenProp() {
          var prefixes = ['webkit', 'moz', 'ms', 'o']; // if 'hidden' is natively supported just return it

          if ('hidden' in document) {
            return 'hidden';
          } // otherwise loop over all the known prefixes until we find one


          for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] + 'Hidden' in document) {
              return prefixes[i] + 'Hidden';
            }
          } // otherwise it's not supported


          return null;
        }
      },
      setToClearWatchedEvent: function setToClearWatchedEvent() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function () {
          watchedEvent = "";
        }, 3000);
      }
    }; // public methods

    slider.flexAnimate = function (target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = target > slider.currentSlide ? "next" : "prev";
      }

      if (asNav && slider.pagingCount === 1) slider.direction = slider.currentItem < target ? "next" : "prev";

      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = slider.currentItem < target ? "next" : "prev";
          master.direction = slider.direction;

          if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target / slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }

        slider.animating = true;
        slider.animatingTo = target; // SLIDESHOW:

        if (pause) {
          slider.pause();
        } // API: before() animation Callback


        slider.vars.before(slider); // SYNC:

        if (slider.syncExists && !fromNav) {
          methods.sync("animate");
        } // CONTROLNAV


        if (slider.vars.controlNav) {
          methods.controlNav.active();
        } // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)


        if (!carousel) {
          slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');
        } // INFINITE LOOP:
        // CANDIDATE: atEnd


        slider.atEnd = target === 0 || target === slider.last; // DIRECTIONNAV:

        if (slider.vars.directionNav) {
          methods.directionNav.update();
        }

        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider); // SLIDESHOW && !INFINITE LOOP:

          if (!slider.vars.animationLoop) {
            slider.pause();
          }
        } // SLIDE:


        if (!fade) {
          var dimension = vertical ? slider.slides.filter(':first').height() : slider.computedW,
              margin,
              slideString,
              calcNext; // INFINITE LOOP / REVERSE:

          if (carousel) {
            margin = slider.vars.itemMargin;
            calcNext = (slider.itemW + margin) * slider.move * slider.animatingTo;
            slideString = calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = reverse ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = reverse ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = reverse ? (slider.count - 1 - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }

          slider.setProps(slideString, "", slider.vars.animationSpeed);

          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            } // Unbind previous transitionEnd events and re-bind new transitionEnd event


            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function () {
              clearTimeout(slider.ensureAnimationEnd);
              slider.wrapup(dimension);
            }); // Insurance for the ever-so-fickle transitionEnd event

            clearTimeout(slider.ensureAnimationEnd);
            slider.ensureAnimationEnd = setTimeout(function () {
              slider.wrapup(dimension);
            }, slider.vars.animationSpeed + 100);
          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function () {
              slider.wrapup(dimension);
            });
          }
        } else {
          // FADE:
          if (!touch) {
            slider.slides.eq(slider.currentSlide).css({
              "zIndex": 1
            }).animate({
              "opacity": 0
            }, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({
              "zIndex": 2
            }).animate({
              "opacity": 1
            }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);
          } else {
            slider.slides.eq(slider.currentSlide).css({
              "opacity": 0,
              "zIndex": 1
            });
            slider.slides.eq(target).css({
              "opacity": 1,
              "zIndex": 2
            });
            slider.wrapup(dimension);
          }
        } // SMOOTH HEIGHT:


        if (slider.vars.smoothHeight) {
          methods.smoothHeight(slider.vars.animationSpeed);
        }
      }
    };

    slider.wrapup = function (dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }

      slider.animating = false;
      slider.currentSlide = slider.animatingTo; // API: after() animation Callback

      slider.vars.after(slider);
    }; // SLIDESHOW:


    slider.animateSlides = function () {
      if (!slider.animating && focused) {
        slider.flexAnimate(slider.getTarget("next"));
      }
    }; // SLIDESHOW:


    slider.pause = function () {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false; // PAUSEPLAY:

      if (slider.vars.pausePlay) {
        methods.pausePlay.update("play");
      } // SYNC:


      if (slider.syncExists) {
        methods.sync("pause");
      }
    }; // SLIDESHOW:


    slider.play = function () {
      if (slider.playing) {
        clearInterval(slider.animatedSlides);
      }

      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true; // PAUSEPLAY:

      if (slider.vars.pausePlay) {
        methods.pausePlay.update("pause");
      } // SYNC:


      if (slider.syncExists) {
        methods.sync("play");
      }
    }; // STOP:


    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    };

    slider.canAdvance = function (target, fromNav) {
      // ASNAV:
      var last = asNav ? slider.pagingCount - 1 : slider.last;
      return fromNav ? true : asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev" ? true : asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next" ? false : target === slider.currentSlide && !asNav ? false : slider.vars.animationLoop ? true : slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next" ? false : slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next" ? false : true;
    };

    slider.getTarget = function (dir) {
      slider.direction = dir;

      if (dir === "next") {
        return slider.currentSlide === slider.last ? 0 : slider.currentSlide + 1;
      } else {
        return slider.currentSlide === 0 ? slider.last : slider.currentSlide - 1;
      }
    }; // SLIDE:


    slider.setProps = function (pos, special, dur) {
      var target = function () {
        var posCheck = pos ? pos : (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo,
            posCalc = function () {
          if (carousel) {
            return special === "setTouch" ? pos : reverse && slider.animatingTo === slider.last ? 0 : reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : slider.animatingTo === slider.last ? slider.limit : posCheck;
          } else {
            switch (special) {
              case "setTotal":
                return reverse ? (slider.count - 1 - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;

              case "setTouch":
                return reverse ? pos : pos;

              case "jumpEnd":
                return reverse ? pos : slider.count * pos;

              case "jumpStart":
                return reverse ? slider.count * pos : pos;

              default:
                return pos;
            }
          }
        }();

        return posCalc * (slider.vars.rtl ? 1 : -1) + "px";
      }();

      if (slider.transitions) {
        target = vertical ? "translate3d(0," + target + ",0)" : "translate3d(" + ((slider.vars.rtl ? -1 : 1) * parseInt(target) + 'px') + ",0,0)";
        dur = dur !== undefined ? dur / 1000 + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
        slider.container.css("transition-duration", dur);
      }

      slider.args[slider.prop] = target;

      if (slider.transitions || dur === undefined) {
        slider.container.css(slider.args);
      }

      slider.container.css('transform', target);
    };

    slider.setup = function (type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;

        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({
            "overflow": "hidden",
            "position": "relative"
          }).appendTo(slider).append(slider.container); // INFINITE LOOP:

          slider.cloneCount = 0;
          slider.cloneOffset = 0; // REVERSE:

          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        } // INFINITE LOOP && !CAROUSEL:


        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1; // clear out old clones

          if (type !== "init") {
            slider.container.find('.clone').remove();
          }

          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true')).prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
        }

        slider.newSlides = $(slider.vars.selector, slider);
        sliderOffset = reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset; // VERTICAL:

        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function () {
            slider.newSlides.css({
              "display": "block"
            });
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, type === "init" ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function () {
            slider.doMath();

            if (slider.vars.rtl) {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            } else {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            } // SMOOTH HEIGHT:


            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }
          }, type === "init" ? 100 : 0);
        }
      } else {
        // FADE:
        if (slider.vars.rtl) {
          slider.slides.css({
            "width": "100%",
            "float": 'right',
            "marginLeft": "-100%",
            "position": "relative"
          });
        } else {
          slider.slides.css({
            "width": "100%",
            "float": 'left',
            "marginRight": "-100%",
            "position": "relative"
          });
        }

        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            if (slider.vars.fadeFirstSlide == false) {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).css({
                "opacity": 1
              });
            } else {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).animate({
                "opacity": 1
              }, slider.vars.animationSpeed, slider.vars.easing);
            }
          } else {
            slider.slides.css({
              "opacity": 0,
              "display": "block",
              "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease",
              "zIndex": 1
            }).eq(slider.currentSlide).css({
              "opacity": 1,
              "zIndex": 2
            });
          }
        } // SMOOTH HEIGHT:


        if (slider.vars.smoothHeight) {
          methods.smoothHeight();
        }
      } // !CAROUSEL:
      // CANDIDATE: active slide


      if (!carousel) {
        slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
      } //FlexSlider: init() Callback


      slider.vars.init(slider);
    };

    slider.doMath = function () {
      var slide = slider.slides.first(),
          slideMargin = slider.vars.itemMargin,
          minItems = slider.vars.minItems,
          maxItems = slider.vars.maxItems;
      slider.w = slider.viewport === undefined ? slider.width() : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width(); // CAROUSEL:

      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.itemM = slideMargin;
        slider.minW = minItems ? minItems * slider.itemT : slider.w;
        slider.maxW = maxItems ? maxItems * slider.itemT - slideMargin : slider.w;
        slider.itemW = slider.minW > slider.w ? (slider.w - slideMargin * (minItems - 1)) / minItems : slider.maxW < slider.w ? (slider.w - slideMargin * (maxItems - 1)) / maxItems : slider.vars.itemWidth > slider.w ? slider.w : slider.vars.itemWidth;
        slider.visible = Math.floor(slider.w / slider.itemW);
        slider.move = slider.vars.move > 0 && slider.vars.move < slider.visible ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil((slider.count - slider.visible) / slider.move + 1);
        slider.last = slider.pagingCount - 1;
        slider.limit = slider.pagingCount === 1 ? 0 : slider.vars.itemWidth > slider.w ? slider.itemW * (slider.count - 1) + slideMargin * (slider.count - 1) : (slider.itemW + slideMargin) * slider.count - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.itemM = slideMargin;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }

      slider.computedW = slider.itemW - slider.boxPadding;
      slider.computedM = slider.itemM;
    };

    slider.update = function (pos, action) {
      slider.doMath(); // update currentSlide and slider.animatingTo if necessary

      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }

        slider.animatingTo = slider.currentSlide;
      } // update controlNav


      if (slider.vars.controlNav && !slider.manualControls) {
        if (action === "add" && !carousel || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if (action === "remove" && !carousel || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }

          methods.controlNav.update("remove", slider.last);
        }
      } // update directionNav


      if (slider.vars.directionNav) {
        methods.directionNav.update();
      }
    };

    slider.addSlide = function (obj, pos) {
      var $obj = $(obj);
      slider.count += 1;
      slider.last = slider.count - 1; // append new slide

      if (vertical && reverse) {
        pos !== undefined ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        pos !== undefined ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      } // update currentSlide, animatingTo, controlNav, and directionNav


      slider.update(pos, "add"); // update slider.slides

      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide

      slider.setup(); //FlexSlider: added() Callback

      slider.vars.added(slider);
    };

    slider.removeSlide = function (obj) {
      var pos = isNaN(obj) ? slider.slides.index($(obj)) : obj; // update count

      slider.count -= 1;
      slider.last = slider.count - 1; // remove slide

      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        vertical && reverse ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      } // update currentSlide, animatingTo, controlNav, and directionNav


      slider.doMath();
      slider.update(pos, "remove"); // update slider.slides

      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide

      slider.setup(); // FlexSlider: removed() Callback

      slider.vars.removed(slider);
    }; //FlexSlider: Initialize


    methods.init();
  }; // Ensure the slider isn't focussed if the window loses focus.


  $(window).blur(function (e) {
    focused = false;
  }).focus(function (e) {
    focused = true;
  }); //FlexSlider: Default Settings

  $.flexslider.defaults = {
    namespace: "flex-",
    //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",
    //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",
    //String: Select your animation type, "fade" or "slide"
    easing: "swing",
    //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",
    //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,
    //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,
    //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,
    //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,
    //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,
    //Boolean: Animate slider automatically
    slideshowSpeed: 7000,
    //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,
    //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,
    //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,
    //Boolean: Randomize slide order
    fadeFirstSlide: true,
    //Boolean: Fade in the first slide when animation type is "fade"
    thumbCaptions: false,
    //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.
    // Usability features
    pauseOnAction: true,
    //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,
    //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,
    //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,
    //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,
    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,
    //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches
    // Primary Controls
    controlNav: true,
    //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
    directionNav: true,
    //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",
    //String: Set the text for the "previous" directionNav item
    nextText: "Next",
    //String: Set the text for the "next" directionNav item
    // Secondary Navigation
    keyboard: true,
    //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,
    //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,
    //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,
    //Boolean: Create pause/play dynamic element
    pauseText: "Pause",
    //String: Set the text for the "pause" pausePlay item
    playText: "Play",
    //String: Set the text for the "play" pausePlay item
    // Special properties
    controlsContainer: "",
    //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",
    //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    customDirectionNav: "",
    //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
    sync: "",
    //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",
    //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider
    // Carousel Options
    itemWidth: 0,
    //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,
    //{NEW} Integer: Margin between carousel items.
    minItems: 1,
    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,
    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,
    //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,
    //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide
    // Callback API
    start: function start() {},
    //Callback: function(slider) - Fires when the slider loads the first slide
    before: function before() {},
    //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function after() {},
    //Callback: function(slider) - Fires after each slider animation completes
    end: function end() {},
    //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function added() {},
    //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function removed() {},
    //{NEW} Callback: function(slider) - Fires after a slide is removed
    init: function init() {},
    //{NEW} Callback: function(slider) - Fires after the slider is initially setup
    rtl: false //{NEW} Boolean: Whether or not to enable RTL mode

  }; //FlexSlider: Plugin Function

  $.fn.flexslider = function (options) {
    if (options === undefined) {
      options = {};
    }

    if (_typeof(options) === "object") {
      return this.each(function () {
        var $this = $(this),
            selector = options.selector ? options.selector : ".slides > li",
            $slides = $this.find(selector);

        if ($slides.length === 1 && options.allowOneSlide === false || $slides.length === 0) {
          $slides.fadeIn(400);

          if (options.start) {
            options.start($this);
          }
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');

      switch (options) {
        case "play":
          $slider.play();
          break;

        case "pause":
          $slider.pause();
          break;

        case "stop":
          $slider.stop();
          break;

        case "next":
          $slider.flexAnimate($slider.getTarget("next"), true);
          break;

        case "prev":
        case "previous":
          $slider.flexAnimate($slider.getTarget("prev"), true);
          break;

        default:
          if (typeof options === "number") {
            $slider.flexAnimate(options, true);
          }

      }
    }
  };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(25).setImmediate))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(26);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2), __webpack_require__(27)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Shows the next form.
 *
 * @param  {Element} selector        - Each target forms selector.
 * @param  {Element} formTarget      - Wrapper of target forms selector.
 * @param  {String} indicator       - Indicator of timeline.
 * @param  {Number} index           - Default index for initialization.
 * 									  0 => step one, 
 * 									  1 => step two
 * 									  2 => step three
 * 									  3 => step four
 * 									  4 => step five
 * 									  ...
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixFormProgressToNext = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: $('.uix-form-progress__target .uix-form-progress__target__step'),
      formTarget: $('.uix-form-progress__target'),
      indicator: '.uix-form-progress .uix-form-progress__indicator',
      index: 0
    }, options);
    this.each(function () {
      var $this = $(this);
      var transitionEnd = 'webkitTransitionEnd transitionend',
          $sections = settings.selector,
          $formTarget = settings.formTarget,
          $indicator = $(settings.indicator),
          allStep = $indicator.length,
          stepPerValue = 100 / (allStep - 1);
      var value = 0,
          tarIndex,
          curIndex;
      if ($indicator.length == 0) return false; //Returns current index

      if (settings.index > allStep - 1) {
        curIndex = allStep - 1;
      } else {
        curIndex = settings.index;
      }

      tarIndex = curIndex - 1; // Returns current index

      if (tarIndex > allStep - 2) {
        value = stepPerValue * (allStep - 2);
        curIndex = allStep - 2;
      } else {
        curIndex = tarIndex;
      } // Increment value (based on 4 steps 0 - 100)


      value = stepPerValue * curIndex; //Get form transition speed

      var dur = $formTarget.data('anime-speed');

      if (_typeof(dur) === ( true ? "undefined" : undefined)) {
        dur = '0.5s';
      }

      var durString = dur.toString().toLowerCase(),
          isMS = durString.indexOf('ms') >= 0,
          numberNum = durString.replace('ms', '').replace('s', ''),
          animeSpeed = isMS ? numberNum : numberNum * 1000;
      var currentFormStep = parseInt($sections.eq(tarIndex).attr('data-step')) || false,
          $nextForm = $formTarget.find('.uix-form-progress__target__step[data-step="' + (currentFormStep + 1) + '"]');
      var currentFormIndex = $nextForm.attr('data-step') - 1;
      if (isNaN(currentFormIndex)) currentFormIndex = 0; // Activate other unused modules

      if (currentFormIndex > 0) {
        for (var i = 0; i < curIndex; i++) {
          $sections.eq(i).addClass('leaving');
          $indicator.eq(i).addClass('is-active');
        }

        $indicator.eq(curIndex).addClass('is-active');
      } // Hide current form fields


      $sections.eq(tarIndex).addClass('leaving');
      setTimeout(function () {
        $indicator.eq(currentFormIndex).addClass('is-active');
      }, animeSpeed); // Show next form fields

      $nextForm.addClass('coming').one(transitionEnd, function () {
        $nextForm.removeClass('coming waiting');
      }); // Active next form fields

      $sections.removeClass('is-active');
      $sections.eq(currentFormIndex).addClass('is-active'); // Increment value (based on 4 steps 0 - 100)

      value += stepPerValue; //console.log( currentFormIndex );
      //Initialize pointer and form location data

      if (currentFormIndex == 0) {
        //Avoid initialization to always cover other same events
        $('body').addClass('form-progress-initok'); //so something

        $indicator.removeClass('is-active');
        $indicator.each(function (index) {
          $(this).css('left', index * stepPerValue + '%');
          $formTarget.find('.uix-form-progress__target__step:eq(' + index + ')').attr('data-step', index + 1);
        });
        setTimeout(function () {
          $formTarget.addClass('js-uix-show');
        }, animeSpeed);
        $formTarget.find('.uix-form-progress__target__step').removeClass('left leaving').css({
          'position': 'absolute'
        }).not(':eq(0)').addClass('waiting');
      } //Set wrapper height


      var currentContentH = $formTarget.find('.uix-form-progress__target__step:eq(' + currentFormIndex + ') > .uix-form-progress__content').height() + 100;
      $formTarget.css('height', currentContentH + 'px');
      var curText = $('.uix-form-progress .uix-form-progress__indicator:eq(' + currentFormIndex + ') > span').html();
      $('#app-form-progress-text').text(curText); //The current indicator class

      $indicator.removeClass('current');
      $indicator.eq(currentFormIndex).addClass('current'); // Reset if we've reached the end

      if (value >= 100) {
        $formTarget.find('.uix-form-progress__target__step').addClass('leaving').last().removeClass('coming waiting leaving');
      } else {
        $('.uix-form-progress').find('.uix-form-progress__indicator.is-active').next('.uix-form-progress__indicator').addClass('is-active');
      } // Set progress bar value


      $('.uix-form-progress .uix-form-progress__line span').css('width', value + '%');
      return false;
    });
  };
})(jQuery);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Render Normal Radio Status
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderNormalRadio = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__radio'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        $(this).find('> label').each(function () {
          var targetID = '#' + $(this).parent().attr("data-targetid");
          var switchIDs = ''; //add switch IDs

          $(this).parent().find('> label').each(function () {
            if (_typeof($(this).data("switchid")) != ( true ? "undefined" : undefined)) {
              switchIDs += $(this).data("switchid") + ',';
            }
          });
          $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, '')); //Set actived style from their values

          if (_typeof($(this).data('value')) != ( true ? "undefined" : undefined)) {
            if ($(targetID).val() == $(this).data('value')) {
              $(this).addClass('is-active').find('[type="radio"]').prop('checked', true);
            } else {
              $(this).removeClass('is-active').find('[type="radio"]').prop('checked', false);
            }
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 33 */
/***/ (function(module, exports) {

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */
(function ($) {
  var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
      toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
      slice = Array.prototype.slice,
      nullLowestDeltaTimeout,
      lowestDelta;

  if ($.event.fixHooks) {
    for (var i = toFix.length; i;) {
      $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    }
  }

  var special = $.event.special.mousewheel = {
    version: '3.1.12',
    setup: function setup() {
      if (this.addEventListener) {
        for (var i = toBind.length; i;) {
          this.addEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = handler;
      } // Store the line height and page height for this particular element


      $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
      $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
    },
    teardown: function teardown() {
      if (this.removeEventListener) {
        for (var i = toBind.length; i;) {
          this.removeEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = null;
      } // Clean up the data we added to the element


      $.removeData(this, 'mousewheel-line-height');
      $.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function getLineHeight(elem) {
      var $elem = $(elem),
          $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();

      if (!$parent.length) {
        $parent = $('body');
      }

      return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
    },
    getPageHeight: function getPageHeight(elem) {
      return $(elem).height();
    },
    settings: {
      adjustOldDeltas: true,
      // see shouldAdjustOldDeltas() below
      normalizeOffset: true // calls getBoundingClientRect for each event

    }
  };
  $.fn.extend({
    mousewheel: function mousewheel(fn) {
      return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
    },
    unmousewheel: function unmousewheel(fn) {
      return this.unbind('mousewheel', fn);
    }
  });

  function handler(event) {
    var orgEvent = event || window.event,
        args = slice.call(arguments, 1),
        delta = 0,
        deltaX = 0,
        deltaY = 0,
        absDelta = 0,
        offsetX = 0,
        offsetY = 0;
    event = $.event.fix(orgEvent);
    event.type = 'mousewheel'; // Old school scrollwheel delta

    if ('detail' in orgEvent) {
      deltaY = orgEvent.detail * -1;
    }

    if ('wheelDelta' in orgEvent) {
      deltaY = orgEvent.wheelDelta;
    }

    if ('wheelDeltaY' in orgEvent) {
      deltaY = orgEvent.wheelDeltaY;
    }

    if ('wheelDeltaX' in orgEvent) {
      deltaX = orgEvent.wheelDeltaX * -1;
    } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


    if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
      deltaX = deltaY * -1;
      deltaY = 0;
    } // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy


    delta = deltaY === 0 ? deltaX : deltaY; // New school wheel delta (wheel event)

    if ('deltaY' in orgEvent) {
      deltaY = orgEvent.deltaY * -1;
      delta = deltaY;
    }

    if ('deltaX' in orgEvent) {
      deltaX = orgEvent.deltaX;

      if (deltaY === 0) {
        delta = deltaX * -1;
      }
    } // No change actually happened, no reason to go any further


    if (deltaY === 0 && deltaX === 0) {
      return;
    } // Need to convert lines and pages to pixels if we aren't already in pixels
    // There are three delta modes:
    //   * deltaMode 0 is by pixels, nothing to do
    //   * deltaMode 1 is by lines
    //   * deltaMode 2 is by pages


    if (orgEvent.deltaMode === 1) {
      var lineHeight = $.data(this, 'mousewheel-line-height');
      delta *= lineHeight;
      deltaY *= lineHeight;
      deltaX *= lineHeight;
    } else if (orgEvent.deltaMode === 2) {
      var pageHeight = $.data(this, 'mousewheel-page-height');
      delta *= pageHeight;
      deltaY *= pageHeight;
      deltaX *= pageHeight;
    } // Store lowest absolute delta to normalize the delta values


    absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta; // Adjust older deltas if necessary

      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
        lowestDelta /= 40;
      }
    } // Adjust older deltas if necessary


    if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
      // Divide all the things by 40!
      delta /= 40;
      deltaX /= 40;
      deltaY /= 40;
    } // Get a whole, normalized value for the deltas


    delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
    deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
    deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta); // Normalise offsetX and offsetY properties

    if (special.settings.normalizeOffset && this.getBoundingClientRect) {
      var boundingRect = this.getBoundingClientRect();
      offsetX = event.clientX - boundingRect.left;
      offsetY = event.clientY - boundingRect.top;
    } // Add information to the event object


    event.deltaX = deltaX;
    event.deltaY = deltaY;
    event.deltaFactor = lowestDelta;
    event.offsetX = offsetX;
    event.offsetY = offsetY; // Go ahead and set deltaMode to 0 since we converted to pixels
    // Although this is a little odd since we overwrite the deltaX/Y
    // properties with normalized deltas.

    event.deltaMode = 0; // Add event and delta to the front of the arguments

    args.unshift(event, delta, deltaX, deltaY); // Clearout lowestDelta after sometime to better
    // handle multiple device types that give different
    // a different lowestDelta
    // Ex: trackpad = 3 and mouse wheel = 120

    if (nullLowestDeltaTimeout) {
      clearTimeout(nullLowestDeltaTimeout);
    }

    nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
    return ($.event.dispatch || $.event.handle).apply(this, args);
  }

  function nullLowestDelta() {
    lowestDelta = null;
  }

  function shouldAdjustOldDeltas(orgEvent, absDelta) {
    // If this is an older event and the delta is divisable by 120,
    // then we are assuming that the browser is treating this as an
    // older mouse wheel event and that we should divide the deltas
    // by 40 to try and get a more usable deltaFactor.
    // Side note, this actually impacts the reported scroll distance
    // in older browsers and can cause scrolling to be slower than native.
    // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
    return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
  }
})(jQuery);

/***/ }),
/* 34 */
/***/ (function(module, exports) {

/*
 * Hover Effect
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsHover = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.js-uix-float-label'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this); // on focus add cladd active to label

        $this.on('focus', function () {
          $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
        }); //on blur check field and remove class if needed

        $this.on('blur change', function (e) {
          if ($this.val() === '' || $this.val() === 'blank') {
            $(this).closest('div').find('label').removeClass('is-active');
          } //----


          if ($this.val() === '' || $this.val() === 'blank' || $this.val() != '' && $this.val() != 'blank') {
            $(this).closest('div').find('.uix-controls__bar').removeClass('is-active');
          }
        }); // if exist cookie value

        if ($this.val() != '' && $this.val() != 'blank') {
          $(this).closest('div').find('label').addClass('is-active');
        }
      });
    });
  };
})(jQuery);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Render Single Selector Status
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSingleSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__single-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        $(this).find('> span').each(function () {
          var targetID = '#' + $(this).parent().attr('data-targetid');
          var switchIDs = ''; //add switch IDs

          $(this).parent().find('> span').each(function () {
            if (_typeof($(this).data("switchid")) != ( true ? "undefined" : undefined)) {
              switchIDs += $(this).data("switchid") + ',';
            }
          });
          $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, '')); //Set actived style from their values

          if ($(targetID).val() == $(this).data('value')) {
            $(this).addClass('is-active').attr('aria-checked', true);
          } else {
            $(this).removeClass('is-active').attr('aria-checked', false);
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 36 */
/***/ (function(module, exports) {

/*
 * Render Multiple Selector Status
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomMultiSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__multi-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        $(this).find('> span').each(function () {
          var targetID = '#' + $(this).parent().attr('data-targetid');

          if ($(targetID).val().indexOf($(this).data('value')) >= 0) {
            $(this).addClass('is-active').attr('aria-checked', true);
          } else {
            $(this).removeClass('is-active').attr('aria-checked', false);
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 37 */
/***/ (function(module, exports) {

/*
 * Render Custom File Dropzone
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFileDropzone = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-field-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $dropZone = $(this).find('input[type="file"]');
        $(document).on('dragover', function (e) {
          var timeout = window.dropZoneTimeout;

          if (!timeout) {
            $dropZone.addClass('in');
          } else {
            clearTimeout(timeout);
          }

          var found = false,
              node = e.target;

          do {
            if (node === $dropZone[0]) {
              found = true;
              break;
            }

            node = node.parentNode;
          } while (node != null);

          if (found) {
            $dropZone.addClass('hover');
          } else {
            $dropZone.removeClass('hover');
          }

          window.dropZoneTimeout = setTimeout(function () {
            window.dropZoneTimeout = null;
            $dropZone.removeClass('in hover');
          }, 100);
        });
        $dropZone.on('change', function (e) {
          var input = $(this)[0];

          if (input.files && input.files[0]) {
            var reader = new FileReader();

            reader.onload = function (e) {
              var imgData = e.target.result;
              var imgName = input.files[0].name;
              input.setAttribute('data-title', imgName); //console.log(e.target.result);
            };

            reader.readAsDataURL(input.files[0]);
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 38 */
/***/ (function(module, exports) {

/*
 * Render Custom File Type
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFile = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $fileInput = $(this).find('input[type="file"]'),
            $fileBtn = $(this).find('.uix-controls__file-trigger'),
            $filePath = $(this).next('.uix-controls__file-return');
        $fileBtn.off('click').on('click', function () {
          $fileInput.focusin();
        });
        $fileInput.on('change', function () {
          $filePath.text($(this).val());
        });
      });
    });
  };
})(jQuery);

/***/ }),
/* 39 */
/***/ (function(module, exports) {

/*
 * Disabled Controls Status
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsDisable = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: 'input.is-disabled'
    }, options);
    this.each(function () {
      $(settings.controls).prop('disabled', true);
    });
  };
})(jQuery);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Create Line Effect on Click
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsLineEff = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls.uix-controls--line'
    }, options);
    this.each(function () {
      var $this = $(this);
      var customControls = settings.controls;
      $(customControls).each(function () {
        var dataExist = $(this).data('exist');

        if (_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          $('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>').insertAfter($(this).find('label')); //Multiple Selector or Single Selector

          if ($(this).hasClass('uix-controls__multi-sel') || $(this).hasClass('uix-controls__single-sel')) {
            $(this).find('> span').each(function () {
              $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
            });
          } //Custom Input Number


          if ($(this).hasClass('uix-controls__number')) {
            $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
          } //Prevent the form from being initialized again


          $(this).data('exist', 1);
        }
      });
    });
  };
})(jQuery);

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Render Custom Radio, Checkbox and Toggle 
 *
 * @param  {String} radioWrapper             - Wrapper of the radio.
 * @param  {String} toggle                   - Toggle of the checkbox.
 * @param  {String} checkboxWrapper          - Wrapper of the checkbox.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomRadioCheckbox = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      radioWrapper: '.uix-controls__radio',
      toggle: '.uix-controls__toggle',
      checkboxWrapper: '.uix-controls__checkbox'
    }, options);
    this.each(function () {
      var $this = $(this);
      var customRadio = settings.radioWrapper,
          customToggle = settings.toggle,
          customCheckbox = settings.checkboxWrapper;
      $(customRadio).find('input[type="radio"]').each(function () {
        var dataExist = $(this).data('exist');

        if (_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          $('<span class="uix-controls__radio-trigger"></span>').insertAfter($(this)); //Prevent the form from being initialized again

          $(this).data('exist', 1);
        }
      });
      $(customToggle).find('input[type="checkbox"]').each(function () {
        var dataExist = $(this).data('exist'),
            $obj = $(this).closest('.uix-controls'),
            offText = $obj.data('off-text'),
            onText = $obj.data('on-text');

        if (_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          $('<span class="uix-controls__toggle-trigger" data-off-text="' + offText + '" data-on-text="' + onText + '"></span>').insertAfter($(this)); //hide or display a associated div

          var targetID = '#' + $obj.attr('data-targetid');

          if ($(this).is(':checked')) {
            $obj.addClass('is-active').attr('aria-checked', true);
            $(targetID).show();
          } else {
            $obj.removeClass('is-active').attr('aria-checked', false);
            $(targetID).hide();
          } //Prevent the form from being initialized again


          $(this).data('exist', 1);
        }
      });
      $(customCheckbox).find('input[type="checkbox"]').each(function () {
        var dataExist = $(this).data('exist'),
            $obj = $(this).closest('.uix-controls');

        if (_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          $('<span class="uix-controls__checkbox-trigger"></span>').insertAfter($(this)); //hide or display a associated div

          var targetID = '#' + $obj.attr('data-targetid');

          if ($(this).is(':checked')) {
            $obj.addClass('is-active').attr('aria-checked', true);
            $(targetID).show();
          } else {
            $obj.removeClass('is-active').attr('aria-checked', false);
            $(targetID).hide();
          } //Prevent the form from being initialized again


          $(this).data('exist', 1);
        }
      });
    });
  };
})(jQuery);

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 73 */
/***/ (function(module, exports) {

/**
 * jQuery.fn.sortElements
 * --------------
 * @author James Padolsey (http://james.padolsey.com)
 * @version 0.11
 * @updated 18-MAR-2010
 * --------------
 * @param Function comparator:
 *   Exactly the same behaviour as [1,2,3].sort(comparator)
 *   
 * @param Function getSortable
 *   A function that should return the element that is
 *   to be sorted. The comparator will run on the
 *   current collection, but you may want the actual
 *   resulting sort to occur on a parent or another
 *   associated element.
 *   
 *   E.g. $('td').sortElements(comparator, function(){
 *      return this.parentNode; 
 *   })
 *   
 *   The <td>'s parent (<tr>) will be sorted instead
 *   of the <td> itself.
 */
jQuery.fn.sortElements = function () {
  var sort = [].sort;
  return function (comparator, getSortable) {
    getSortable = getSortable || function () {
      return this;
    };

    var placements = this.map(function () {
      var sortElement = getSortable.call(this),
          parentNode = sortElement.parentNode,
          // Since the element itself will change position, we have
      // to have some way of storing it's original position in
      // the DOM. The easiest way is to have a 'flag' node:
      nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);
      return function () {
        if (parentNode === this) {
          throw new Error("You can't sort elements if any one is a descendant of another.");
        } // Insert before flag:


        parentNode.insertBefore(this, nextSibling); // Remove flag:

        parentNode.removeChild(nextSibling);
      };
    });
    return sort.call(this, comparator).each(function (i) {
      placements[i].call(getSortable.call(this));
    });
  };
}();

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Text Animation
 *
 * @param  {String} selectors                - Text wrapper ID or class name.
 * @return {Void}
 */
(function ($) {
  $.fn.UixTextEff = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selectors: '.letters-eff-fadeInRight',
      scrollSpy: false
    }, options);
    this.each(function () {
      var customControls = settings.selectors;
      var scrollSpy = settings.scrollSpy;
      var $this = $(customControls);
      var speed = $this.data('text-eff-speed'),
          txtEff;

      if (_typeof(speed) === ( true ? "undefined" : undefined)) {
        speed = 1200;
      } //The data-text-eff attribute must be unique, otherwise it will not execute correctly.


      if ($this.length > 1) return false;
      $this.html($this.text().replace(/([^\x00-\x80]|\w|((?=[\x21-\x7e]+)[^A-Za-z0-9]))/g, "<span class='uix-letter'>$&</span>")); //--------------

      if (customControls.indexOf('fadeInRight') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateX: [40, 0],
          translateZ: 0,
          opacity: [0, 1],
          easing: "easeOutExpo",
          duration: speed,
          delay: function delay(el, i) {
            return 500 + 30 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('zoomInDown') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          scale: [0, 1],
          duration: speed,
          elasticity: 600,
          delay: function delay(el, i) {
            return 45 * (i + 1);
          }
        });
      } //--------------


      if (customControls.indexOf('flyInOut') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateX: [40, 0],
          translateZ: 0,
          opacity: [0, 1],
          easing: "easeOutExpo",
          duration: speed,
          delay: function delay(el, i) {
            return 500 + 30 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('fading') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          opacity: [0, 1],
          easing: "easeInOutQuad",
          duration: speed,
          delay: function delay(el, i) {
            return 150 * (i + 1);
          }
        });
      } //--------------


      if (customControls.indexOf('floatingUp') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateY: ["1.1em", 0],
          translateZ: 0,
          duration: speed,
          delay: function delay(el, i) {
            return 50 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('scaleIn') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          opacity: [0, 1],
          scale: [3.5, 1],
          duration: speed
        });
      }

      txtEff.pause();

      if (!scrollSpy) {
        txtEff.play();
      } else {
        var viewport = 1; //

        var scrollUpdate = function scrollUpdate() {
          var spyTop = $this[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

          var actived = $this.data('activated');

          if (spyTop < window.innerHeight * viewport) {
            if (_typeof(actived) === ( true ? "undefined" : undefined)) {
              txtEff.play(); //Prevents front-end javascripts that are activated in the background to repeat loading.

              $this.data('activated', 1);
            } //endif actived

          }
        };

        scrollUpdate(); // Please do not use scroll's off method in each

        $(window).on('scroll.UixTextEff touchmove.UixTextEff', function (event) {
          scrollUpdate();
        });
      }
    });
  };
})(jQuery);

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/components/_global/scss/_style.scss
var _style = __webpack_require__(10);

// CONCATENATED MODULE: ./src/components/_global/js/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**

	TABLE OF CONTENTS
	---------------------------


	1.Base
    2.Body And Header
    3.Common Height
    4.Get all custom attributes of an element like "data-*"
    5.Loader
    6.Mega Menu
    7.Mobile Menu
    8.Navigation
    9.Specify a background image
    10.Videos
    11.Theme Scripts
    12.Accordion Background Images
    13.Accordion
    14.Advanced Slider (Basic)
    15.Advanced Slider (Special Effects)
    16.Ajax Push Content
    17.Ajax Page Loader (Loading A Page via Ajax Into Div)
    18.Back to Top
    19.Circle Layout
    20.Counter
    21.Dropdown Menu
    22.Dropdown Menu 2 (Multi-level drop-down navigation)
    23.Dynamic Drop Down List from JSON
    24.Flexslider (Third-party plugin)
    25.Floating Side Element
    26.Form Progress
    27.Form
    28.Gallery
    29.Hybrid Content Slider
    30.Hover Delay Interaction
    31.Image Shapes
    32.Infinite Scrolling Element
    33.Lava-Lamp Style Menu
    34.Custom Lightbox
    35.Bulleted List
    36.Posts List With Ajax
    37.Full Width Column to Edge
    38.Login Templates
    39.Modal Dialog
    40.Mousewheel Interaction
    41.Multiple Items Carousel
    42.Full Page/One Page Transition
    43.Full Page/One Page Transition 2
    44.Parallax
    45.Periodical Scroll
    46.Pricing
    47.Progress Bar
    48.Progress Line
    49.Retina Graphics for Website
    50.Rotating Elements
    51.Scroll Reveal
    52.Scrollspy Animate
    53.Show More Less
    54.Skew Based On Velocity of Scroll
    55.Smooth Scrolling When Clicking An Anchor Link
    56.Smooth Scrolling Page
    57.Sticky Elements
    58.SVG Map (China)
    59.SVG Map (World)
    60.SVG Mask Slider
    61.Swiper
    62.3D Background 1 with three.js
    63.3D Background 2 with three.js
    64.3D Background 3 with three.js
    65.3D Background
    66.3D Carousel
    67.3D Gallery with three.js
    68.3D Image Transition with three.js
    69.3D Model
    70.3D Pages
    71.3D Particle Effect
    72.3D Sphere Rotation
    73.3D Object Anim When Click
    74.3D Mouse Interaction with three.js
    75.3D Mouse Interaction with three.js
    76.3D Shatter Slider
    77.3D Explosive Particle Slider
    78.3D Liquid Scrollspy Slider
    79.3D Filmic Effects
    80.Responsive Table
    81.Table Sorter
    82.Tabs
    83.Team Focus
    84.Text effect
    85.Timeline
    86.Vertical Menu
    87.WordPress Core Scripts


*/

/*
 *************************************
 * <!-- Base -->
 *************************************
 */

/* !!! To build a table of contents (TOC), you need to import this scss file into JS */

/*
 * Global variables from front pages
 *
 * @private
 */

var //If the file is in the root directory, you can leave it empty.
//If in another directory, you can write: "/blog"
templateUrl, //Eg. https://uiux.cc
homeUrl, //Eg. https://uiux.cc/wp-admin/admin-ajax.php
ajaxUrl;

if (typeof APP_ROOTPATH === 'undefined') {
  templateUrl = '';
  homeUrl = '';
  ajaxUrl = '';
} else {
  templateUrl = APP_ROOTPATH.templateUrl.replace(/\/\s*$/, '');
  homeUrl = APP_ROOTPATH.homeUrl.replace(/\/\s*$/, '');
  ajaxUrl = APP_ROOTPATH.ajaxUrl.replace(/\/\s*$/, '');
}
/*
 * Determine whether it is a special browser
 *
 * @private
 */
// Add feature test for passive event listener support


var supportsPassive = false;

try {
  document.addEventListener("test", null, {
    get passive() {
      supportsPassive = true;
    }

  });
} catch (e) {}

var browser = {
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  isAndroid: /(android)/i.test(navigator.userAgent),
  isPC: !navigator.userAgent.match(/(iPhone|iPod|Android|ios|Mobile)/i),
  isSafari: !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/),

  /*Test to 9, 10. */
  isIE: !!window.ActiveXObject || "ActiveXObject" in window,

  /*Test to 6 ~ 11 (not edge) */
  supportsPassive: supportsPassive
};
/*
 * Core scripts for current site
 *
 * @private
 * @description Used for all modules from ./src/components/[__]/js
 * @requires ./examples/assets/js/min/jquery.waitforimages.min.js
 * @requires ./examples/assets/js/min/video.min.js
 * @requires ./examples/assets/js/min/TweenMax.min.js
 */

var UixModuleInstance = function ($, window, document) {
  var _APP = {},
      components = {
    documentReady: [],
    pageLoaded: []
  };

  if ($('img').length == 0) {
    $('body').prepend('<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" style="display:none">');
  }

  if ($.isFunction($.fn.waitForImages)) {
    $('body').waitForImages(pageLoaded);
  } else {
    $(window).on('load', pageLoaded);
  }

  $(document).ready(documentReady);

  function documentReady(context) {
    context = _typeof(context) == ( true ? "undefined" : undefined) ? $ : context;
    components.documentReady.forEach(function (component) {
      component(context);
    });
  }

  function pageLoaded(context) {
    context = _typeof(context) == "object" ? $ : context;
    components.pageLoaded.forEach(function (component) {
      component(context);
    });
  }

  _APP.setContext = function (contextSelector) {
    var context = $;

    if (_typeof(contextSelector) !== ( true ? "undefined" : undefined)) {
      return function (selector) {
        return $(contextSelector).find(selector);
      };
    }

    return context;
  };

  _APP.components = components;
  _APP.documentReady = documentReady;
  _APP.pageLoaded = pageLoaded;
  return _APP;
}($, window, document);
/*
 * Create GUID / UUID
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}                        - The globally-unique identifiers.
 */

var UixGUID = UixGUID || function () {
  function t() {}

  return t.version = "0.0.1", t.create = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }, //
  t;
}();
/*
 * Evaluating a string as a mathematical expression in JavaScript
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}            - New calculation result.
 */

var UixMath = UixMath || function () {
  function t() {}

  return t.version = "0.0.1", t.evaluate = function (s) {
    var chars = s.replace(/\s/g, '').split("");
    var n = [],
        op = [],
        index = 0,
        oplast = true;
    n[index] = ""; // Parse the expression

    for (var c = 0; c < chars.length; c++) {
      if (isNaN(parseInt(chars[c])) && chars[c] !== "." && !oplast) {
        op[index] = chars[c];
        index++;
        n[index] = "";
        oplast = true;
      } else {
        n[index] += chars[c];
        oplast = false;
      }
    } // Calculate the expression


    s = parseFloat(n[0]);

    for (var o = 0; o < op.length; o++) {
      var num = parseFloat(n[o + 1]);

      switch (op[o]) {
        case "+":
          s = s + num;
          break;

        case "-":
          s = s - num;
          break;

        case "*":
          s = s * num;
          break;

        case "/":
          s = s / num;
          break;
      }
    }

    return s;
  }, //
  t;
}();
/*
 * Get the CSS property
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {!Element} el     - The Element for which to get the computed style. Using class name or ID to locate.
 * @return {String|Object}   - The value of property.
 */

var UixCssProperty = UixCssProperty || function () {
  function t() {}

  return t.version = "0.0.1", t.getTransitionDuration = function (el) {
    if (_typeof(el) === ( true ? "undefined" : undefined)) {
      return 0;
    }

    var style = window.getComputedStyle(el),
        duration = style.webkitTransitionDuration,
        delay = style.webkitTransitionDelay;

    if (_typeof(duration) != ( true ? "undefined" : undefined)) {
      // fix miliseconds vs seconds
      duration = duration.indexOf("ms") > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;
      delay = delay.indexOf("ms") > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;
      return duration;
    } else {
      return 0;
    }
  }, //
  t.getAbsoluteCoordinates = function (el) {
    var windowWidth = window.innerWidth,
        leftPos = null,
        topPos = null;

    if (!document.getElementsByTagName('body')[0].className.match(/rtl/)) {
      leftPos = el.offsetLeft == 0 ? el.parentElement.offsetLeft : el.offsetLeft;
      topPos = el.offsetTop == 0 ? el.parentElement.offsetTop : el.offsetTop;
    } else {
      // width and height in pixels, including padding and border
      // Corresponds to jQuery outerWidth(), outerHeight()
      leftPos = el.offsetLeft == 0 ? windowWidth - (el.parentElement.offsetLeft + el.parentElement.offsetWidth) : windowWidth - (el.offsetLeft + el.offsetWidth);
      topPos = el.offsetTop == 0 ? windowWidth - (el.parentElement.offsetTop + el.parentElement.offsetHeight) : windowWidth - (el.offsetTop + el.offsetHeight);
    }

    return {
      'left': leftPos,
      'top': topPos
    };
  }, //
  t;
}();
// CONCATENATED MODULE: ./src/components/_global/js/fn/UixModuleFilter.js
function UixModuleFilter_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { UixModuleFilter_typeof = function _typeof(obj) { return typeof obj; }; } else { UixModuleFilter_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return UixModuleFilter_typeof(obj); }

/*
 * Method of deleting or adding a module
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean|String} destroy       - If it is a string, it means destroying this module from UixModuleInstance
 * @param  {Object} add                     - New module data via JSON.
 * @param  {String} add.moduleName        - The name of the module (the default is all uppercase).
 * @param  {Boolean} add.pageLoaded       - Window loading module method. If true or 1, the module will execute after the page is loaded.
 * @param  {Number} add.version           - The new module version number.
 * @param  {Function} add.callback        - The new module script of function.
 * @return {Void}      
 *
 * @Usage:
 * !!! The code is to be inserted in front of the uix-kit core script.
	
	
<script>
window.MAIN = null;
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixModuleFilter( { 
		   'destroy' : 'MAIN',
		   'add'     : {
							moduleName    : 'YOUR_MODULE_NAME',
							pageLoaded    : true,
							version       : '0.0.1',
							callback      : function() {
								//the module will execute after the page is loaded.

							}
						}
		} );
    } );
} ) ( jQuery );
</script>

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixModuleFilter = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      destroy: false,
      add: {
        moduleName: 'OLD_MODULE_NAME',
        pageLoaded: false,
        version: '0.0.1',
        callback: function callback() {}
      }
    }, options);
    this.each(function () {
      //remove a module
      //-------------------------------------	
      if (settings.destroy && Object.prototype.toString.call(settings.destroy) == '[object String]') {
        var moduleName = settings.destroy;

        if (UixModuleFilter_typeof(UixModuleInstance[moduleName]) != ( true ? "undefined" : undefined)) {
          delete UixModuleInstance[moduleName];
        }
      } //add or replace a module
      //-------------------------------------	


      if (settings.add && Object.prototype.toString.call(settings.add) == '[object Object]' && settings.add.hasOwnProperty('pageLoaded')) {
        var _moduleName2 = settings.add.moduleName; //delete the old module if exist

        if (UixModuleFilter_typeof(UixModuleInstance[_moduleName2]) != ( true ? "undefined" : undefined)) {
          console.log('The module already exists, please destroy the old module or change the new module name.');
        } else {
          //loading mode "documentReady"
          if (!settings.add.pageLoaded || settings.add.pageLoaded == 0) {
            var _moduleName = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;

              module[_moduleName2].documentReady = function ($) {
                settings.add.callback();
              };

              module.components.documentReady.push(module[_moduleName2].documentReady);
              return _moduleName;
            }(UixModuleInstance, jQuery, window, document);

            UixModuleInstance[_moduleName2].documentReady($);
          } //loading mode "pageLoaded"


          if (settings.add.pageLoaded || settings.add.pageLoaded == 1) {
            var _moduleName3 = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;

              module[_moduleName2].pageLoaded = function () {
                settings.add.callback();
              };

              module.components.pageLoaded.push(module[_moduleName2].pageLoaded);
              return _moduleName3;
            }(UixModuleInstance, jQuery, window, document);

            UixModuleInstance[_moduleName2].pageLoaded();
          }
        }
      }
    });
  };
})(jQuery);
// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncScripts.js
/*
 * Apply some asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} scrollReveal          - Run script of module "Scroll Reveal". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxPostList          - Run script of module "Posts List With Ajax". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxDDList            - Run script of module "Dynamic Drop Down List from JSON".
 * @param  {Boolean} counterAnim           - Run script of module "Counter".
 * @return {Void}
 *
 * @Usage:
    
	
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncScripts({
			scrollReveal    : true,
			ajaxPostList    : true,
			ajaxDDList      : true,
			counterAnim     : true,
			lightBox        : true 
		});
    } );
} ) ( jQuery );
</script>

 

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixApplyAsyncScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      scrollReveal: true,
      // @from ./src/components/scroll-reveal
      ajaxPostList: true,
      // @from ./src/components/list-posts
      ajaxDDList: true,
      // @from ./src/components/dynamic-dropdown-list-json
      counterAnim: true,
      // @from ./src/components/counter
      lightBox: true // @from ./src/components/lightbox

    }, options);
    this.each(function () {
      //----
      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.pageLoaded(); //Theme Scripts

      if (UixModuleInstance.COMMON_HEIGHT) UixModuleInstance.COMMON_HEIGHT.pageLoaded(); //Common Height

      if (UixModuleInstance.ADVANCED_SLIDER) UixModuleInstance.ADVANCED_SLIDER.pageLoaded(); //Advanced Slider (Basic)

      if (UixModuleInstance.ADVANCED_SLIDER_FILTER) UixModuleInstance.ADVANCED_SLIDER_FILTER.pageLoaded(); //Advanced Slider

      if (UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE) UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded(); //Full Width Column to Edge

      if (UixModuleInstance.STICKY_EL) UixModuleInstance.STICKY_EL.pageLoaded(); //Sticky Elements

      if (UixModuleInstance.TEXT_EFFECT) UixModuleInstance.TEXT_EFFECT.pageLoaded(); //Text effect

      if (UixModuleInstance.TIMELINE) UixModuleInstance.TIMELINE.pageLoaded(); //Timeline

      if (UixModuleInstance.HYBRID_CONTENT_SLIDER) UixModuleInstance.HYBRID_CONTENT_SLIDER.pageLoaded(); //Hybrid Content Slider
      //----

      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.documentReady($); //Theme Scripts

      if (UixModuleInstance.TABLE) UixModuleInstance.TABLE.documentReady($); //Responsive Table

      if (UixModuleInstance.TABLE_SORTER) UixModuleInstance.TABLE_SORTER.documentReady($); //Table Sorter

      if (UixModuleInstance.MODAL_DIALOG) UixModuleInstance.MODAL_DIALOG.documentReady($); //Modal Dialog

      if (UixModuleInstance.PARALLAX) UixModuleInstance.PARALLAX.documentReady($); //Parallax

      if (UixModuleInstance.VIDEOS) UixModuleInstance.VIDEOS.documentReady($); //Videos

      if (UixModuleInstance.BODY_AND_HEADER) UixModuleInstance.BODY_AND_HEADER.documentReady($); //Header Area

      if (UixModuleInstance.SET_BG) UixModuleInstance.SET_BG.documentReady($); //Specify a background image

      if (UixModuleInstance.GET_CUSTOM_ATTRS) UixModuleInstance.GET_CUSTOM_ATTRS.documentReady($); //Get all custom attributes of an element like "data-*"

      if (UixModuleInstance.PAGINATION) UixModuleInstance.PAGINATION.documentReady($); //Pagination

      if (UixModuleInstance.FORM) UixModuleInstance.FORM.documentReady($); //Form

      if (UixModuleInstance.FLEXSLIDER) UixModuleInstance.FLEXSLIDER.documentReady($); //Flexslider (Third-party plugin)

      if (UixModuleInstance.RETINA) UixModuleInstance.RETINA.documentReady($); //Retina Graphics for Website

      if (UixModuleInstance.SHOW_MORELESS) UixModuleInstance.SHOW_MORELESS.documentReady($); //Show More Less

      if (UixModuleInstance.DROPDOWN_MENU) UixModuleInstance.DROPDOWN_MENU.documentReady($); //Dropdown Menu

      if (UixModuleInstance.DROPDOWN_MENU2) UixModuleInstance.DROPDOWN_MENU2.documentReady($); //Dropdown Menu2

      if (UixModuleInstance.ACCORDION) UixModuleInstance.ACCORDION.documentReady($); //Accordion

      if (UixModuleInstance.GALLERY) UixModuleInstance.GALLERY.documentReady($); //Gallery

      if (UixModuleInstance.IMAGE_SHAPES) UixModuleInstance.IMAGE_SHAPES.documentReady($); //Image Shapes

      if (UixModuleInstance.PERIODICAL_SCROLL) UixModuleInstance.PERIODICAL_SCROLL.documentReady($); //Periodical Scroll

      if (UixModuleInstance.PRICING) UixModuleInstance.PRICING.documentReady($); //Pricing

      if (UixModuleInstance.PROGRESS_BAR) UixModuleInstance.PROGRESS_BAR.documentReady($); //Progress Bar

      if (UixModuleInstance.PROGRESS_LINE) UixModuleInstance.PROGRESS_LINE.documentReady($); //Progress Line

      if (UixModuleInstance.ROTATING_EL) UixModuleInstance.ROTATING_EL.documentReady($); //Rotating Elements

      if (UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK) UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK.documentReady($); //Smooth Scrolling When Clicking An Anchor Link

      if (UixModuleInstance.SWIPER) UixModuleInstance.SWIPER.documentReady($); //SWIPER (Third-party plugin)

      if (UixModuleInstance.TABS) UixModuleInstance.TABS.documentReady($); //Tabs

      if (UixModuleInstance.TEAM_FOCUS) UixModuleInstance.TEAM_FOCUS.documentReady($); //Team Focus

      if (UixModuleInstance.LAVA_LAMP_STYLE_MENU) UixModuleInstance.LAVA_LAMP_STYLE_MENU.documentReady($); //Lava-Lamp Style Menu

      if (UixModuleInstance.CIRCLE_LAYOUT) UixModuleInstance.CIRCLE_LAYOUT.documentReady($); //Circle Layout

      if (UixModuleInstance.MULTI_ITEMS_CAROUSEL) UixModuleInstance.MULTI_ITEMS_CAROUSEL.documentReady($); //Multiple Items Carousel

      if (UixModuleInstance.THREE_BACKGROUND) UixModuleInstance.THREE_BACKGROUND.documentReady($); //3D Background

      if (UixModuleInstance.THREE_CAROUSEL) UixModuleInstance.THREE_CAROUSEL.documentReady($); //3D Carousel

      if (UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER) UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady($); //3D Liquid Scrollspy Slider
      //---- Prevent overlay clicks on asynchronous requests
      //---- Commonly used for AJAX modules that are clicked by button
      //Scroll Reveal

      if (settings.scrollReveal) {
        if (UixModuleInstance.SCROLL_REVEAL) UixModuleInstance.SCROLL_REVEAL.documentReady($);
      } //Posts List With Ajax


      if (settings.ajaxPostList) {
        if (UixModuleInstance.POST_LIST_AJAX) UixModuleInstance.POST_LIST_AJAX.documentReady($);
      } //Dynamic Drop Down List from JSON


      if (settings.ajaxDDList) {
        if (UixModuleInstance.DYNAMIC_DD_LIST) UixModuleInstance.DYNAMIC_DD_LIST.documentReady($);
      } //Counter


      if (settings.counterAnim) {
        if (UixModuleInstance.COUNTER) UixModuleInstance.COUNTER.documentReady($);
      } //Custom Lightbox


      if (settings.lightBox) {
        if (UixModuleInstance.LIGHTBOX) UixModuleInstance.LIGHTBOX.pageLoaded();
      } //----Uix Shortcodes (WordPress Plugin)


      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncAllScripts.js
/*
 * Apply all the asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} runAll          - Run all module scripts.
 * @return {Void}
 *
 * @Usage:
    
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncAllScripts();
    } );
} ) ( jQuery );
</script>
	

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixApplyAsyncAllScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      runAll: true
    }, options);
    this.each(function () {
      var scipts_pageLoaded = UixModuleInstance.components.pageLoaded,
          scipts_documentReady = UixModuleInstance.components.documentReady;

      if (settings.runAll) {
        for (var i = 0; i < scipts_pageLoaded.length; i++) {
          scipts_pageLoaded[i]();
        }

        for (var j = 0; j < scipts_documentReady.length; j++) {
          scipts_documentReady[j]($);
        }
      } //Uix Shortcodes


      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
// CONCATENATED MODULE: ./src/components/_global/js/modules/body-and-header.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Body And Header -->
 *************************************
 */

var BODY_AND_HEADER = function (module, $, window, document) {
  if (window.BODY_AND_HEADER === null) return false;
  module.BODY_AND_HEADER = module.BODY_AND_HEADER || {};
  module.BODY_AND_HEADER.version = '0.0.7';

  module.BODY_AND_HEADER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Header initialize

    headerInit(windowWidth);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        headerInit(windowWidth);
      }
    });

    function headerInit(w) {
      var $headerPlaceholder = $('.uix-header__placeholder.js-uix-header__placeholder-autoheight');

      if (w > 768) {
        $headerPlaceholder.css('height', $('.uix-header__container').outerHeight(true) + 'px');
        $('body').removeClass('is-mobile');
      } else {
        $headerPlaceholder.css('height', 0);
        $('body').addClass('is-mobile');
      }
    } //-------- Sticky header area
    //Note: Don't use Waypoint, because the Offset is wrong on calculating height of fixed element


    var $el = $('.uix-header__container, .uix-header__placeholder');
    $window.off('scroll.BODY_AND_HEADER touchmove.BODY_AND_HEADER').on('scroll.BODY_AND_HEADER touchmove.BODY_AND_HEADER', function () {
      var scrolled = $(this).scrollTop(),
          spyTop = 220;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    });
  };

  module.components.documentReady.push(module.BODY_AND_HEADER.documentReady);
  return function BODY_AND_HEADER() {
    _classCallCheck(this, BODY_AND_HEADER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/common-height.js
function common_height_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Common Height -->
 
 *
 * Note: 
 *
 * Automatically sets the div height of the grid system to the height of the 
 * outer container when ".js-uix-common-height" class on ".row" or ".uix-core-grid__row" div.
 *
 *************************************
 */

var COMMON_HEIGHT = function (module, $, window, document) {
  if (window.COMMON_HEIGHT === null) return false;
  module.COMMON_HEIGHT = module.COMMON_HEIGHT || {};
  module.COMMON_HEIGHT.version = '0.0.3';

  module.COMMON_HEIGHT.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    commonHeightInit(windowWidth);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        commonHeightInit(windowWidth);
      }
    });

    function commonHeightInit(w) {
      $('.js-uix-common-height').each(function () {
        var $this = $(this);
        var element = $this;
        var selectors = '[class*=col-], [class*=uix-core-grid__col-]'; //Bootstrap grid system and Custom uix grid system

        var maxHeight = 0; // Select and loop the elements you want to equalise

        element.children(selectors).each(function () {
          var element = $(this); //Solve the problem that the image cannot be read accurately

          element.find('img').each(function () {
            var imgOuter = $(this).parent('a').css('display');

            if (imgOuter == 'inline') {
              $(this).parent('a').css('display', 'inline-block');
            }
          });

          if (element.hasClass('max-height')) {
            // if has max-height
            maxHeight = element.outerHeight();
          } else {
            // if this box is higher than the cached highest then store it
            if (element.height() > maxHeight) {
              maxHeight = element.outerHeight();
            }
          }
        }); // Set the height of all those children to whichever was highest 

        if (w > 768) {
          element.children(selectors).each(function () {
            $(this).css('height', maxHeight);
          });
        } else {
          element.children(selectors).each(function () {
            $(this).css('height', 'auto');
          });
        }
      });
    }
  };

  module.components.pageLoaded.push(module.COMMON_HEIGHT.pageLoaded);
  return function COMMON_HEIGHT() {
    common_height_classCallCheck(this, COMMON_HEIGHT);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/third-party-plugins/esm/Miscellaneous/attrExt.js
var attrExt = __webpack_require__(4);

// CONCATENATED MODULE: ./src/components/_global/js/modules/custom-data-attrs.js
function custom_data_attrs_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Get all custom attributes of an element like "data-*" -->
 *************************************
 */


var GET_CUSTOM_ATTRS = function (module, $, window, document) {
  if (window.GET_CUSTOM_ATTRS === null) return false;
  module.GET_CUSTOM_ATTRS = module.GET_CUSTOM_ATTRS || {};
  module.GET_CUSTOM_ATTRS.version = '0.0.1';

  module.GET_CUSTOM_ATTRS.documentReady = function ($) {
    $('[data-my-custom-datas]').each(function () {
      var $this = $(this); //Get all attributes of an element and push the new attributes like "data-*"

      var curAttrs = $this.attr(),
          customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-custom-field-') >= 0) {
          customPostData += '"' + i.replace('data-custom-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, '');
    });
  };

  module.components.documentReady.push(module.GET_CUSTOM_ATTRS.documentReady);
  return function GET_CUSTOM_ATTRS() {
    custom_data_attrs_classCallCheck(this, GET_CUSTOM_ATTRS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/loader.js
function loader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function loader_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { loader_typeof = function _typeof(obj) { return typeof obj; }; } else { loader_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return loader_typeof(obj); }

/* 
 *************************************
 * <!-- Loader -->
 *************************************
 */

var LOADER = function (module, $, window, document) {
  if (window.LOADER === null) return false;
  module.LOADER = module.LOADER || {};
  module.LOADER.version = '0.0.5';

  module.LOADER.documentReady = function ($) {
    // Disable devices scaling
    //-------------------------------------	
    document.addEventListener('touchstart', function (event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    });
    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      var now = new Date().getTime();

      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }

      lastTouchEnd = now;
    }, false); // Loader Process
    //-------------------------------------	
    // Detect if video.load is successful or not 

    var videos = [];
    var videosTotal = 0;
    var videosLoaded = 0;
    $('.uix-video__slider > video').each(function () {
      videos.push($(this));
    });
    videosTotal = videos.length;
    console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded); // Loading progress event

    var loadedPercent = 0;
    var imgTotal = 0;

    var loadingAnim = function loadingAnim(per) {
      $('.uix-loader-progress > span').text($('.uix-loader-progress').data('txt').replace(/\{progress\}/g, per));
      TweenMax.to('.uix-loader-progress__line', 0.3, {
        width: per / 100.0 * window.innerWidth
      });
    };

    $('body').waitForImages().progress(function (loaded, count, success) {
      imgTotal = count;
      var per = parseInt(loaded / (count - (1 - videosTotal)) * 100); //

      if ($('img').length <= 1) {
        per = 100;
      } //


      if (isNaN(per)) per = 100; //

      loadedPercent = per; //animation classes for loader

      for (var i = 1; i < 10; i++) {
        if (per < i * 10) $('body').addClass('loaded' + i);
      } //loading animation


      loadingAnim(per);
    }).done(function () {
      //Event after loading is complete
      // Main scene
      console.log('loadedPercent: ' + loadedPercent + ', imageTotal: ' + imgTotal);
      mainObjLoader(loadedPercent, imgTotal);
    });
    /*
     * Main Object Loader
     *
     * @param  {Number} loadedPercent  - The percentage value after the page loads the image.
     * @param  {Number} imgTotal       - The total number of imags.
     * @return {Void}
     */

    function mainObjLoader(loadedPercent, imgTotal) {
      var remainedPercentComplete = 0;

      var loadedFun = function loadedFun() {
        //loading animation
        loadingAnim(100); //animation classes for loader

        $('body').addClass('loaded10'); // Remove loader

        TweenMax.to('.uix-loader, .uix-loader-progress, .uix-loader-progress__line', 0.5, {
          css: {
            opacity: 0,
            display: 'none'
          }
        }); //page animation when elements loaded
        //...
      }; //


      if (loadedPercent < 100) {
        videos.forEach(function (element) {
          var _src = element.find('source:first').attr('src');

          if (loader_typeof(_src) === ( true ? "undefined" : undefined)) _src = element.attr('src');
          var video = document.getElementById(element.attr('id')),
              videoURL = _src;
          video.addEventListener('loadedmetadata', function (e) {
            //Video has started loading successfully
            videosLoaded++; //get remained percent

            remainedPercentComplete = (1 - videosLoaded / videosTotal) * (100 - loadedPercent); //current percent

            var currentPercent = loadedPercent + (100 - loadedPercent - remainedPercentComplete); //loading animation

            loadingAnim(currentPercent); // All videos loaded

            if (currentPercent == 100) {
              loadedFun();
            } //debug


            console.log('remainedPercentComplete: ' + remainedPercentComplete + ', currentPercent: ' + currentPercent);
            console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded);
          }, false);
          video.src = videoURL;
        });
      } else {
        // All videos loaded
        if (remainedPercentComplete == 0) {
          loadedFun();
        }
      }
    }
  };

  module.components.documentReady.push(module.LOADER.documentReady);
  return function LOADER() {
    loader_classCallCheck(this, LOADER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/mega-menu.js
function mega_menu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Mega Menu -->
 *************************************
 */

var MEGA_MENU = function (module, $, window, document) {
  if (window.MEGA_MENU === null) return false;
  module.MEGA_MENU = module.MEGA_MENU || {};
  module.MEGA_MENU.version = '0.0.3';

  module.MEGA_MENU.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; // Using delay is for more accurate calculation

    setTimeout(function () {
      megaMenuInit(windowWidth);
    }, 500);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        megaMenuInit(windowWidth);
      }
    }); // Initialize mega menu

    function megaMenuInit(w) {
      var $menuWrap = $('.uix-menu__container:not(.is-mobile)'),
          maxWidth = 1140,
          //The maximum width of the mega menu wrapper
      //This value is equal to the $nav-mega-li-w variable in the SCSS
      perDefaultW = 270; //Default width of each column
      //New XL container for Bootstrap 4.x

      if (w > 1430) maxWidth = 1278; //Full width container

      maxWidth = windowWidth - 15; // Remove the html tag for mega menu item

      $menuWrap.find('li.multi-column  > ul .multi-column-title').each(function () {
        var mega_old_item = $(this).html();

        if (mega_old_item != '') {
          $(this).html(mega_old_item.replace(/<[^>]+>/g, ''));
        }
      });

      if (w > 768) {
        $menuWrap.find('li.multi-column').each(function (index) {
          var root_li = $(this),
              col_total = root_li.find('> ul > li').length,
              mega_div = root_li.find(' > ul.sub-menu'),
              mega_div_w = mega_div.width(),
              mega_single_w = null,
              root_li_left = null; // Add mega arrow

          if (root_li.find('.uix-menu__arrow-mega').length < 1) root_li.prepend('<span class="uix-menu__arrow-mega"></span>'); // Detecting if the right or left of the div is touching the browser window edge.

          if (col_total > 0) {
            root_li_left = UixCssProperty.getAbsoluteCoordinates(mega_div[0]).left; //Determine the mega menu wrapper within document width, in order to limit the width of each column for mega menu

            if (maxWidth > w) maxWidth = w;

            if (parseFloat(mega_div_w + 20) > maxWidth) {
              mega_div_w = maxWidth;
              mega_single_w = maxWidth / col_total - 2.888; //Resetting the width of each column

              mega_div.find('> li').css({
                'width': mega_single_w + 'px'
              }); //Resetting the width of each <li> tag

              mega_div.find('> li ul li').css({
                'width': mega_single_w + 'px'
              });

              if (!$('body').hasClass('rtl')) {
                mega_div.css({
                  'margin-left': -root_li_left + (w - mega_div_w) / 2 + 'px'
                });
              } else {
                mega_div.css({
                  'margin-right': -root_li_left + (w - mega_div_w) / 2 + 'px'
                });
              }
            } else {
              //Resetting the width of each column
              mega_div.find('> li').css({
                'width': perDefaultW + 'px'
              }); //Resetting the width of each <li> tag

              mega_div.find('> li ul li').css({
                'width': perDefaultW + 'px'
              });
              var chkWidth = parseFloat(root_li_left + mega_div_w);

              if (chkWidth > w) {
                if (!$('body').hasClass('rtl')) {
                  mega_div.css({
                    'margin-left': -(chkWidth - w) + 'px'
                  });
                } else {
                  mega_div.css({
                    'margin-right': -(chkWidth - w) + 'px'
                  });
                } //If the CSS sets the offset of ul::before
                //								const mega_div_offset = mega_div_w/2 - 0;
                //								
                //								if ( ! $( 'body' ).hasClass( 'rtl' ) ) {
                //									mega_div.css( {
                //										'margin-left' : - ( chkWidth - w ) + mega_div_offset + 'px'
                //									} );
                //								} else {
                //									mega_div.css( {
                //										'margin-right' : - ( chkWidth - w ) + mega_div_offset + 'px'
                //									} );
                //								}	

              }
            }
          }
        });
      }
    }
  };

  module.components.pageLoaded.push(module.MEGA_MENU.pageLoaded);
  return function MEGA_MENU() {
    mega_menu_classCallCheck(this, MEGA_MENU);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/mobile-menu.js
function mobile_menu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function mobile_menu_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { mobile_menu_typeof = function _typeof(obj) { return typeof obj; }; } else { mobile_menu_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return mobile_menu_typeof(obj); }

/* 
 *************************************
 * <!-- Mobile Menu -->
 *************************************
 */

var MOBILE_MENU = function (module, $, window, document) {
  if (window.MOBILE_MENU === null) return false;
  module.MOBILE_MENU = module.MOBILE_MENU || {};
  module.MOBILE_MENU.version = '0.0.8';

  module.MOBILE_MENU.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Show Toolbar when viewing site for WordPress
    //Note: Don't use Waypoint, because the Offset is wrong on calculating height of fixed element

    var $el = $('.admin-bar .uix-menu-mobile__toggle');
    $window.off('scroll.MOBILE_MENU touchmove.MOBILE_MENU').on('scroll.MOBILE_MENU touchmove.MOBILE_MENU', function () {
      var scrolled = $(this).scrollTop(),
          spyTop = 46;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    }); //-------- Mobile Menu

    var $toggle = $('.uix-menu-mobile__toggle'),
        $toggleBody = $('body'); //-------- Add mobile menu to your website

    $('nav.uix-menu__container').clone().addClass('is-mobile').appendTo('body'); //Wait until previous .appendTo() is complete

    $.when($('.uix-menu__container.is-mobile').length > 0).then(function () {
      $toggle.on('touchstart click', function (e) {
        e.preventDefault(); //Prevents further propagation of the current event in the capturing and bubbling phases.

        e.stopPropagation();
        $(this).toggleClass('is-opened');

        if ($(this).hasClass('is-opened')) {
          //Add mobile brand
          var logoURL = $('.uix-brand--mobile img').attr('src');

          if (mobile_menu_typeof(logoURL) !== ( true ? "undefined" : undefined) && logoURL != '') {
            if (logoURL.indexOf('blank.gif') >= 0) $('.mobile-inner').css('margin-top', '-70px');
          } //Toggle effect


          $toggleBody.addClass('js-uix-menu-opened');
        } else {
          $toggleBody.removeClass('js-uix-menu-opened');
        }
      }); //Mobile menu mask event

      $('.uix-menu-mobile__mask').on('click', function () {
        $toggle.removeClass('is-opened');
        $toggleBody.removeClass('js-uix-menu-opened');
      }); // Fires drop-menu event 

      var $drMenuLi = $('.uix-menu__container.is-mobile ul li');
      $drMenuLi.find('> a').on('click', function (e) {
        var arrowText = $(this).find('.uix-menu__arrow-mobile').text().replace(/(.).*\1/g, "$1"),
            $sub = $(this).next('ul');

        if ($sub.length > 0) {
          e.preventDefault(); //Its value is not a boolean but a string

          var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

          if (expanded) {
            //Hide other all sibling <ul> of the selected element
            var $e = $(this).parent('li').siblings().find('> a');
            $e.removeClass('is-opened').attr('aria-expanded', false);
            $e.parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $e.parent('li').removeClass('is-opened');
            $(this).addClass('is-opened').attr('aria-expanded', true);
            $(this).parent('li').find('.uix-menu__arrow-mobile').addClass('is-opened');
            $(this).parent('li').addClass('is-opened');
            TweenMax.to($e.next('ul'), 0.5, {
              height: 0
            }); //to open
            // - temporarilty set height:auto
            // - tween from height:0

            TweenMax.set($sub, {
              height: 'auto'
            });
            TweenMax.from($sub, 0.5, {
              height: 0
            });
          } else {
            $(this).removeClass('is-opened').attr('aria-expanded', false);
            $(this).parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $(this).parent('li').removeClass('is-opened'); //to close

            TweenMax.to($sub, 0.5, {
              height: 0
            });
          }

          return false;
        }
      });
      mobileMenuInit(windowWidth); // Close the menu on window change

      $window.on('resize', function () {
        // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
        if (window.innerWidth != windowWidth) {
          // Update the window width for next time
          windowWidth = window.innerWidth; // Do stuff here

          $toggleBody.removeClass('js-uix-menu-opened');
          $toggle.removeClass('is-opened');
          mobileMenuInit(windowWidth);
        }
      });
    });
    /*
     * Initialize mobile menu
     *
     * @param  {Number} w                  - Returns width of browser viewport.
     * @return {Void}
     */

    function mobileMenuInit(w) {
      if (w <= 768) {
        $('.uix-menu__container.is-mobile .uix-menu > li').each(function () {
          if ($(this).find('ul').length > 0) {
            if ($(this).find('.uix-menu__arrow-mobile').length < 1) $(this).prepend('<em class="uix-menu__arrow-mobile"></em>');
            $(this).find('ul ul').addClass('sub-sub');
            $(this).find(' > a').attr('href', 'javascript:void(0);');
          }
        });
      }
    }
  };

  module.components.documentReady.push(module.MOBILE_MENU.documentReady);
  return function MOBILE_MENU() {
    mobile_menu_classCallCheck(this, MOBILE_MENU);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/navigation.js
function navigation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function navigation_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { navigation_typeof = function _typeof(obj) { return typeof obj; }; } else { navigation_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return navigation_typeof(obj); }

/* 
 *************************************
 * <!-- Navigation -->
 *************************************
 */

var NAVIGATION = function (module, $, window, document) {
  if (window.NAVIGATION === null) return false;
  module.NAVIGATION = module.NAVIGATION || {};
  module.NAVIGATION.version = '0.0.9';

  module.NAVIGATION.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var ulForDesktop = '.uix-menu__container:not(.is-mobile) ul.uix-menu'; //-------- Menu selected (if it exists "data-current" property in <ul>)

    var curMenuIndex = $(ulForDesktop).data('current');

    if (navigation_typeof(curMenuIndex) !== ( true ? "undefined" : undefined)) {
      $(ulForDesktop + ' > li:eq(' + curMenuIndex + ')').addClass('is-active');
    } //-------- Menu Hover


    var mTop = 15;
    $(ulForDesktop + ' > li.multi-column > ul li ul').addClass('multi');
    $(ulForDesktop + ' > li:not(.multi-column) ul, .uix-menu__container:not(.is-mobile) li.multi-column > ul.sub-menu > li > ul, ' + ulForDesktop + ' li.multi-column > ul').css('margin-top', mTop + 'px');
    $(ulForDesktop + ' li').on('mouseenter', function () {
      TweenMax.set($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), {
        css: {
          opacity: 0,
          display: 'block',
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.3, {
            css: {
              opacity: 1,
              marginTop: 0
            },
            ease: Power2.easeOut
          });
        }
      });
    }).on('mouseleave', function () {
      TweenMax.to($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), 0.3, {
        css: {
          opacity: 0,
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              display: 'none'
            }
          });
        }
      });
    }); //-------- Add Sub-menu Arrow

    $(ulForDesktop + ' li').each(function () {
      if ($(this).find('ul').length > 0) {
        $(this).prepend('<span class="uix-menu__arrow"></span>');
      }
    }); //-------- Sticky primary navigation
    //Note: Don't use Waypoint, because the Offset is wrong on calculating height of fixed element

    var $el = $('.uix-menu__container:not(.is-mobile)');
    $window.off('scroll.NAVIGATION touchmove.NAVIGATION').on('scroll.NAVIGATION touchmove.NAVIGATION', function () {
      var scrolled = $(this).scrollTop(),
          spyTop = 220;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    });
  };

  module.components.documentReady.push(module.NAVIGATION.documentReady);
  return function NAVIGATION() {
    navigation_classCallCheck(this, NAVIGATION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_global/js/fn/UixParallax.js
var UixParallax = __webpack_require__(5);

// CONCATENATED MODULE: ./src/components/_global/js/modules/set-background.js
function set_background_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function set_background_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { set_background_typeof = function _typeof(obj) { return typeof obj; }; } else { set_background_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return set_background_typeof(obj); }

/* 
 *************************************
 * <!-- Specify a background image -->
 *************************************
 */


var SET_BG = function (module, $, window, document) {
  if (window.SET_BG === null) return false;
  module.SET_BG = module.SET_BG || {};
  module.SET_BG.version = '0.0.7';

  module.SET_BG.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    setBGInit(windowWidth, windowHeight);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight; // Do stuff here

        setBGInit(windowWidth, windowHeight);
      }
    });
    /*
     * Initialize background using "data-bg" attribute.
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function setBGInit(w, h) {
      $('[data-bg]').each(function () {
        var $this = $(this);
        var config = $this.data('bg');

        if (set_background_typeof(config) === ( true ? "undefined" : undefined)) {
          config = {
            "src": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
            "position": "top left",
            "size": "cover",
            "repeat": "no-repeat",
            "offsetTop": 0,
            "fill": false,
            "parallax": 0,
            "transition": "none 0s ease 0s",
            "move": false // {"dir":"left","duration":"10s","easing":"linear","loop":true}

          };
        }

        if (config) {
          var dataImg = config.src,
              dataPos = config.position,
              dataSize = config.size,
              dataRepeat = config.repeat,
              dataEasing = config.transition,
              dataOffsetTop = config.offsetTop,
              dataParallax = config.parallax,
              dataMove = config.move;
          if (set_background_typeof(dataPos) === ( true ? "undefined" : undefined)) dataPos = 'top left';
          if (set_background_typeof(dataSize) === ( true ? "undefined" : undefined)) dataSize = 'cover';
          if (set_background_typeof(dataRepeat) === ( true ? "undefined" : undefined)) dataRepeat = 'no-repeat';
          if (set_background_typeof(dataOffsetTop) === ( true ? "undefined" : undefined)) dataOffsetTop = 0;
          if (set_background_typeof(dataEasing) === ( true ? "undefined" : undefined)) dataEasing = 'none 0s ease 0s';
          if (set_background_typeof(dataMove) === ( true ? "undefined" : undefined)) dataMove = false; //Using parallax

          if (dataParallax && set_background_typeof(dataParallax) != ( true ? "undefined" : undefined) && dataParallax != 0) {
            dataPos = dataPos.replace('top', '50%');
          } //background animation


          var moveAnim = 'none',
              moveAnimLoop = 'infinite',
              moveEasing = 'linear',
              moveKeyframesTop = '@keyframes js-uix-cssanim--move-t{from{background-position:0 0;}to{background-position:0 -19999px;}',
              moveKeyframesBottom = '@keyframes js-uix-cssanim--move-b{from{background-position:0 0;}to{background-position:0 19999px;}',
              moveKeyframesLeft = '@keyframes js-uix-cssanim--move-l{from{background-position:0 0;}to{background-position:-19999px 0;}',
              moveKeyframesRight = '@keyframes js-uix-cssanim--move-r{from{background-position:0 0;}to{background-position:19999px 0;}';

          if (dataMove && Object.prototype.toString.call(dataMove) == '[object Object]') {
            if (!dataMove.loop) moveAnimLoop = '1 forwards';
            dataPos = '0 0';

            switch (dataMove.dir) {
              case 'top':
                moveAnim = 'js-uix-cssanim--move-t ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'bottom':
                moveAnim = 'js-uix-cssanim--move-b ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'left':
                moveAnim = 'js-uix-cssanim--move-l ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'right':
                moveAnim = 'js-uix-cssanim--move-r ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
            } //  CSS3 animation keyframe attributes inline


            if ($('#js-uix-cssanim--move-t').length == 0) {
              $('<style id="js-uix-cssanim--move-t">').text(moveKeyframesTop).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-b').length == 0) {
              $('<style id="js-uix-cssanim--move-b">').text(moveKeyframesBottom).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-l').length == 0) {
              $('<style id="js-uix-cssanim--move-l">').text(moveKeyframesLeft).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-r').length == 0) {
              $('<style id="js-uix-cssanim--move-r">').text(moveKeyframesRight).appendTo('head');
            }
          } //-----


          if (set_background_typeof(dataImg) != ( true ? "undefined" : undefined) && dataImg != '') {
            if (config.fill) {
              //Show Image Under Text
              if (Modernizr.cssanimations) {
                $this.css({
                  'background': 'url(' + dataImg + ') ' + dataRepeat + '',
                  'background-size': dataSize,
                  '-webkit-background-clip': 'text',
                  '-webkit-text-fill-color': 'transparent',
                  'animation': moveAnim
                });
              }
            } else {
              $this.css({
                'background-image': 'url(' + dataImg + ')',
                'background-position': dataPos,
                'background-size': dataSize,
                'background-repeat': dataRepeat,
                'animation': moveAnim
              });
            } //Using parallax


            if (dataParallax && set_background_typeof(dataParallax) != ( true ? "undefined" : undefined) && dataParallax != 0) {
              $this.UixParallax({
                'speed': dataParallax,
                'transition': dataEasing,
                'offsetTop': dataOffsetTop,
                'bg': {
                  enable: true,
                  xPos: '50%'
                }
              });
            }
          }
        }
      });
    }
  };

  module.components.documentReady.push(module.SET_BG.documentReady);
  return function SET_BG() {
    set_background_classCallCheck(this, SET_BG);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/_global/js/modules/videos.js
function videos_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function videos_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { videos_typeof = function _typeof(obj) { return typeof obj; }; } else { videos_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return videos_typeof(obj); }

/* 
 *************************************
 * <!-- Videos -->
 *************************************
 */

var VIDEOS = function (module, $, window, document) {
  if (window.VIDEOS === null) return false;
  module.VIDEOS = module.VIDEOS || {};
  module.VIDEOS.version = '0.1.3';

  module.VIDEOS.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /* 
     ---------------------------
     Video Embed
     ---------------------------
     */

    $('.uix-video').each(function () {
      var $this = $(this);
      var curVideoID = $this.find('video').attr('id'),
          coverPlayBtnID = 'videocover-' + curVideoID,
          videoWrapperW = $this.closest('[data-embed-video-wrapper]').width();
      var dataAuto = $this.data('embed-video-autoplay'),
          dataLoop = $this.data('embed-video-loop'),
          dataControls = $this.data('embed-video-controls'),
          dataW = $this.data('embed-video-width'),
          dataH = $this.data('embed-video-height'); //Push a new ID to video
      //Solve the problem that ajax asynchronous loading does not play

      $this.find('.video-js').attr('id', curVideoID);

      if (videos_typeof(dataAuto) === ( true ? "undefined" : undefined)) {
        dataAuto = true;
      }

      if (videos_typeof(dataLoop) === ( true ? "undefined" : undefined)) {
        dataLoop = true;
      }

      if (videos_typeof(dataControls) === ( true ? "undefined" : undefined)) {
        dataControls = false;
      }

      if (videos_typeof(dataW) === ( true ? "undefined" : undefined) || dataW == 'auto') {
        dataW = videoWrapperW;
      }

      if (videos_typeof(dataH) === ( true ? "undefined" : undefined) || dataH == 'auto') {
        dataH = videoWrapperW / 1.77777777777778;
      } //Display cover and play buttons when some mobile device browsers cannot automatically play video


      if ($('#' + coverPlayBtnID).length == 0) {
        $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
        var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
        $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
          e.preventDefault();
          myPlayer.play();
          $('#' + coverPlayBtnID).hide();
        }); //Prevent some devices from automatically playing video and trigger with buttons

        if (!dataAuto || browser.isAndroid) {
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
        }
      }
      /* ---------  HTML5 video autoplay on mobile revisited  */


      if (windowWidth <= 768) {
        $this.find('.video-js').attr({
          'playsinline': 'true'
        });
      }

      var myPlayer = videojs(curVideoID, {
        width: dataW,
        height: dataH,
        loop: dataLoop,
        autoplay: dataAuto
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH;
          newW = videoWrapperW; //Scaled/Proportional Content 

          newH = curH * (newW / curW);

          if (!isNaN(newW) && !isNaN(newH)) {
            obj.height(newH);
            obj.width(newW);
          } //Show this video wrapper


          $this.css('visibility', 'visible'); //Hide loading effect

          $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
        };

        initVideo(this);
        /* ---------  Video initialize */

        this.on('loadedmetadata', function () {
          initVideo(this);
        });
        /* ---------  Set, tell the player it's in fullscreen  */

        if (dataAuto) {
          this.muted(true); //Fix an error of Video auto play is not working in browser

          this.play();
        }
        /* ---------  Disable control bar play button click */


        if (!dataControls) {
          this.controls(false);
        }
        /* ---------  Determine if the video is auto played from mobile devices  */


        var autoPlayOK = false;
        this.on('timeupdate', function () {
          var duration = this.duration();

          if (duration > 0) {
            autoPlayOK = true;

            if (this.currentTime() > 0) {
              autoPlayOK = true;
              this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

              $('#' + coverPlayBtnID).hide();
            }
          }
        });
      });
    });
    /* 
     ---------------------------
     Video Popup Interaction
     ---------------------------
     */

    var modalDialogTrigger = '[data-video-win]'; //Add video container

    $(modalDialogTrigger).each(function () {
      var $this = $(this);
      var videoSrcIfm = '',
          videoSrcMp4 = $this.data('video-mp4'),
          videoSrcWebm = $this.data('video-webm'),
          videoSrcOgv = $this.data('video-ogv'),
          videoPoster = $this.data('video-poster'),
          videoContainerMid = $this.data('modal-id'),
          videoContainerVid = videoContainerMid + '--videopush';

      if (videos_typeof(videoSrcMp4) === ( true ? "undefined" : undefined)) {
        videoSrcMp4 = '';
      }

      if (videos_typeof(videoSrcWebm) === ( true ? "undefined" : undefined)) {
        videoSrcWebm = '';
      }

      if (videos_typeof(videoSrcOgv) === ( true ? "undefined" : undefined)) {
        videoSrcOgv = '';
      }

      if ($this.find('[data-video-iframe]').length > 0) {
        videoSrcIfm = $this.find('[data-video-iframe]').html();
      } //Add modal dialog


      if ($('#' + videoContainerMid).length == 0) {
        var v = '',
            vmp4 = '',
            vwebm = '',
            vogv = '';

        if (videoSrcMp4 != '') {
          vmp4 = '<source src="' + videoSrcMp4 + '" type="video/mp4">';
        }

        if (videoSrcWebm != '') {
          vwebm = '<source src="' + videoSrcWebm + '" type="video/webm">';
        }

        if (videoSrcOgv != '') {
          vogv = '<source src="' + videoSrcOgv + '" type="video/ogv">';
        }

        v += '<div class="uix-modal-box is-fullscreen is-video" role="dialog" tabindex="-1" aria-hidden="true" id="' + videoContainerMid + '">';
        v += '<button type="button" class="uix-modal-box__close" data-modal-close-trigger="true"></button>';
        v += '<div class="uix-modal-box__content" role="document">';
        v += '<div class="uix-modal-box__video-waiting"></div><div class="uix-modal-box__video-container" data-video-player-init="0">';

        if ($this.find('[data-video-iframe]').length > 0 && videoSrcIfm != '') {
          //If iframe
          v += '<div id="' + videoContainerVid + '" class="embed-responsive embed-responsive-16by9">';
          v += videoSrcIfm;
          v += '</div>';
        } else {
          //If local video
          v += '<video id="' + videoContainerVid + '" class="video-js vjs-default-skin" controls poster="' + videoPoster + '">';
          v += vmp4 + vwebm + vogv;
          v += '</video>';
        }

        v += '</div>';
        v += '</div>';
        v += '</div>'; //Wait until previous .append() is complete

        $(v).appendTo('body');
      }
    }); //Check out: http://docs.videojs.com/tutorial-player-workflows.html

    $(document).off('click.VIDEOS').on('click.VIDEOS', modalDialogTrigger, function () {
      var vid = $(this).data('modal-id') + '--videopush',
          newMaxW = windowWidth - 80,
          newMaxH = windowHeight - 80,
          $vContainer = $('#' + vid).closest('.uix-modal-box__video-container'),
          $vLoader = $vContainer.prev('.uix-modal-box__video-waiting'),
          myPlayerInit = $vContainer.data('video-player-init');
      var $ifm = false; //----- Hidden/Display the wrapper of video

      var displayVC = function displayVC() {
        TweenMax.set($vContainer, {
          alpha: 1
        });
        $vLoader.removeClass('is-active');
      };

      var hiddenVC = function hiddenVC() {
        TweenMax.set($vContainer, {
          alpha: 0
        });
        $vLoader.addClass('is-active');
      }; //----- Embed iframe


      if ($('#' + vid).find('iframe').length > 0) {
        $ifm = $('#' + vid).find('iframe');
      } else {
        hiddenVC();
      }

      if ($ifm && videos_typeof($ifm) === 'object') {
        if ($ifm.length > 0) {
          var curW = $ifm.width(),
              curH = $ifm.height(),
              newW = curW,
              newH = curH;

          if (curH > newMaxH) {
            newH = newMaxH; //Scaled/Proportional Content 

            newW = curW * (newH / curH);
          }

          if (newW > newMaxW) {
            newW = newMaxW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);
          }

          $ifm.css({
            'left': (newMaxW - newW) / 2 + 'px',
            'top': (newMaxH - newH) / 2 + 'px',
            'height': newH + 'px',
            'width': newW + 'px'
          });

          if (windowWidth <= 768) {
            $ifm.css({
              'top': 0
            }).parent('.embed-responsive').css({
              'top': (newMaxH - newH) / 2 + 'px'
            });
          }
        }

        return false;
      } //----- HTML5 video autoplay on mobile revisited


      if (windowWidth <= 768) {
        $('#' + vid).attr({
          'playsinline': 'true'
        });
      } //----- Embed local video


      var myPlayer = videojs(vid, {
        width: 1,
        height: 1,
        autoplay: true,
        loop: true
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH; //Resise modal

          if (curH > newMaxH) {
            newH = newMaxH; //Scaled/Proportional Content 

            newW = curW * (newH / curH);
          }

          if (newW > newMaxW) {
            newW = newMaxW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);
          }

          obj.height(newH);
          obj.width(newW); //In order to allow CSS to support video centering

          $vContainer.find(' > div.video-js').css({
            'width': newW + 'px'
          }); //Vertically center the video area

          var mt = parseFloat(windowHeight - newH) / 2 - 50;
          $vContainer.css({
            'transform': 'translateY(' + mt + 'px)'
          }); //Display the wrapper of video

          displayVC();
        };

        initVideo(this);
        /* ---------  Video Modal initialize */

        this.on('loadedmetadata', function () {
          initVideo(this); //If a player instance has already been created for this variable.

          $vContainer.data('video-player-init', 1);
        });
        /* ---------  Set, tell the player it's in fullscreen  */
        //this.exitFullscreen();
        //this.requestFullscreen();

        this.play();
        /* ---------  Disable control bar play button click */
        //this.controls( false );

        /* ---------  Display video playback progress  */

        this.on('timeupdate', function () {
          var duration = this.duration(),
              progressAmount = '0%';

          if (duration > 0) {
            progressAmount = this.currentTime() / duration * 100 + "%";
          } //console.log( progressAmount );

        });
        /* ---------  Callback for when a video has ended */

        this.on('ended', function () {//console.log( 'video is done!' );
        });
      });
      /* ---------  Display the wrapper of video  */

      if (myPlayerInit === 1) {
        displayVC();
      }
      /* ---------  Close the modal  */


      $(document).off('click.VIDEOS_CLOSE').on('click.VIDEOS_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
        myPlayer.ready(function () {
          this.pause();
        });
      });
    });
  };

  module.components.documentReady.push(module.VIDEOS.documentReady);
  return function VIDEOS() {
    videos_classCallCheck(this, VIDEOS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_main/scss/_style.scss
var scss_style = __webpack_require__(11);

// CONCATENATED MODULE: ./src/components/_main/js/index.js
function js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Theme Scripts  -->
 *************************************
 */


var MAIN = function (module, $, window, document) {
  if (window.MAIN === null) return false;
  module.MAIN = module.MAIN || {};
  module.MAIN.version = '0.0.1';

  module.MAIN.documentReady = function ($) {
    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };

  module.MAIN.pageLoaded = function () {
    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };

  module.components.documentReady.push(module.MAIN.documentReady);
  module.components.pageLoaded.push(module.MAIN.pageLoaded);
  return function MAIN() {
    js_classCallCheck(this, MAIN);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/accordion-img/scss/_style.scss
var accordion_img_scss_style = __webpack_require__(12);

// CONCATENATED MODULE: ./src/components/accordion-img/js/index.js
function accordion_img_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { js_typeof = function _typeof(obj) { return typeof obj; }; } else { js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return js_typeof(obj); }

/* 
 *************************************
 * <!-- Accordion Background Images -->
 *************************************
 */


var ACCORDION_BG = function (module, $, window, document) {
  if (window.ACCORDION_BG === null) return false;
  module.ACCORDION_BG = module.ACCORDION_BG || {};
  module.ACCORDION_BG.version = '0.0.6';

  module.ACCORDION_BG.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    if (windowWidth <= 768) return false;
    $('.uix-accordion-img').each(function () {
      var $this = $(this);
      var aEvent = $this.data('event'),
          outReset = $this.data('out-reset'),
          activeIndex = $this.data('actived-item'),
          widthShow = $this.data('width-show'),
          closeBtn = $this.data('close-btn'),
          $li = $this.find('ul').children('li'),
          total = $li.length;

      if (js_typeof(activeIndex) === ( true ? "undefined" : undefined)) {
        activeIndex = false;
      }

      if (js_typeof(aEvent) === ( true ? "undefined" : undefined)) {
        aEvent = 'click';
      }

      if (js_typeof(outReset) === ( true ? "undefined" : undefined)) {
        outReset = true;
      }

      if (js_typeof(widthShow) === ( true ? "undefined" : undefined)) {
        widthShow = '60%';
      } //Initialize the width of each item


      itemInit();
      $li.on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation(); //Apply click method to outer div but not inner div

        if (e.target.className == 'uix-accordion-img__content') {
          if ($(this).hasClass('is-active')) {
            $(this).addClass('is-active');
          } else {
            $li.addClass('active-sub');
            $(this).addClass('is-active');
            $(this).siblings().removeClass('is-active');
            $li.css('width', (100 - parseFloat(widthShow)) / (total - 1) + '%');
            $(this).css('width', widthShow);
          }
        }
      });

      if (outReset) {
        $this.on('mouseleave', function (e) {
          itemInit();
        });
      }

      if (js_typeof(closeBtn) != ( true ? "undefined" : undefined) && closeBtn != false && closeBtn != '') {
        $(closeBtn).off('click').on('click', function (e) {
          e.preventDefault();
          itemInit();
        });
      }
      /*
       * Active the target item
       *
          * @param  {Number} index     - The index value of the item to be activated.
       * @return {Void}
       */


      function itemActiveItem(index) {
        if (index >= 0) {
          $li.css('width', (100 - parseFloat(widthShow)) / (total - 1) + '%');
          $li.eq(index).css('width', widthShow).addClass('is-active');
        }
      }

      itemActiveItem(parseFloat(activeIndex));
      /*
       * Initialize the width of each item
       *
       * @return {Void}
       */

      function itemInit() {
        $li.removeClass('is-active active-sub').css('width', 100 / total + '%');
      }
    });
  };

  module.components.documentReady.push(module.ACCORDION_BG.documentReady);
  return function ACCORDION_BG() {
    accordion_img_js_classCallCheck(this, ACCORDION_BG);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/accordion/scss/_style.scss
var accordion_scss_style = __webpack_require__(13);

// CONCATENATED MODULE: ./src/components/accordion/js/index.js
function accordion_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function accordion_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { accordion_js_typeof = function _typeof(obj) { return typeof obj; }; } else { accordion_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return accordion_js_typeof(obj); }

/* 
 *************************************
 * <!-- Accordion -->
 *************************************
 */


var ACCORDION = function (module, $, window, document) {
  if (window.ACCORDION === null) return false;
  module.ACCORDION = module.ACCORDION || {};
  module.ACCORDION.version = '0.0.3';

  module.ACCORDION.documentReady = function ($) {
    $('.uix-accordion').each(function () {
      var $this = $(this);
      var $li = $this.children('dl'),
          $titlebox = $this.find('dt');
      var aEvent = $this.data('event'),
          firstShow = $this.data('first-show');

      var openItem = function openItem(obj) {
        //to open
        // - temporarilty set height:auto
        // - tween from height:0
        TweenMax.set(obj, {
          height: 'auto'
        });
        TweenMax.from(obj, 0.5, {
          height: 0
        });
      };

      if (accordion_js_typeof(aEvent) === ( true ? "undefined" : undefined)) {
        aEvent = 'click';
      }

      if (accordion_js_typeof(firstShow) === ( true ? "undefined" : undefined)) {
        firstShow = false;
      }

      if (firstShow) {
        $li.first().addClass('is-active').attr('aria-expanded', true);
        openItem($li.first().find('dd'));
      }

      $li.off(aEvent).on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation(); //Its value is not a boolean but a string

        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true,
            $content = $(this).find('dd');

        if (expanded) {
          //Hide other all sibling <dt> of the selected element
          var $e = $(this).siblings();
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.find('dd'), 0.5, {
            height: 0
          }); //to open

          openItem($content);
        } else {
          if (e.type == 'click') {
            $(this).removeClass('is-active').attr('aria-expanded', false); //to close

            TweenMax.to($content, 0.5, {
              height: 0
            });
          }
        }
      });
    });
  };

  module.components.documentReady.push(module.ACCORDION.documentReady);
  return function ACCORDION() {
    accordion_js_classCallCheck(this, ACCORDION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/advanced-slider/scss/_basic.scss
var _basic = __webpack_require__(14);

// CONCATENATED MODULE: ./src/components/advanced-slider/js/basic.js
function basic_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function basic_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { basic_typeof = function _typeof(obj) { return typeof obj; }; } else { basic_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return basic_typeof(obj); }

/* 
 *************************************
 * <!-- Advanced Slider (Basic) -->
 *************************************
 */


var ADVANCED_SLIDER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER === null) return false;
  module.ADVANCED_SLIDER = module.ADVANCED_SLIDER || {};
  module.ADVANCED_SLIDER.version = '0.2.3';

  module.ADVANCED_SLIDER.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animDelay = 0;
    var $sliderWrapper = $('.uix-advanced-slider');
    sliderInit(false);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        sliderInit(true);
      }
    });
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if (basic_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now');
          if (basic_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-advanced-slider__pagination';
          if (basic_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider__arrows';
          if (basic_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
          if (basic_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if (basic_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = 'p.count em.count';
          if (basic_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = 'p.count em.current'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if (basic_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
          if (basic_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
          if (basic_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the duration of the animation from CSS/SCSS
          //-------------------------------------	

          animDelay = UixCssProperty.getTransitionDuration($first[0]); //Initialize the properties of each Item
          //-------------------------------------	

          $items.each(function (index) {
            var _item = $(this);

            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          }); //Initialize the first item container
          //-------------------------------------		

          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay);

          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if (basic_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $first.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
              nativeItemW = this.videoWidth;
              nativeItemH = this.videoHeight; //Initialize all the items to the stage

              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $first.find('img').attr('src');

            if (basic_typeof(imgURL) != ( true ? "undefined" : undefined)) {
              var img = new Image();

              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
              };

              img.src = imgURL;
            }
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }
    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
    * @return {Void}
    */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID) {
      var $this = slider,
          $items = $this.find('.uix-advanced-slider__item'),
          $first = $items.first(),
          itemTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider__arrows--prev"></a><a href="#" class="uix-advanced-slider__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      } // Fires local videos asynchronously with slider switch.
      //-------------------------------------


      normalSliderVideoInit($items, false); //Pagination dots 
      //-------------------------------------	

      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-advanced-slider__arrows--prev'),
          _next = $(arrowsID).find('.uix-advanced-slider__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animDelay).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animDelay).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      }); //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragDropTrigger = $items; //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragDropTrigger.css('cursor', draggableCursor); //Mouse event

      $dragDropTrigger.on('mousedown.ADVANCED_SLIDER touchstart.ADVANCED_SLIDER', function (e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.originalEvent.touches;
        $(this).addClass('is-dragging');

        if (touches && touches.length) {
          $(this).data('origin_mouse_x', parseInt(touches[0].pageX));
          $(this).data('origin_mouse_y', parseInt(touches[0].pageY));
        } else {
          if (draggable) {
            $(this).data('origin_mouse_x', parseInt(e.pageX));
            $(this).data('origin_mouse_y', parseInt(e.pageY));
          }
        }

        $dragDropTrigger.on('mouseup.ADVANCED_SLIDER touchmove.ADVANCED_SLIDER', function (e) {
          $(this).removeClass('is-dragging');
          var touches = e.originalEvent.touches,
              origin_mouse_x = $(this).data('origin_mouse_x'),
              origin_mouse_y = $(this).data('origin_mouse_y');

          if (touches && touches.length) {
            var deltaX = origin_mouse_x - touches[0].pageX,
                deltaY = origin_mouse_y - touches[0].pageY; //--- left

            if (deltaX >= 50) {
              if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
            } //--- right


            if (deltaX <= -50) {
              if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
            } //--- up


            if (deltaY >= 50) {} //--- down


            if (deltaY <= -50) {}

            if (Math.abs(deltaX) >= 50 || Math.abs(deltaY) >= 50) {
              $dragDropTrigger.off('touchmove.ADVANCED_SLIDER');
            }
          } else {
            if (draggable) {
              //right
              if (e.pageX > origin_mouse_x) {
                if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
              } //left


              if (e.pageX < origin_mouse_x) {
                if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
              } //down


              if (e.pageY > origin_mouse_y) {} //up


              if (e.pageY < origin_mouse_y) {}

              $dragDropTrigger.off('mouseup.ADVANCED_SLIDER');
            }
          }
        }); //end: mouseup.ADVANCED_SLIDER touchmove.ADVANCED_SLIDER
      }); // end: mousedown.ADVANCED_SLIDER touchstart.ADVANCED_SLIDER
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //Display counter
      //-------------------------------------

      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); // Fires local videos asynchronously with slider switch.
      //-------------------------------------

      normalSliderVideoInit($items, false);
      normalSliderVideoInit($current, true); //Reset the default height of item
      //-------------------------------------	

      itemDefaultInit(slider, $current);
    }
    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function itemDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if (basic_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          slider.css('height', this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth) + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');

        if (basic_typeof(imgURL) != ( true ? "undefined" : undefined)) {
          var img = new Image();

          img.onload = function () {
            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };

          img.src = imgURL;
        }
      }
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if (basic_typeof(dataAuto) === ( true ? "undefined" : undefined)) {
          dataAuto = true;
        }

        if (basic_typeof(dataLoop) === ( true ? "undefined" : undefined)) {
          dataLoop = true;
        }

        if (basic_typeof(dataControls) === ( true ? "undefined" : undefined)) {
          dataControls = false;
        }

        if (basic_typeof(dataW) === ( true ? "undefined" : undefined) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if (basic_typeof(dataH) === ( true ? "undefined" : undefined) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true); //Prevent autoplay error: Uncaught (in promise) DOMException

            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);

            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };

  module.components.pageLoaded.push(module.ADVANCED_SLIDER.pageLoaded);
  return function ADVANCED_SLIDER() {
    basic_classCallCheck(this, ADVANCED_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/third-party-plugins/esm/GSAP/TweenLite.js
var GSAP_TweenLite = __webpack_require__(0);

// CONCATENATED MODULE: ./src/third-party-plugins/esm/GSAP/PixiPlugin.js
/*!
 * VERSION: 0.3.0
 * DATE: 2019-05-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * PixiPlugin is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */


var _numExp = /(\d|\.)+/g,
    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
    _colorLookup = {
  aqua: [0, 255, 255],
  lime: [0, 255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, 255],
  navy: [0, 0, 128],
  white: [255, 255, 255],
  fuchsia: [255, 0, 255],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  orange: [255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [255, 0, 0],
  pink: [255, 192, 203],
  cyan: [0, 255, 255],
  transparent: [255, 255, 255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
},

/**
 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if "format" parameter is "hsl", it will populate the array with hue, saturation, and lightness values. Or if "format" is "number", it'll return a number like 0xFF0000 instead of an array. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
 * @param {(string)} format If "hsl", an hsl() or hsla() value will be returned instead of rgb() or rgba(). Or if "number", then a numeric value will be returned, like 0xFF0000. Default is rgb.
 * @return {(array|number)} An array containing red, green, and blue (and optionally alpha) in that order, or if the format parameter was "hsl", the array will contain hue, saturation and lightness (and optionally alpha) in that order. Or if "format" is defined as "number", it'll return a number like 0xFF0000. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and "format" is "hsl".
 */
_parseColor = function _parseColor(v, format) {
  var toHSL = format === "hsl",
      a,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!v) {
    a = _colorLookup.black;
  } else if (typeof v === "number") {
    a = [v >> 16, v >> 8 & 255, v & 255];
  } else {
    if (v.charAt(v.length - 1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length === 4) {
        //for shorthand like #9F0
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b;
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & 255, v & 255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_numExp);

      if (!toHSL) {
        h = Number(a[0]) % 360 / 360;
        s = Number(a[1]) / 100;
        l = Number(a[2]) / 100;
        g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;

        if (a.length > 3) {
          a[3] = Number(v[3]);
        }

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (v.indexOf("=") !== -1) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        return v.match(_relNumExp);
      }
    } else {
      a = v.match(_numExp) || _colorLookup.transparent;
    }

    a[0] = Number(a[0]);
    a[1] = Number(a[1]);
    a[2] = Number(a[2]);

    if (a.length > 3) {
      a[3] = Number(a[3]);
    }
  }

  if (toHSL && !wasHSL) {
    r = a[0] / 255;
    g = a[1] / 255;
    b = a[2] / 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = h + 0.5 | 0;
    a[1] = s * 100 + 0.5 | 0;
    a[2] = l * 100 + 0.5 | 0;
  }

  return format === "number" ? a[0] << 16 | a[1] << 8 | a[2] : a;
},
    _formatColors = function _formatColors(s, toHSL) {
  var colors = (s + "").match(_colorExp) || [],
      charIndex = 0,
      parsed = "",
      i,
      color,
      temp;

  if (!colors.length) {
    return s;
  }

  for (i = 0; i < colors.length; i++) {
    color = colors[i];
    temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
    charIndex += temp.length + color.length;
    color = _parseColor(color, toHSL ? "hsl" : "rgb");

    if (color.length === 3) {
      color.push(1);
    }

    parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
  }

  return parsed + s.substr(charIndex);
},
    _colorStringFilter,
    PixiPlugin_TweenLite = (GSAP_TweenLite["a" /* _gsScope */].GreenSockGlobals || GSAP_TweenLite["a" /* _gsScope */]).TweenLite,
    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
    //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.
_idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    _lumR = 0.212671,
    _lumG = 0.715160,
    _lumB = 0.072169,
    _applyMatrix = function _applyMatrix(m, m2) {
  var temp = [],
      i = 0,
      z = 0,
      y,
      x;

  for (y = 0; y < 4; y++) {
    for (x = 0; x < 5; x++) {
      z = x === 4 ? m[i + 4] : 0;
      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
    }

    i += 5;
  }

  return temp;
},
    _setSaturation = function _setSaturation(m, n) {
  var inv = 1 - n,
      r = inv * _lumR,
      g = inv * _lumG,
      b = inv * _lumB;
  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
},
    _colorize = function _colorize(m, color, amount) {
  var c = _parseColor(color),
      r = c[0] / 255,
      g = c[1] / 255,
      b = c[2] / 255,
      inv = 1 - amount;

  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
},
    _setHue = function _setHue(m, n) {
  n *= Math.PI / 180;
  var c = Math.cos(n),
      s = Math.sin(n);
  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
},
    _setContrast = function _setContrast(m, n) {
  return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
},
    PixiPlugin_getFilter = function _getFilter(t, type) {
  var filterClass = GSAP_TweenLite["a" /* _gsScope */].PIXI.filters[type],
      filters = t.filters || [],
      i = filters.length,
      filter;

  if (!filterClass) {
    throw "PixiPlugin error: " + type + " isn't present.";
  }

  while (--i > -1) {
    if (filters[i] instanceof filterClass) {
      return filters[i];
    }
  }

  filter = new filterClass();

  if (type === "BlurFilter") {
    filter.blur = 0;
  }

  filters.push(filter);
  t.filters = filters;
  return filter;
},
    _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, pg, cache, vars) {
  //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.
  pg._addTween(cache, p, cache[p], vars[p], p);

  pg._overwriteProps.push(p);
},
    PixiPlugin_applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {
  var temp = new GSAP_TweenLite["a" /* _gsScope */].PIXI.filters.ColorMatrixFilter();
  temp.matrix = matrix;
  temp.brightness(brightness, true);
  return temp.matrix;
},
    _CMFdefaults = {
  contrast: 1,
  saturation: 1,
  colorizeAmount: 0,
  colorize: "rgb(255,255,255)",
  hue: 0,
  brightness: 1
},
    _parseColorMatrixFilter = function _parseColorMatrixFilter(t, v, pg) {
  var filter = PixiPlugin_getFilter(t, "ColorMatrixFilter"),
      cache = t._gsColorMatrixFilter = t._gsColorMatrixFilter || {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
  },
      combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),
      i,
      matrix,
      startMatrix;

  startMatrix = filter.matrix;

  if (v.resolution) {
    filter.resolution = v.resolution;
  }

  if (v.matrix && v.matrix.length === startMatrix.length) {
    matrix = v.matrix;

    if (cache.contrast !== 1) {
      _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
    }

    if (cache.hue) {
      _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
    }

    if (cache.brightness !== 1) {
      _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
    }

    if (cache.colorizeAmount) {
      _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
    }

    if (cache.saturation !== 1) {
      _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
    }
  } else {
    matrix = _idMatrix.slice();

    if (v.contrast != null) {
      matrix = _setContrast(matrix, Number(v.contrast));

      _addColorMatrixFilterCacheTween("contrast", pg, cache, v);
    } else if (cache.contrast !== 1) {
      if (combine) {
        matrix = _setContrast(matrix, cache.contrast);
      } else {
        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
      }
    }

    if (v.hue != null) {
      matrix = _setHue(matrix, Number(v.hue));

      _addColorMatrixFilterCacheTween("hue", pg, cache, v);
    } else if (cache.hue) {
      if (combine) {
        matrix = _setHue(matrix, cache.hue);
      } else {
        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
      }
    }

    if (v.brightness != null) {
      matrix = PixiPlugin_applyBrightnessToMatrix(Number(v.brightness), matrix);

      _addColorMatrixFilterCacheTween("brightness", pg, cache, v);
    } else if (cache.brightness !== 1) {
      if (combine) {
        matrix = PixiPlugin_applyBrightnessToMatrix(cache.brightness, matrix);
      } else {
        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
      }
    }

    if (v.colorize != null) {
      v.colorizeAmount = "colorizeAmount" in v ? Number(v.colorizeAmount) : 1;
      matrix = _colorize(matrix, v.colorize, v.colorizeAmount);

      _addColorMatrixFilterCacheTween("colorize", pg, cache, v);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
    } else if (cache.colorizeAmount) {
      if (combine) {
        matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
      } else {
        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
      }
    }

    if (v.saturation != null) {
      matrix = _setSaturation(matrix, Number(v.saturation));

      _addColorMatrixFilterCacheTween("saturation", pg, cache, v);
    } else if (cache.saturation !== 1) {
      if (combine) {
        matrix = _setSaturation(matrix, cache.saturation);
      } else {
        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
      }
    }
  }

  i = matrix.length;

  while (--i > -1) {
    if (matrix[i] !== startMatrix[i]) {
      pg._addTween(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");
    }
  }

  pg._overwriteProps.push("colorMatrixFilter");
},
    _addColorTween = function _addColorTween(target, p, value, colorSetter, plugin) {
  var pt = colorSetter._firstPT = {
    _next: colorSetter._firstPT,
    t: target,
    p: p,
    proxy: {},
    f: typeof target[p] === "function"
  };
  pt.proxy[p] = "rgb(" + _parseColor(!pt.f ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]()).join(",") + ")";

  plugin._addTween(pt.proxy, p, "get", typeof value === "number" ? "rgb(" + _parseColor(value, false).join(",") + ")" : value, p, null, null, _colorStringFilter);
},
    //to improve performance, when a color is sensed, we hijack the setRatio() method of the plugin instance with a new function that this method spits back. This is a special method that handles parsing color values on-the-fly and turns them into numeric values which PixiJS requires. In other words, instead of "rgb(255, 0, 0)", PixiJS wants 0xFF0000. This also works with hsl() values.
_buildColorSetter = function _buildColorSetter(tween, plugin) {
  var setRatio = plugin.setRatio,
      //save the original (super) setRatio() function
  func = function func(v) {
    var pt = func._firstPT,
        val;
    setRatio.call(plugin, v);

    while (pt) {
      val = _parseColor(pt.proxy[pt.p], "number");

      if (pt.f) {
        pt.t[pt.p](val);
      } else {
        pt.t[pt.p] = val;
      }

      pt = pt._next;
    }

    if (func.graphics) {
      //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the "dirty" and "clearDirty" values. If we don't do this, the values will be tween properly, but not rendered.
      func.graphics.dirty++;
      func.graphics.clearDirty++;
    }
  };

  plugin.setRatio = func;
  return func;
},
    _colorProps = {
  tint: 1,
  lineColor: 1,
  fillColor: 1
},
    _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
    _contexts = {
  x: "position",
  y: "position",
  tileX: "tilePosition",
  tileY: "tilePosition"
},
    _colorMatrixFilterProps = {
  colorMatrixFilter: 1,
  saturation: 1,
  contrast: 1,
  hue: 1,
  colorize: 1,
  colorizeAmount: 1,
  brightness: 1,
  combineCMF: 1
},
    _DEG2RAD = Math.PI / 180,
    _degreesToRadians = function _degreesToRadians(value) {
  return typeof value === "string" && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;
},
    PixiPlugin_i,
    PixiPlugin_p; //context setup...


for (PixiPlugin_i = 0; PixiPlugin_i < _xyContexts.length; PixiPlugin_i++) {
  PixiPlugin_p = _xyContexts[PixiPlugin_i];
  _contexts[PixiPlugin_p + "X"] = PixiPlugin_p;
  _contexts[PixiPlugin_p + "Y"] = PixiPlugin_p;
} //color parsing setup...


for (PixiPlugin_p in _colorLookup) {
  _colorExp += "|" + PixiPlugin_p + "\\b";
}

_colorExp = new RegExp(_colorExp + ")", "gi");

_colorStringFilter = function _colorStringFilter(a) {
  var combined = a[0] + " " + a[1],
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
    a[0] = _formatColors(a[0], toHSL);
    a[1] = _formatColors(a[1], toHSL);
  }
};

if (!PixiPlugin_TweenLite.defaultStringFilter) {
  PixiPlugin_TweenLite.defaultStringFilter = _colorStringFilter;
}

var PixiPlugin = GSAP_TweenLite["a" /* _gsScope */]._gsDefine.plugin({
  propName: "pixi",
  priority: 0,
  API: 2,
  global: true,
  version: "0.3.0",
  init: function init(target, values, tween, index) {
    if (!target instanceof GSAP_TweenLite["a" /* _gsScope */].PIXI.DisplayObject) {
      return false;
    }

    var isV4 = GSAP_TweenLite["a" /* _gsScope */].PIXI.VERSION.charAt(0) === "4",
        context,
        axis,
        value,
        colorMatrix,
        filter,
        p,
        padding,
        colorSetter,
        i,
        data,
        pt;

    for (p in values) {
      context = _contexts[p];
      value = values[p];

      if (typeof value === "function") {
        value = value(index || 0, target);
      }

      if (context) {
        axis = p.charAt(p.length - 1).toLowerCase().indexOf("x") !== -1 ? "x" : "y";

        this._addTween(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value, p);
      } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
        this._addTween(target[p], "x", target[p].x, value, p + "X");

        this._addTween(target[p], "y", target[p].y, value, p + "Y");
      } else if (p === "rotation") {
        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
        this._addTween(target, p, target.rotation, _degreesToRadians(value), p);
      } else if (_colorMatrixFilterProps[p]) {
        if (!colorMatrix) {
          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);

          colorMatrix = true;
        }
      } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
        filter = PixiPlugin_getFilter(target, "BlurFilter");

        this._addTween(filter, p, filter[p], value, p);

        if (values.blurPadding !== 0) {
          padding = values.blurPadding || Math.max(filter[p], value) * 2;
          i = target.filters.length;

          while (--i > -1) {
            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
          }
        }
      } else if (_colorProps[p]) {
        if (!colorSetter) {
          colorSetter = _buildColorSetter(tween, this);
        }

        if ((p === "lineColor" || p === "fillColor") && target instanceof GSAP_TweenLite["a" /* _gsScope */].PIXI.Graphics) {
          data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5

          i = data.length;

          while (--i > -1) {
            _addColorTween(isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], isV4 ? p : "color", value, colorSetter, this);
          }

          colorSetter.graphics = target.geometry || target;
        } else {
          _addColorTween(target, p, value, colorSetter, this);
        }
      } else if (p === "autoAlpha") {
        this._firstPT = pt = {
          t: {
            setRatio: function setRatio() {
              target.visible = !!target.alpha;
            }
          },
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          pg: 0,
          n: "visible",
          pr: 0,
          m: 0,
          _next: this._firstPT
        };

        if (pt._next) {
          pt._next._prev = pt;
        }

        this._addTween(target, "alpha", target.alpha, value, "alpha");

        this._overwriteProps.push("alpha", "visible");
      } else {
        this._addTween(target, p, target[p], value, p);
      }

      this._overwriteProps.push(p);
    }

    return true;
  }
});

PixiPlugin.colorProps = _colorProps;
PixiPlugin.parseColor = _parseColor;
PixiPlugin.formatColors = _formatColors;
PixiPlugin.colorStringFilter = _colorStringFilter;

PixiPlugin.registerPIXI = function (PIXI) {
  GSAP_TweenLite["a" /* _gsScope */].PIXI = PIXI;
};


// EXTERNAL MODULE: ./src/components/advanced-slider/scss/_special.scss
var _special = __webpack_require__(16);

// CONCATENATED MODULE: ./src/components/advanced-slider/js/special.js
function special_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function special_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { special_typeof = function _typeof(obj) { return typeof obj; }; } else { special_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return special_typeof(obj); }

/* 
 *************************************
 * <!-- Advanced Slider (Special Effects) -->
 *************************************
 */



var ADVANCED_SLIDER_FILTER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER_FILTER === null) return false;
  module.ADVANCED_SLIDER_FILTER = module.ADVANCED_SLIDER_FILTER || {};
  module.ADVANCED_SLIDER_FILTER.version = '0.3.2';

  module.ADVANCED_SLIDER_FILTER.pageLoaded = function () {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-advanced-slider-sp');
    var //Save different canvas heights as an array
    canvasHeights = [],
        //Basic webGL renderers 
    rendererOuterID = 'uix-advanced-slider-sp__canvas-container',
        rendererCanvasID = 'uix-advanced-slider-sp__canvas',
        renderer,
        //PIXI
    renderer__filter,
        rendererCanvasID__filter = rendererCanvasID,
        stage__filter,
        container__items,
        displacementSprite,
        displacementFilter;
    sliderInit(false);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        sliderInit(true);
      }
    });
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider-sp__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if (special_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now'),
              dataSpeed = $this.data('speed'),
              dataFilterTexture = $this.data('filter-texture');
          if (special_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-advanced-slider-sp__pagination';
          if (special_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider-sp__arrows';
          if (special_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
          if (special_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if (special_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = 'p.count em.count';
          if (special_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = 'p.count em.current';
          if (special_typeof(dataFilterTexture) === ( true ? "undefined" : undefined) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if (special_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
          if (special_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
          if (special_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the animation speed
          //-------------------------------------	

          if (special_typeof(dataSpeed) != ( true ? "undefined" : undefined) && dataSpeed != false) {
            animSpeed = dataSpeed;
          } //Display all images
          //-------------------------------------	


          if (!Modernizr.webgl) {
            $this.find('img').css('visibility', 'visible');
          } //Initialize the first item container
          //-------------------------------------		


          $items.addClass('next');
          $first.addClass('is-active');
          TweenMax.set($items, {
            alpha: 0,
            onComplete: function onComplete() {
              TweenMax.to($first, animSpeed / 1000, {
                alpha: 1,
                delay: animSpeed / 1000
              });
            }
          });

          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $first.attr('src');

            if (special_typeof(videoURL) != ( true ? "undefined" : undefined)) {
              video.addEventListener('loadedmetadata', function (e) {
                $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
                nativeItemW = this.videoWidth;
                nativeItemH = this.videoHeight; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              }, false);
              video.src = videoURL;
            }
          } else {
            var imgURL = $first.find('img').attr('src');

            if (special_typeof(imgURL) != ( true ? "undefined" : undefined)) {
              var img = new Image();

              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              };

              img.src = imgURL;
            }
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
    * @param  {String} countTotalID           - Total number ID or class of counter.
    * @param  {String} countCurID             - Current number ID or class of counter.
    * @param  {String} paginationID           - Navigation ID for paging control of each slide.
    * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider-sp__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1; //Prevent problems with styles when switching in positive order

          if (playTimes == 0) {
            sliderUpdates(playTimes, slider, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
          } else {
            sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
          }
        }
      }, timing);
    }
    /*
     * Initialize all the items to the stage
     *
     * @param  {Element} slider                 - Current selector of each slider.
     * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
     * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
           * @param  {Boolean} draggable             - Allow drag and drop on the slider.
           * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} filterTexture          - The texture used for the displacement map.
     * @return {Void}
     */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, filterTexture) {
      var $this = slider,
          $items = $this.find('.uix-advanced-slider-sp__item'),
          $first = $items.first(),
          itemTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider-sp__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider-sp__arrows--prev"></a><a href="#" class="uix-advanced-slider-sp__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      }

      if (Modernizr.webgl) {
        //Load slides to canvas
        //-------------------------------------	
        if ($('#' + rendererCanvasID).length == 0) {
          $this.prepend('<div id="' + rendererOuterID + '" class="uix-advanced-slider-sp__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
        } //Save different canvas heights as an array
        //-------------------------------------	


        $this.find('.uix-advanced-slider-sp__item').each(function (index) {
          var $thisItem = $(this);

          if ($thisItem.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($thisItem.find('video').attr('id'));
            var videoURL = $thisItem.find('video source:first').attr('src');
            if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              var curW = this.videoWidth,
                  curH = this.videoHeight,
                  newW = curW,
                  newH = curH;
              newW = $this.width(); //Scaled/Proportional Content 

              newH = curH * (newW / curW); //Save different canvas heights as an array

              if (canvasHeights.length < itemTotal) {
                canvasHeights.push(newH);
              }
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();

            imgCur.onload = function () {
              var curW_img = this.width,
                  curH_img = this.height,
                  newW_img = curW_img,
                  newH_img = curH_img;
              newW_img = $this.width(); //Scaled/Proportional Content 

              newH_img = curH_img * (newW_img / curW_img); //Save different canvas heights as an array

              if (canvasHeights.length < itemTotal) {
                canvasHeights.push(newH_img);
              }
            };

            imgCur.src = imgURL;
          }
        }); //$this.find( '.uix-advanced-slider-sp__item' ).each
        //Basic webGL renderers 
        //-------------------------------------

        renderer = new PIXI.Application({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          antialias: true,
          autoResize: true,
          view: document.getElementById(rendererCanvasID)
        });
        renderer__filter = new PIXI.autoDetectRenderer({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          view: document.getElementById(rendererCanvasID__filter)
        }); //
        //

        stage__filter = new PIXI.Container();
        container__items = new PIXI.Container();
        displacementSprite = /^.*\.(avi|AVI|wmv|WMV|flv|FLV|mpg|MPG|mp4|MP4)/.test(filterTexture) ? new PIXI.Sprite(PIXI.Texture.from(filterTexture)) : new PIXI.Sprite.from(filterTexture);
        displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite); //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: renderer.stage.children[index]

        if ($this.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            renderer.stage.addChild(curSprite);
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2;
            displacementSprite.scale.x = 1;
            displacementSprite.scale.y = 1; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              //Need the displacementSprite.texture.baseTexture.wrapMode is "PIXI.WRAP_MODES.REPEAT"
              displacementSprite.x += 1 * delta;
              displacementSprite.y += 0.3; // Render updated scene

              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -------------------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; // Create mask
            //-------------------------------------
            //current mask

            var curSpriteMask = new PIXI.Graphics();
            curSpriteMask.lineStyle(0);
            curSpriteMask.beginFill(0xFFFFFF);
            curSpriteMask.moveTo(0, 0);
            curSpriteMask.lineTo(renderer.view.width, 0);
            curSpriteMask.lineTo(renderer.view.width, renderer.view.height);
            curSpriteMask.lineTo(0, renderer.view.height);
            curSpriteMask.endFill();
            curSpriteMask.position.x = 0;
            curSpriteMask.position.y = 0;
            curSprite.mask = curSpriteMask;
            stage__filter.addChild(curSpriteMask); //Do not add to the container
            //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //Canvas Interactions
        //-------------------------------------


        transitionInteractions(0, itemTotal - 1, $this, 'in', 'next');
      } // Fires local videos asynchronously with slider switch.
      //-------------------------------------


      if (!Modernizr.webgl) normalSliderVideoInit($items, false); //Pagination dots 
      //-------------------------------------	

      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animSpeed).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          } //Canvas Interactions


          transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', curDir); //Update the current and previous/next items

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev'),
          _next = $(arrowsID).find('.uix-advanced-slider-sp__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //Canvas Interactions

        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'prev'); //Update the current and previous items

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //
        //Canvas Interactions

        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'next'); //Update the current and next items

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      }); //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragDropTrigger = $items; //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragDropTrigger.css('cursor', draggableCursor); //Mouse event

      $dragDropTrigger.on('mousedown.ADVANCED_SLIDER_FILTER touchstart.ADVANCED_SLIDER_FILTER', function (e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.originalEvent.touches;
        $(this).addClass('is-dragging');

        if (touches && touches.length) {
          $(this).data('origin_mouse_x', parseInt(touches[0].pageX));
          $(this).data('origin_mouse_y', parseInt(touches[0].pageY));
        } else {
          if (draggable) {
            $(this).data('origin_mouse_x', parseInt(e.pageX));
            $(this).data('origin_mouse_y', parseInt(e.pageY));
          }
        }

        $dragDropTrigger.on('mouseup.ADVANCED_SLIDER_FILTER touchmove.ADVANCED_SLIDER_FILTER', function (e) {
          $(this).removeClass('is-dragging');
          var touches = e.originalEvent.touches,
              origin_mouse_x = $(this).data('origin_mouse_x'),
              origin_mouse_y = $(this).data('origin_mouse_y');

          if (touches && touches.length) {
            var deltaX = origin_mouse_x - touches[0].pageX,
                deltaY = origin_mouse_y - touches[0].pageY; //--- left

            if (deltaX >= 50) {
              if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
            } //--- right


            if (deltaX <= -50) {
              if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
            } //--- up


            if (deltaY >= 50) {} //--- down


            if (deltaY <= -50) {}

            if (Math.abs(deltaX) >= 50 || Math.abs(deltaY) >= 50) {
              $dragDropTrigger.off('touchmove.ADVANCED_SLIDER_FILTER');
            }
          } else {
            if (draggable) {
              //right
              if (e.pageX > origin_mouse_x) {
                if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
              } //left


              if (e.pageX < origin_mouse_x) {
                if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
              } //down


              if (e.pageY > origin_mouse_y) {} //up


              if (e.pageY < origin_mouse_y) {}

              $dragDropTrigger.off('mouseup.ADVANCED_SLIDER_FILTER');
            }
          }
        }); //end: mouseup.ADVANCED_SLIDER_FILTER touchmove.ADVANCED_SLIDER_FILTER
      }); // end: mousedown.ADVANCED_SLIDER_FILTER touchstart.ADVANCED_SLIDER_FILTER
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider-sp__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.
      //-------------------------------------


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.
      //-------------------------------------

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination
      //-------------------------------------

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item
      //-------------------------------------	

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider-sp__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //Display counter
      //-------------------------------------

      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); // Fires local videos asynchronously with slider switch.
      //-------------------------------------

      if (!Modernizr.webgl) {
        normalSliderVideoInit($items, false);
        normalSliderVideoInit($current, true);
      } //Reset the default height of canvas
      //-------------------------------------	


      setTimeout(function () {
        canvasDefaultInit(slider, $current);
      }, animSpeed); //Canvas Interactions
      //-------------------------------------
      //-- Brightness Effect

      if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {} //-- Liquid Distortion Effect


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {} //-- Liquid Distortion Effect 2


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {} //-- Liquid Distortion Effect 3


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {} //-- Parallax Effect 


      if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
        if (loop) {
          if (elementIndex == 0) dir = 'prev';
        }
      }

      transitionInteractions(elementIndex, $items.filter('.leave').index(), slider, 'in', dir);
    }
    /*
     * Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
     *
     * @param  {Number} w                - The width that the canvas will be set.
     * @param  {Number} h                - The height that the canvas will be set.
     * @return {Void}
     */


    function fixCanvasTagSize(w, h) {
      TweenMax.to(['#' + rendererCanvasID, '.uix-advanced-slider-sp__wrapper', '.uix-advanced-slider-sp__inner', '.uix-advanced-slider-sp__canvas-container'], animSpeed / 1000, {
        width: w,
        height: h
      });
    }
    /*
     * Initialize the default height of canvas
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function canvasDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if (special_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          //At the same time change the height of the canvas and slider container
          var h = this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth);

          if (Modernizr.webgl) {
            renderer.view.style.height = h + 'px';
          } //---


          slider.css('height', h + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');

        if (special_typeof(imgURL) != ( true ? "undefined" : undefined)) {
          var img = new Image();

          img.onload = function () {
            if (Modernizr.webgl) {
              renderer.view.style.height = currentLlement.find('img').height() + 'px';
            } //---


            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };

          img.src = imgURL;
        }
      }
    }
    /*
     * Canvas Transition Interactions
     * @http://pixijs.download/dev/docs/index.html
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Number} prevElementIndex       - Index of previous slider.
     * @param  {Element} slider                 - Selector of the slider.
     * @param  {String} goType                 - The type of entry and exit between two items.  
                                                 Optional values: in, out
     * @param  {String} dir                    - Switching direction indicator.	 
     * @return {Void}
     */


    function transitionInteractions(elementIndex, prevElementIndex, slider, goType, dir) {
      if (Modernizr.webgl) {
        var $myRenderer = $('#' + rendererOuterID),
            $current = slider.find('.uix-advanced-slider-sp__item').eq(elementIndex),
            $allItems = slider.find('.uix-advanced-slider-sp__item'),
            imgSel = $current.find('img'),
            curImgURL = imgSel.attr('src'),
            stageW = slider.width(),
            stageH = slider.height(),
            spTotal = slider.find('.uix-advanced-slider-sp__item').length;
        elementIndex = parseFloat(elementIndex);
        prevElementIndex = parseFloat(prevElementIndex); //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------

        if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(renderer.stage.children[elementIndex], animSpeed / 1000, {
              pixi: {
                brightness: 5
              },
              alpha: 1
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = renderer.stage.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var k = 0; k < spTotal; k++) {
                  var obj = renderer.stage.children[k];
                  TweenMax.set(obj, {
                    alpha: 0
                  }); //pause all videos

                  if (obj._texture.baseTexture.imageType == null) {
                    var videoSource = obj.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters

                TweenMax.set(curSp, {
                  pixi: {
                    brightness: 5
                  },
                  alpha: 1,
                  onComplete: function onComplete() {
                    TweenMax.to(this.target, animSpeed / 1000, {
                      pixi: {
                        brightness: 1
                      }
                    });
                    TweenMax.to($current, animSpeed / 1000, {
                      alpha: 1
                    });
                  }
                });
              }
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });
          var curSp = container__items.children[elementIndex],
              prevSp = container__items.children[prevElementIndex]; //Display the current item
          //-------------------------------------

          if (!slider.hasClass('js-init-ok')) {
            for (var k = 0; k < spTotal; k++) {
              var obj = container__items.children[k];
              TweenMax.set(obj, {
                alpha: 0
              });
            } //Avoid repeated initialization


            slider.addClass('js-init-ok');
          } //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	


          if (goType == 'out') {//Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _k = 0; _k < spTotal; _k++) {
                var _obj = container__items.children[_k]; //pause all videos

                if (_obj._texture.baseTexture.imageType == null) {
                  var videoSource = _obj.texture.baseTexture.resource.source; // play the video

                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              } //play current video


              if (curSp._texture.baseTexture.imageType == null) {
                var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              } //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100); //Current item entry action

            var baseTimeline = new TimelineMax({
              onComplete: function onComplete() {
                displacementSprite.scale.set(1);
              },
              onUpdate: function onUpdate() {
                displacementSprite.rotation += baseTimeline.progress() * 0.02;
                displacementSprite.scale.set(baseTimeline.progress() * 3);
              }
            });
            baseTimeline.clear();

            if (baseTimeline.isActive()) {
              return;
            }

            baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
              x: 300,
              y: 300,
              ease: Power1.easeOut
            }).to(prevSp, animSpeed / 2 / 1000, {
              alpha: 0,
              ease: Power2.easeOut
            }, animSpeed / 3 / 1000).to(curSp, animSpeed / 2 / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
              x: 0,
              y: 0,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, 'final'); //Add new ripple each time mouse
            //-------------------------------------

            slider[0].addEventListener("mousedown", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: "+=" + Math.sin(e.pageX) * 100 + "",
                y: "+=" + Math.cos(e.pageY) * 100 + ""
              });
              rotateSpite();
            });
            slider[0].addEventListener("mouseup", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: 0,
                y: 0
              });
            });

            var rotateSpite = function rotateSpite() {
              displacementFilter.rotation += 0.001;
            };
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(displacementSprite.scale, 1, {
              x: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var _k2 = 0; _k2 < spTotal; _k2++) {
                  var _obj2 = container__items.children[_k2];
                  TweenMax.set(_obj2, {
                    alpha: 0
                  }); //pause all videos

                  if (_obj2._texture.baseTexture.imageType == null) {
                    var videoSource = _obj2.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters
                //sprite

                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {
                    TweenMax.to(displacementSprite.scale, 1, {
                      x: 1,
                      y: 1
                    });
                    TweenMax.to(displacementSprite, 1, {
                      rotation: 0
                    });
                  },
                  onUpdate: function onUpdate() {
                    displacementSprite.scale.set(baseTimeline.progress() * 13);
                    displacementSprite.rotation += baseTimeline.progress() * 0.02;
                  }
                });
                baseTimeline.clear(); //filter

                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 200 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            }); //Add new ripple each time mouse is clicked/mousemoved
            //-------------------------------------

            document.addEventListener("mousemove", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: e.pageX / 2 + ""
              });
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(displacementSprite, 1, {
              x: 23,
              y: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var _k3 = 0; _k3 < spTotal; _k3++) {
                  var _obj3 = container__items.children[_k3];
                  TweenMax.set(_obj3, {
                    alpha: 0
                  }); //pause all videos

                  if (_obj3._texture.baseTexture.imageType == null) {
                    var videoSource = _obj3.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters
                //sprite

                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {},
                  onUpdate: function onUpdate() {}
                });
                baseTimeline.clear(); //filter

                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 50 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -----------------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Prevent text overlap when switching quickly

          $allItems.attr('data-text-eff-enable', 0);
          $current.attr('data-text-eff-enable', 1);
          var curSpParallax = container__items.children[elementIndex],
              prevSpParallax = container__items.children[prevElementIndex]; //Display the current item
          //-------------------------------------

          if (!slider.hasClass('js-init-ok')) {
            for (var m = 0; m < spTotal; m++) {
              var objParallax = container__items.children[m];
              TweenMax.set(objParallax.mask, {
                x: renderer.view.width
              });
            } //Avoid repeated initialization


            slider.addClass('js-init-ok');
          } //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	


          if (goType == 'out') {//Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _m = 0; _m < spTotal; _m++) {
                var _obj4 = container__items.children[_m]; //pause all videos

                if (_obj4._texture.baseTexture.imageType == null) {
                  var videoSource = _obj4.texture.baseTexture.resource.source; // play the video

                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              } //play current video


              if (curSpParallax._texture.baseTexture.imageType == null) {
                var videoSource2 = curSpParallax.texture.baseTexture.resource.source; // play the video

                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              } //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100); //Current item entry action

            var restoreX,
                offsetX = renderer.view.width / 6,
                parallaxSpeed = animSpeed / 1000,
                restoreItems = function restoreItems() {
              //restore other items besides the current item
              for (var n = 0; n < spTotal; n++) {
                var _objParallax = container__items.children[n];
                if (elementIndex != n) _objParallax.mask.x = restoreX;
              }
            },
                goNextItem = function goNextItem() {
              // Paralax effect on current slide
              TweenMax.set(curSpParallax, {
                alpha: 1,
                //Avoid error texture rendering errors ***!Important***
                onComplete: function onComplete() {
                  TweenMax.to(this.target, parallaxSpeed, {
                    x: 0,
                    ease: Power2.easeInOut
                  });
                }
              }); // Current Mask animation

              TweenMax.to(curSpParallax.mask, parallaxSpeed, {
                x: 0,
                ease: Power4.easeInOut,
                onComplete: function onComplete() {
                  restoreItems();
                }
              });
              setTimeout(function () {
                //text effect
                if ($.isFunction($.fn.UixTextEff)) {
                  $current.find('[data-text-eff]').each(function (index) {
                    $(document).UixTextEff({
                      selectors: '[data-text-eff="' + $(this).data('text-eff') + '"]',
                      scrollSpy: false
                    });
                  });
                } //Prevent text overlap when switching quickly


                $allItems.each(function () {
                  if ($(this).attr('data-text-eff-enable') == 1) {
                    TweenMax.to($(this), parallaxSpeed, {
                      alpha: 1,
                      delay: parallaxSpeed / 2
                    });
                  } else {
                    TweenMax.to($(this), parallaxSpeed, {
                      alpha: 0,
                      delay: parallaxSpeed / 2
                    });
                  }
                });
              }, parallaxSpeed * 1000 / 2);
            }; // Direction handler


            if (dir == 'next') {
              curSpParallax.x = offsetX;
              curSpParallax.mask.x = renderer.view.width;
              restoreX = renderer.view.width; // Paralax effect on current slide

              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: -offsetX,
                ease: Power2.easeInOut
              });
            } else {
              curSpParallax.x = -offsetX;
              curSpParallax.mask.x = -(renderer.view.width + curSpParallax.x);
              restoreX = -renderer.view.width; // Paralax effect on previous slide

              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: offsetX,
                ease: Power2.easeInOut
              }); // Previous Mask animation

              TweenMax.to(prevSpParallax.mask, parallaxSpeed, {
                x: renderer.view.width,
                ease: Power4.easeInOut
              });
            }

            goNextItem();
          }
        } // end effect		

      } else {
        slider.find('.uix-advanced-slider-sp__item canvas').hide();
      }
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if (special_typeof(dataAuto) === ( true ? "undefined" : undefined)) {
          dataAuto = true;
        }

        if (special_typeof(dataLoop) === ( true ? "undefined" : undefined)) {
          dataLoop = true;
        }

        if (special_typeof(dataControls) === ( true ? "undefined" : undefined)) {
          dataControls = false;
        }

        if (special_typeof(dataW) === ( true ? "undefined" : undefined) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if (special_typeof(dataH) === ( true ? "undefined" : undefined) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true); //Prevent autoplay error: Uncaught (in promise) DOMException

            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);

            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };

  module.components.pageLoaded.push(module.ADVANCED_SLIDER_FILTER.pageLoaded);
  return function ADVANCED_SLIDER_FILTER() {
    special_classCallCheck(this, ADVANCED_SLIDER_FILTER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/AJAX-push/js/index.js
function AJAX_push_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AJAX_push_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { AJAX_push_js_typeof = function _typeof(obj) { return typeof obj; }; } else { AJAX_push_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return AJAX_push_js_typeof(obj); }

/* 
 *************************************
 * <!-- Ajax Push Content  -->
 *************************************
 */


var AJAX_PUSH_CONTENT = function (module, $, window, document) {
  if (window.AJAX_PUSH_CONTENT === null) return false;
  module.AJAX_PUSH_CONTENT = module.AJAX_PUSH_CONTENT || {};
  module.AJAX_PUSH_CONTENT.version = '0.1.9';

  module.AJAX_PUSH_CONTENT.documentReady = function ($) {
    // trigger of AJAX request
    var AJAXPageLinks = '[data-ajax-push-content]'; //all images from pages

    var sources = []; //Added timer to prevent page loading errors for a long time

    var timeClockInit;
    /* Need to set it as a global variable for history */

    var ajaxConfig = {
      "container": "#my-ajax-demo-push-container",
      "target": "#my-ajax-demo-target-container",
      "loading": "<div class=\"my-loader\"><span><i class=\"fa fa-spinner fa-spin\"></i> loading <em id=\"app-loading\" data-txt=\"{progress}%\"></em>...</span></div>",
      "method": "POST"
    },
        thisPageTitle = document.title; // The progress of each page load, using global variables to accurately determine

    var loadedProgress = 0; //loading animation

    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    }; //Click event


    $(document).off('click.AJAX_PUSH_CONTENT').on('click.AJAX_PUSH_CONTENT', AJAXPageLinks, function (event) {
      event.preventDefault(); // The progress of each page load

      loadedProgress = 0; //

      var $this = $(this);
      var curURL = $this.attr('href'),
          config = $this.data('ajax-push-content');

      if (AJAX_push_js_typeof(config) == ( true ? "undefined" : undefined)) {
        config = ajaxConfig;
      } //The currently URL of link


      if (AJAX_push_js_typeof(curURL) === ( true ? "undefined" : undefined)) {
        curURL = $this.closest('a').attr('href');
      } //Prevent multiple request on click


      if ($this.data('request-running')) {
        return;
      }

      $this.data('request-running', true); // Modify the URL without reloading the page

      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      } //Click on this link element using an AJAX request


      pushAction($(config.container), config.target, config.loading, curURL, config.method, $this);
      return false;
    }); //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
          goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )
        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      }); //Empty content that does not exist

      if (eleTarget == null) {
        $(AJAXPageLinks).each(function () {
          var curConfig = $(this).data('ajax-push-content');

          if (AJAX_push_js_typeof(curConfig) != ( true ? "undefined" : undefined)) {
            $(curConfig.container).html('');
          }
        });
      } //Push new content to target container


      var backConfig = $(eleTarget).data('ajax-push-content');

      if (AJAX_push_js_typeof(backConfig) != ( true ? "undefined" : undefined)) {
        pushAction($(backConfig.container), backConfig.target, backConfig.loading, goURL, backConfig.method, $(eleTarget));
      } // Output history button
      //console.log(  $( eleTarget ).data( 'ajax-push-content' ) );

    });
    /*
     * Move Animation
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String|Boolean} target  - The instance ID or class name returned from the callback data. If it is "false", the push content is empty.
     * @param  {String} loading         - Content of loading area.
     * @param  {String} url             - The target URL via AJAX. 
     * @param  {String} method          - The HTTP method to use for the request (e.g. "POST", "GET", "PUT")
     * @param  {?Element|Boolean} btn     - Current trigger button. Avoid button events if "false".
     * @return {Void}
     */

    function pushAction(container, target, loading, url, method, btn) {
      if (container.length == 0) return false;

      if (AJAX_push_js_typeof(method) === ( true ? "undefined" : undefined) || method == '') {
        method = 'POST';
      } // Add a request or response interceptor


      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent
        //Display loader
        showLoader(container, loading); //

        return config;
      }, function (error) {
        return Promise.reject(error);
      }); // To send data in the application/x-www-form-urlencoded format instead

      var formData = new FormData();
      var defaultPostData = {
        action: 'load_singlepages_ajax_content'
      };

      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      } // Create a request event


      axios({
        timeout: 15000,
        method: method,
        url: url,
        data: formData,
        responseType: 'text'
      }).then(function (response) {
        var htmlCode = response.data; //A function to be called if the request succeeds

        var pushContent = !target ? '' : $(htmlCode).find(target).html(); //Display loading image when AJAX call is in progress
        //Remove existing images

        sources = []; //Push all images from page

        $(htmlCode).find('img').each(function () {
          sources.push({
            "url": this.src,
            "id": 'img-' + UixGUID.create(),
            "type": 'img'
          });
        }); //Push all videos from page

        $(htmlCode).find('.uix-video__slider > video').each(function () {
          var _src = $(this).find('source:first').attr('src');

          if (AJAX_push_js_typeof(_src) === ( true ? "undefined" : undefined)) _src = $(this).attr('src');
          sources.push({
            "url": _src,
            "id": 'video-' + UixGUID.create(),
            "type": 'video'
          });
        }); //Execute after all images have loaded

        var per;
        var perInit = 1;

        if (sources.length == 0) {
          per = 100; //loading animation

          loadingAnim(per); //Remove loader

          hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
        }

        var loadImages = function loadImages() {
          var promises = [];

          var _loop = function _loop(i) {
            if (sources[i].type == 'img') {
              ///////////
              // IMAGE //
              ///////////   
              promises.push(new Promise(function (resolve, reject) {
                var img = document.createElement("img");
                img.crossOrigin = "anonymous";
                img.src = sources[i].url;

                img.onload = function (image) {
                  //Compatible with safari and firefox
                  if (AJAX_push_js_typeof(image.path) === ( true ? "undefined" : undefined)) {
                    return resolve(image.target.currentSrc);
                  } else {
                    return resolve(image.path[0].currentSrc);
                  }
                };
              }).then(textureLoaded));
            } else {
              ///////////
              // VIDEO //
              ///////////    
              promises.push(new Promise(function (resolve, reject) {
                $('#' + sources[i].id).one('loadedmetadata', resolve);
                return resolve(sources[i].url);
              }).then(textureLoaded));
            }
          };

          for (var i = 0; i < sources.length; i++) {
            _loop(i);
          }

          return Promise.all(promises);
        };

        var textureLoaded = function textureLoaded(url) {
          //loading
          per = parseInt(100 * (perInit / sources.length));
          console.log('progress: ' + per + '%');
          if (isNaN(per)) per = 100; // The progress of each page load

          loadedProgress = per; //loading animation

          loadingAnim(per);
          var texture = null;
          perInit++;
          return per;
        };

        var func = function func() {
          ajaxSucceeds(container, pushContent, $(htmlCode).filter('title').text(), btn);
        }; //images loaded
        //Must be placed behind the loadImages()


        loadImages().then(function (images) {
          clearInterval(timeClockInit);
          func();
        }); //Calculating page load time

        var timeLimit = 10,
            timeStart = new Date().getTime(); //Prevent duplicate runs when returning to this page

        if (timeClockInit) {
          clearInterval(timeClockInit);
        }

        timeClockInit = setInterval(function () {
          //Converting milliseconds to minutes and seconds
          var _time = (new Date().getTime() - timeStart) / 1000;

          if (_time >= timeLimit) {
            console.log('Page load timeout!'); //Remove loader

            if (htmlCode.indexOf('<body') >= 0) {
              window.location.href = location.href;
            } else {
              hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
            } // clear loader event


            clearInterval(timeClockInit);
            func();
          }
        }, 500);
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
          if (status == 404 || status == 405) window.location.href = url;
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request); //

          window.location.href = url;
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      }); // Remove an interceptor later

      axios.interceptors.request.eject(axiosInterceptor);
    }
    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} container    - The target container to which the content will be added.
     * @param  {String} content      - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @param  {?Element} btn          - Current trigger button.
     * @return {Void}
     */


    function ajaxSucceeds(container, content, title, btn) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false; //Remove loader

      hideLoader(container, title, btn, content);
    }
    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title      - The title of a requested page.
     * @param  {?Element} btn      - Current trigger button.
           * @param  {String} content    - The data returned from the server
     * @return {Void}
     */


    function hideLoader(container, title, btn, content) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          }); //The data returned from the server

          container.html(content).promise().done(function () {
            // Apply some asynchronism scripts
            $(document).UixApplyAsyncScripts(); //Change the page title

            if (title) {
              document.title = title;
            } //Prevent multiple request on click


            if (btn) {
              btn.data('request-running', false);
            }
          });
        },
        //Determine the direction of a jQuery scroll event
        //Fix an issue for mousewheel event is too fast.
        delay: 0.5
      });
    }
    /*
     * Display loader
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String} loading         - Content of loading area.
     * @return {Void}
     */


    function showLoader(container, loading) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.3, {
        css: {
          opacity: 1
        },
        ease: Power2.easeOut
      });
      container.html('<div class="ajax-content-loader">' + loading + '</div>').promise().done(function () {
        //loading animation
        loadingAnim(0); //loader effect from AJAX request

        TweenMax.set(container.find('.ajax-content-loader'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      });
    }
  };

  module.components.documentReady.push(module.AJAX_PUSH_CONTENT.documentReady);
  return function AJAX_PUSH_CONTENT() {
    AJAX_push_js_classCallCheck(this, AJAX_PUSH_CONTENT);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/AJAX/scss/_style.scss
var AJAX_scss_style = __webpack_require__(17);

// CONCATENATED MODULE: ./src/components/AJAX/js/index.js
function AJAX_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AJAX_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { AJAX_js_typeof = function _typeof(obj) { return typeof obj; }; } else { AJAX_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return AJAX_js_typeof(obj); }

/* 
 *************************************
 * <!-- Ajax Page Loader (Loading A Page via Ajax Into Div)  -->
 *************************************
 */



var AJAX_PAGE_LOADER = function (module, $, window, document) {
  if (window.AJAX_PAGE_LOADER === null) return false;
  module.AJAX_PAGE_LOADER = module.AJAX_PAGE_LOADER || {};
  module.AJAX_PAGE_LOADER.version = '0.1.9';

  module.AJAX_PAGE_LOADER.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //all images from pages

    var sources = []; //Added timer to prevent page loading errors for a long time

    var timeClockInit; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    loaderRemoveDelay = 500,
        AJAXPageLinks = '[data-ajax-page]',
        $navs = $(AJAXPageLinks).parent().parent().find('li'),
        total = $navs.length,
        $sectionsContainer = $('.uix-ajax-load__fullpage-container'),
        ajaxContainer = '.ajax-container',
        curAjaxPageID = $(ajaxContainer).data('ajax-page-id');
    var lastAnimation = 0; // The progress of each page load, using global variables to accurately determine

    var loadedProgress = 0; //loading animation

    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    }; //Prevent this module from loading in other pages


    if ($sectionsContainer.length == 0) return false;
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */
    //Activate the first item

    if ($('.js-uix-ajax-load__container').length == 0) {
      moveTo($(ajaxContainer), false, 'down', 0, false);
    } else {
      //Activate navigation from AJAX request
      if (AJAX_js_typeof(curAjaxPageID) != ( true ? "undefined" : undefined)) $navs.eq(curAjaxPageID).addClass('is-active');
    }
    /* 
     ====================================================
     *  AJAX Interaction
     ====================================================
     */

    /*
     * Initialize the clickable ajax links
     *
     * @return {Void}
     */


    function ajaxInit() {
      if (windowWidth <= 768) {
        $(AJAXPageLinks).data('mobile-running', true);
      } else {
        $(AJAXPageLinks).data('mobile-running', false);
      }
    }

    ajaxInit();
    $window.on('resize', function () {
      windowWidth = window.innerWidth;
      ajaxInit();
    });
    /*
     * Call AJAX on click event for "single pages links"
     *
     */

    $(document).off('click.AJAX_PAGE_LOADER').on('click.AJAX_PAGE_LOADER', AJAXPageLinks, function (e) {
      //Prevents third-party plug-ins from triggering
      if ($(this).data('mobile-running')) {
        return;
      }

      e.preventDefault(); // The progress of each page load

      loadedProgress = 0; //

      var $this = $(this);
      var curIndex = $this.attr('data-index');
      var curURL = $this.attr('href'); //The currently URL of link

      if (AJAX_js_typeof(curURL) === ( true ? "undefined" : undefined)) {
        curURL = $this.closest('a').attr('href');
      } //Prevent multiple request on click


      if ($(AJAXPageLinks).data('request-running')) {
        return;
      }

      $(AJAXPageLinks).data('request-running', true); // Modify the URL without reloading the page

      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      } //Click on this link element using an AJAX request


      var dir = $navs.filter('.is-active').find('> a').attr('data-index') > curIndex ? 'up' : 'down';
      moveTo($(ajaxContainer), curURL, dir, curIndex, false);
      return false;
    }); //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
          goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )
        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      }); //Empty content that does not exist

      if (eleTarget == null) {
        moveTo($(ajaxContainer), false, 'down', 0, false);
      } //Push new content to target container


      var pageIndex = $(eleTarget).data('index'); //Push new content to target container

      if (AJAX_js_typeof(pageIndex) != ( true ? "undefined" : undefined)) {
        moveTo($(ajaxContainer), goURL, 'down', pageIndex, false);
      } // Output history button
      //console.log(  $( eleTarget ).data( 'index' ) );

    });
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */

    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($(ajaxContainer), false, 'down', false, true);
      } else {
        //scroll up
        moveTo($(ajaxContainer), false, 'up', false, true);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} container    - The instance returned from the request succeeds 
     * @param  {String} url          - The target URL via AJAX.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} customIndex  - User-specified index value, located on the corresponding AJAX hyperlink.
     * @param  {Boolean} wheel       - Whether to enable mouse wheel control.
     * @return {Void}
     */


    function moveTo(container, url, dir, customIndex, wheel) {
      var index = parseFloat($navs.filter('.is-active').find('> a').attr('data-index'));
      var isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null; //If there is a custom index, it is enabled first

      if (isNumeric.test(customIndex)) {
        nextIndex = customIndex;
      } else {
        if (dir == 'down' || dir === false) {
          nextIndex = index + 1;
        } else {
          nextIndex = index - 1;
        }
      }

      if (nextIndex <= parseFloat(total - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(total - 1)) nextIndex = parseFloat(total - 1);
        if (nextIndex < 0) nextIndex = 0; //Prevents third-party plug-ins from triggering

        if ($navs.eq(nextIndex).find('> a').data('mobile-running')) {
          return;
        } //Activate navigation from AJAX request


        $navs.removeClass('is-active');
        $navs.eq(nextIndex).addClass('is-active'); //Use automatic indexing when no URLs come in.

        if (!url || AJAX_js_typeof(url) === ( true ? "undefined" : undefined)) {
          url = $navs.eq(nextIndex).find('> a').attr('href');
        } // Modify the URL without reloading the page when mouse wheel


        if (wheel) {
          var turl = $navs.eq(nextIndex).find('> a').attr('href');

          if (history.pushState) {
            history.pushState(null, null, url);
          } else {
            location.hash = turl;
          }
        } //Click on this link element using an AJAX request
        // Add a request or response interceptor


        var axiosInterceptor = axios.interceptors.request.use(function (config) {
          // Do something before request is sent
          //Display loader
          showLoader(); //

          return config;
        }, function (error) {
          return Promise.reject(error);
        }); // To send data in the application/x-www-form-urlencoded format instead

        var formData = new FormData();
        var defaultPostData = {
          action: 'load_singlepages_ajax_content'
        };

        for (var k in defaultPostData) {
          formData.append(k, defaultPostData[k]);
        }
        /*
        // For multiple form fields data acquisition
        const formData = new FormData();
        const oldFormData = $this.serializeArray();
        oldFormData.forEach(function(item){
            formData.append(item.name, item.value);
        });
        formData.append('action', 'load_singlepages_ajax_content');
        */
        // Create a request event


        axios({
          timeout: 15000,
          method: AJAX_js_typeof(container.data('ajax-method')) === ( true ? "undefined" : undefined) ? 'POST' : container.data('ajax-method'),
          url: url,
          data: formData,
          responseType: 'text'
        }).then(function (response) {
          var htmlCode = response.data; //A function to be called if the request succeeds
          //Display loading image when AJAX call is in progress
          //Remove existing images

          sources = []; //Push all images from page

          $(htmlCode).find('img').each(function () {
            sources.push({
              "url": this.src,
              "id": 'img-' + UixGUID.create(),
              "type": 'img'
            });
          }); //Push all videos from page

          $(htmlCode).find('.uix-video__slider > video').each(function () {
            var _src = $(this).find('source:first').attr('src');

            if (AJAX_js_typeof(_src) === ( true ? "undefined" : undefined)) _src = $(this).attr('src');
            sources.push({
              "url": _src,
              "id": 'video-' + UixGUID.create(),
              "type": 'video'
            });
          }); //Execute after all images have loaded

          var per;
          var perInit = 1;

          if (sources.length == 0) {
            per = 100; //loading animation

            loadingAnim(per); //Remove loader

            var oldContent = container.html();
            hideLoader(container, $(htmlCode).filter('title').text(), dir, oldContent, htmlCode);
          }

          var loadImages = function loadImages() {
            var promises = [];

            var _loop = function _loop(i) {
              if (sources[i].type == 'img') {
                ///////////
                // IMAGE //
                ///////////   
                promises.push(new Promise(function (resolve, reject) {
                  var img = document.createElement("img");
                  img.crossOrigin = "anonymous";
                  img.src = sources[i].url;

                  img.onload = function (image) {
                    //Compatible with safari and firefox
                    if (AJAX_js_typeof(image.path) === ( true ? "undefined" : undefined)) {
                      return resolve(image.target.currentSrc);
                    } else {
                      return resolve(image.path[0].currentSrc);
                    }
                  };
                }).then(textureLoaded));
              } else {
                ///////////
                // VIDEO //
                ///////////    
                promises.push(new Promise(function (resolve, reject) {
                  $('#' + sources[i].id).one('loadedmetadata', resolve);
                  return resolve(sources[i].url);
                }).then(textureLoaded));
              }
            };

            for (var i = 0; i < sources.length; i++) {
              _loop(i);
            }

            return Promise.all(promises);
          };

          var textureLoaded = function textureLoaded(url) {
            //loading
            per = parseInt(100 * (perInit / sources.length));
            console.log('progress: ' + per + '%');
            if (isNaN(per)) per = 100; // The progress of each page load

            loadedProgress = per; //loading animation

            loadingAnim(per);
            var texture = null;
            perInit++;
            return per;
          };

          var func = function func() {
            ajaxSucceeds(dir, container, $(htmlCode).find('.js-uix-ajax-load__container').html(), $(htmlCode).filter('title').text());
          }; //images loaded
          //Must be placed behind the loadImages()


          loadImages().then(function (images) {
            clearInterval(timeClockInit);
            func();
          }); //Calculating page load time

          var timeLimit = 10,
              timeStart = new Date().getTime(); //Prevent duplicate runs when returning to this page

          if (timeClockInit) {
            clearInterval(timeClockInit);
          }

          timeClockInit = setInterval(function () {
            //Converting milliseconds to minutes and seconds
            var _time = (new Date().getTime() - timeStart) / 1000;

            if (_time >= timeLimit) {
              console.log('Page load timeout!'); //Remove loader

              if (htmlCode.indexOf('<body') >= 0) {
                window.location.href = location.href;
              } else {
                var _oldContent = container.html();

                hideLoader(container, $(htmlCode).filter('title').text(), dir, _oldContent, htmlCode);
              } // clear loader event


              clearInterval(timeClockInit);
              func();
            }
          }, 500);
        })["catch"](function (error) {
          if (error.response) {
            // The request was made and the server responded with a status code
            // that falls out of the range of 2xx
            var status = error.response.status;
            console.log(status);
            if (status == 404 || status == 405) window.location.href = url;
          } else if (error.request) {
            // The request was made but no response was received
            // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
            // http.ClientRequest in node.js
            console.log(error.request); //

            window.location.href = url;
          } else {
            // If there was a problem, we need to
            // dispatch the error condition
            console.log(error.message);
          }
        }); // Remove an interceptor later

        axios.interceptors.request.eject(axiosInterceptor);
      }
    }
    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {Element} container - The instance returned from the request succeeds
     * @param  {String} content   - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @return {Void}
     */


    function ajaxSucceeds(dir, container, content, title) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false; //Remove loader

      var oldContent = container.html();
      hideLoader(container, title, dir, oldContent, content);
    }
    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title     - The title of a requested page.
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent   - The old data returned from the server
           * @param  {String} content   - The data returned from the server
     * @return {Void}
     */


    function hideLoader(container, title, dir, oldContent, content) {
      TweenMax.to('.uix-ajax-load__loader', 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          }); //The data returned from the server

          container.html(content).promise().done(function () {
            //Transition effect between two elements.
            eleTransitionEff(dir, oldContent, content); //Change the page title

            if (title) {
              document.title = title;
            } //Prevent multiple request on click


            $(AJAXPageLinks).data('request-running', false);
          });
        },
        delay: loaderRemoveDelay / 1000
      });
    }
    /*
     * Display loader
     *
     * @return {Void}
     */


    function showLoader() {
      //loading animation
      loadingAnim(0); //loader effect from AJAX request

      TweenMax.set('.uix-ajax-load__loader', {
        css: {
          'display': 'block'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.5, {
            alpha: 1
          });
        }
      });
    }
    /*
     * Transition effect between two elements.
     *
     * @param  {String} dir            - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent     - A string of HTML to set as the content of matched old element.
     * @param  {String} newContent     - A string of HTML to set as the content of matched new element.
     * @return {Void}
     */


    function eleTransitionEff(dir, oldContent, newContent) {
      var $originalItem = $sectionsContainer.find('> section'),
          $cloneItem = $originalItem.clone(); //Reset the original element

      $originalItem.css({
        'z-index': 1
      }); //Clone the last element to the first position

      $cloneItem.prependTo($sectionsContainer).css({
        'z-index': 2,
        'transform': 'translateY(' + (dir == 'down' || dir === false ? windowHeight : -windowHeight) + 'px)'
      }) //Add the latest content to the new container
      .find(ajaxContainer).html(newContent);
      $originalItem.first().find(ajaxContainer).html(oldContent).promise().done(function () {
        TweenMax.to($originalItem.first(), animationTime / 1000, {
          y: dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2,
          ease: Power2.easeOut
        });
        TweenMax.to($cloneItem, animationTime / 1000, {
          y: 0,
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Remove duplicate elements
            $originalItem.first().remove(); // Apply some asynchronism scripts

            $(document).UixApplyAsyncScripts();
          }
        });
      });
    }
    /* 
     ====================================================
     *  Mouse Wheel Method
     ====================================================
     */


    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
  };

  module.components.documentReady.push(module.AJAX_PAGE_LOADER.documentReady);
  return function AJAX_PAGE_LOADER() {
    AJAX_js_classCallCheck(this, AJAX_PAGE_LOADER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/GSAP/ScrollToPlugin.js
function ScrollToPlugin_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ScrollToPlugin_typeof = function _typeof(obj) { return typeof obj; }; } else { ScrollToPlugin_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ScrollToPlugin_typeof(obj); }

/*!
 * VERSION: 1.9.2
 * DATE: 2019-02-07
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

/* eslint-disable */


var _doc = (GSAP_TweenLite["a" /* _gsScope */].document || {}).documentElement,
    _window = GSAP_TweenLite["a" /* _gsScope */],
    _max = function _max(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim,
      body = document.body;
  return element === _window || element === _doc || element === body ? Math.max(_doc[scroll], body[scroll]) - (_window["inner" + dim] || _doc[client] || body[client]) : element[scroll] - element["offset" + dim];
},
    _unwrapElement = function _unwrapElement(value) {
  if (typeof value === "string") {
    value = TweenLite.selector(value);
  }

  if (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {
    value = value[0];
  }

  return value === _window || value.nodeType && value.style ? value : null;
},
    _buildGetter = function _buildGetter(e, axis) {
  //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
  var p = "scroll" + (axis === "x" ? "Left" : "Top");

  if (e === _window) {
    if (e.pageXOffset != null) {
      p = "page" + axis.toUpperCase() + "Offset";
    } else if (_doc[p] != null) {
      e = _doc;
    } else {
      e = document.body;
    }
  }

  return function () {
    return e[p];
  };
},
    _getOffset = function _getOffset(element, container) {
  var rect = _unwrapElement(element).getBoundingClientRect(),
      b = document.body,
      isRoot = !container || container === _window || container === b,
      cRect = isRoot ? {
    top: _doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0),
    left: _doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)
  } : container.getBoundingClientRect(),
      offsets = {
    x: rect.left - cRect.left,
    y: rect.top - cRect.top
  };

  if (!isRoot && container) {
    //only add the current scroll position if it's not the window/body.
    offsets.x += _buildGetter(container, "x")();
    offsets.y += _buildGetter(container, "y")();
  }

  return offsets;
  /*	PREVIOUS
  var rect = _unwrapElement(element).getBoundingClientRect(),
  	isRoot = (!container || container === _window || container === document.body),
  	cRect = (isRoot ? _doc : container).getBoundingClientRect(),
  	offsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};
  if (!isRoot && container) { //only add the current scroll position if it's not the window/body.
  	offsets.x += _buildGetter(container, "x")();
  	offsets.y += _buildGetter(container, "y")();
  }
  return offsets;
  */
},
    _parseVal = function _parseVal(value, target, axis, currentVal) {
  var type = ScrollToPlugin_typeof(value);

  return !isNaN(value) ? parseFloat(value) : type === "string" && value.charAt(1) === "=" ? parseInt(value.charAt(0) + "1", 10) * parseFloat(value.substr(2)) + currentVal : value === "max" ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);
},
    ScrollToPlugin = GSAP_TweenLite["a" /* _gsScope */]._gsDefine.plugin({
  propName: "scrollTo",
  API: 2,
  global: true,
  version: "1.9.2",
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function init(target, value, tween) {
    this._wdw = target === _window;
    this._target = target;
    this._tween = tween;

    if (ScrollToPlugin_typeof(value) !== "object") {
      value = {
        y: value
      }; //if we don't receive an object as the parameter, assume the user intends "y".

      if (typeof value.y === "string" && value.y !== "max" && value.y.charAt(1) !== "=") {
        value.x = value.y;
      }
    } else if (value.nodeType) {
      value = {
        y: value,
        x: value
      };
    }

    this.vars = value;
    this._autoKill = value.autoKill !== false;
    this.getX = _buildGetter(target, "x");
    this.getY = _buildGetter(target, "y");
    this.x = this.xPrev = this.getX();
    this.y = this.yPrev = this.getY();

    if (value.x != null) {
      this._addTween(this, "x", this.x, _parseVal(value.x, target, "x", this.x) - (value.offsetX || 0), "scrollTo_x", true);

      this._overwriteProps.push("scrollTo_x");
    } else {
      this.skipX = true;
    }

    if (value.y != null) {
      this._addTween(this, "y", this.y, _parseVal(value.y, target, "y", this.y) - (value.offsetY || 0), "scrollTo_y", true);

      this._overwriteProps.push("scrollTo_y");
    } else {
      this.skipY = true;
    }

    return true;
  },
  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
  set: function set(v) {
    this._super.setRatio.call(this, v);

    var x = this._wdw || !this.skipX ? this.getX() : this.xPrev,
        y = this._wdw || !this.skipY ? this.getY() : this.yPrev,
        yDif = y - this.yPrev,
        xDif = x - this.xPrev,
        threshold = ScrollToPlugin.autoKillThreshold;

    if (this.x < 0) {
      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
      this.x = 0;
    }

    if (this.y < 0) {
      this.y = 0;
    }

    if (this._autoKill) {
      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
      if (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, "x")) {
        this.skipX = true; //if the user scrolls separately, we should stop tweening!
      }

      if (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, "y")) {
        this.skipY = true; //if the user scrolls separately, we should stop tweening!
      }

      if (this.skipX && this.skipY) {
        this._tween.kill();

        if (this.vars.onAutoKill) {
          this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);
        }
      }
    }

    if (this._wdw) {
      _window.scrollTo(!this.skipX ? this.x : x, !this.skipY ? this.y : y);
    } else {
      if (!this.skipY) {
        this._target.scrollTop = this.y;
      }

      if (!this.skipX) {
        this._target.scrollLeft = this.x;
      }
    }

    this.xPrev = this.x;
    this.yPrev = this.y;
  }
}),
    ScrollToPlugin_p = ScrollToPlugin.prototype;

ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;
ScrollToPlugin.autoKillThreshold = 7;

ScrollToPlugin_p._kill = function (lookup) {
  if (lookup.scrollTo_x) {
    this.skipX = true;
  }

  if (lookup.scrollTo_y) {
    this.skipY = true;
  }

  return this._super._kill.call(this, lookup);
};


// EXTERNAL MODULE: ./src/components/back-to-top/scss/_style.scss
var back_to_top_scss_style = __webpack_require__(18);

// CONCATENATED MODULE: ./src/components/back-to-top/js/index.js
function back_to_top_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Back to Top -->
 *************************************
 */



/*var BACK_TO_TOP = function (module, $, window, document) {
  if (window.BACK_TO_TOP === null) return false;
  module.BACK_TO_TOP = module.BACK_TO_TOP || {};
  module.BACK_TO_TOP.version = '0.0.9';

  module.BACK_TO_TOP.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    $('<a href="#" id="uix-to-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></a>').appendTo('body');
    $.when($('#uix-to-top').length > 0).then(function () {
      //-------- Sticky button of back to top 
      //Note: Don't use Waypoint, because the Offset is wrong on calculating height of fixed element
      var $el = $('#uix-to-top');
      $window.off('scroll.BACK_TO_TOP touchmove.BACK_TO_TOP').on('scroll.BACK_TO_TOP touchmove.BACK_TO_TOP', function () {
        var scrolled = $(this).scrollTop(),
            spyTop = windowHeight / 2;

        if (scrolled >= spyTop) {
          $el.addClass('is-active');
        } else {
          $el.removeClass('is-active');
        }
      }); //-------- Click event of back button

      $el.off('click').on('click', function (e) {
        e.preventDefault();
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: 0,
            //y: "max" --> vertical scroll to bottom
            autoKill: false
          },
          ease: Power2.easeOut
        });
        return false;
      });
    });
  };

  module.components.documentReady.push(module.BACK_TO_TOP.documentReady);
  return function BACK_TO_TOP() {
    back_to_top_js_classCallCheck(this, BACK_TO_TOP);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/circle-layout/scss/_style.scss
var circle_layout_scss_style = __webpack_require__(19);

// CONCATENATED MODULE: ./src/components/circle-layout/js/index.js
function circle_layout_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function circle_layout_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { circle_layout_js_typeof = function _typeof(obj) { return typeof obj; }; } else { circle_layout_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return circle_layout_js_typeof(obj); }

/* 
 *************************************
 * <!-- Circle Layout -->
 *************************************
 */


var CIRCLE_LAYOUT = function (module, $, window, document) {
  if (window.CIRCLE_LAYOUT === null) return false;
  module.CIRCLE_LAYOUT = module.CIRCLE_LAYOUT || {};
  module.CIRCLE_LAYOUT.version = '0.0.1';

  module.CIRCLE_LAYOUT.documentReady = function ($) {
    $('.js-uix-circle-layout').each(function (id) {
      var $this = $(this);
      var $ul = $this.find('> ul'),
          $li = $ul.find('> li'),
          liWidth = $li.first().outerWidth(),
          liHeight = $li.first().outerHeight();
      var display = $this.data('circle-layout-display'),
          radius = $this.data('circle-layout-radius'),
          radius2 = $this.data('circle-layout-radius-c'),
          rotation = $this.data('circle-layout-rotation');

      if (circle_layout_js_typeof(display) === ( true ? "undefined" : undefined)) {
        display = 5;
      }

      if (circle_layout_js_typeof(radius) === ( true ? "undefined" : undefined)) {
        radius = 180;
      }

      if (circle_layout_js_typeof(radius2) === ( true ? "undefined" : undefined)) {
        radius2 = 110;
      }

      if (circle_layout_js_typeof(rotation) === ( true ? "undefined" : undefined)) {
        rotation = 0;
      }

      $this.css({
        'width': radius * 2 + 'px'
      });
      $ul.css({
        'width': radius * 2 + 'px',
        'height': radius * 2 + 'px',
        'transform': 'rotate(' + parseFloat(rotation) + 'deg)'
      });
      $ul.next('div').css({
        'width': radius2 * 2 + 'px',
        'height': radius2 * 2 + 'px'
      }); //Layout components in a circle layout

      var step = 2 * Math.PI / display,
          pad = $ul.width();
      var angle = 0,
          transitionDelay = 0;
      $li.each(function () {
        //Can'nt use arrow function here!!!
        // 'this' works differently with arrow fucntions
        var el = $(this),
            x = radius * Math.cos(angle) - liWidth / 2,
            y = radius * Math.sin(angle) - liHeight / 2;
        el.css({
          'transform': 'translate(' + parseFloat(x + liWidth / 2) + 'px,' + parseFloat(pad / 2 + y + liHeight / 2) + 'px)',
          'transition-delay': transitionDelay + "s"
        }).find('> a').css({
          'transform': 'rotate(' + parseFloat(-rotation) + 'deg)'
        });
        angle += step;
        transitionDelay += 0.15;
      });
    });
  };

  module.components.documentReady.push(module.CIRCLE_LAYOUT.documentReady);
  return function CIRCLE_LAYOUT() {
    circle_layout_js_classCallCheck(this, CIRCLE_LAYOUT);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/counter/js/fn/count-to.js
var count_to = __webpack_require__(20);

// EXTERNAL MODULE: ./src/components/counter/scss/_style.scss
var counter_scss_style = __webpack_require__(21);

// CONCATENATED MODULE: ./src/components/counter/js/index.js
function counter_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function counter_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { counter_js_typeof = function _typeof(obj) { return typeof obj; }; } else { counter_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return counter_js_typeof(obj); }

/* 
 *************************************
 * <!-- Counter -->
 *************************************
 */



var COUNTER = function (module, $, window, document) {
  if (window.COUNTER === null) return false;
  module.COUNTER = module.COUNTER || {};
  module.COUNTER.version = '0.0.4';

  module.COUNTER.documentReady = function ($) {
    var $scrollElements = $('[data-counter-number]');
    $(window).off('scroll.COUNTER touchmove.COUNTER');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this); //

      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if (counter_js_typeof(actived) === ( true ? "undefined" : undefined)) {
            $el.UixCountTo(); //Prevents front-end javascripts that are activated in the background to repeat loading.

            $el.data('activated', 1);
          } //endif actived

        }
      };

      scrollUpdate(); // Please do not use scroll's off method in each

      $(window).on('scroll.COUNTER touchmove.COUNTER', function (event) {
        scrollUpdate();
      });
    }); //end each        
  };

  module.components.documentReady.push(module.COUNTER.documentReady);
  return function COUNTER() {
    counter_js_classCallCheck(this, COUNTER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/dropdown-menu/scss/_style.scss
var dropdown_menu_scss_style = __webpack_require__(22);

// CONCATENATED MODULE: ./src/components/dropdown-menu/js/index.js
function dropdown_menu_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dropdown_menu_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dropdown_menu_js_typeof = function _typeof(obj) { return typeof obj; }; } else { dropdown_menu_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dropdown_menu_js_typeof(obj); }

/* 
 *************************************
 * <!-- Dropdown Menu -->
 *************************************
 */


var DROPDOWN_MENU = function (module, $, window, document) {
  if (window.DROPDOWN_MENU === null) return false;
  module.DROPDOWN_MENU = module.DROPDOWN_MENU || {};
  module.DROPDOWN_MENU.version = '0.0.7';

  module.DROPDOWN_MENU.documentReady = function ($) {
    //Initialize option status
    $('.uix-dropdown-menu').each(function () {
      var v = $(this).find('input[type="hidden"]').val(),
          selectedIndex = $(this).find('ul > li > a[data-value="' + v + '"]').parent().index(),
          $li = $(this).find('ul > li');
      $li.removeClass('is-active');
      $li.eq(selectedIndex).addClass('is-active');
      $(this).find('> summary > span').html($li.eq(selectedIndex).find('> a').data('display-text'));
    }); //Create a trigger of Dropdown Menu on Click
    //Use $( document ) to support other click events for ajax

    $(document).off('click.DROPDOWN_MENU').on('click.DROPDOWN_MENU', '.uix-dropdown-menu > summary', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).parent('.uix-dropdown-menu');
      $this.toggleClass('is-opened');
    });
    $(document).off('click.DROPDOWN_MENU_LINK').on('click.DROPDOWN_MENU_LINK', '.uix-dropdown-menu li a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).closest('.uix-dropdown-menu');

      if ($this.hasClass('is-opened')) {
        $this.removeAttr('open').removeClass('is-opened');
      }

      if (dropdown_menu_js_typeof($(this).attr('data-value')) != ( true ? "undefined" : undefined) && $(this).attr('data-value') != '') {
        $this.find('input[type="hidden"]').val($(this).attr('data-value'));
      }

      if (dropdown_menu_js_typeof($(this).data('display-text')) != ( true ? "undefined" : undefined) && $(this).data('display-text') != '') {
        $this.find('> summary > span').html($(this).data('display-text'));
      } // update active status


      $this.find('li').removeClass('is-active');
      $(this).parent().addClass('is-active');
    }); //Close the target
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      //Apply click method to outer div but not inner div
      if (!$(e.target.offsetParent).hasClass('uix-dropdown-menu')) {
        $('.uix-dropdown-menu').removeAttr('open').removeClass('is-opened');
      }
    });
  };

  module.components.documentReady.push(module.DROPDOWN_MENU.documentReady);
  return function DROPDOWN_MENU() {
    dropdown_menu_js_classCallCheck(this, DROPDOWN_MENU);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/dropdown-menu2/scss/_style.scss
var dropdown_menu2_scss_style = __webpack_require__(23);

// CONCATENATED MODULE: ./src/components/dropdown-menu2/js/index.js
function dropdown_menu2_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Dropdown Menu 2 (Multi-level drop-down navigation) -->
 *************************************
 */


var DROPDOWN_MENU2 = function (module, $, window, document) {
  if (window.DROPDOWN_MENU2 === null) return false;
  module.DROPDOWN_MENU2 = module.DROPDOWN_MENU2 || {};
  module.DROPDOWN_MENU2.version = '0.0.5';

  module.DROPDOWN_MENU2.documentReady = function ($) {
    var $verticalMenuLi = $('.uix-vertical-menu li');
    $verticalMenuLi.find('> a').off('click').on('click', function (e) {
      var $sub = $(this).next('ul');

      if ($sub.length > 0) {
        e.preventDefault(); //Its value is not a boolean but a string

        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

        if (expanded) {
          //Hide other all sibling <ul> of the selected element
          var $e = $(this).parent('li').siblings().find('> a');
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.next('ul'), 0.5, {
            height: 0
          }); //to open
          // - temporarilty set height:auto
          // - tween from height:0

          TweenMax.set($sub, {
            height: 'auto'
          });
          TweenMax.from($sub, 0.5, {
            height: 0
          });
        } else {
          $(this).removeClass('is-active').attr('aria-expanded', false); //to close

          TweenMax.to($sub, 0.5, {
            height: 0
          });
        }

        return false;
      }
    }); //Add multilevel indicator arrow

    if ($verticalMenuLi.find('> a .uix-vertical-menu__arrow').length == 0) {
      $verticalMenuLi.find('> a').append('<span class="uix-vertical-menu__arrow"></span>');
    }

    $verticalMenuLi.each(function () {
      var len = $(this).find('ul').length;

      if (len == 0) {
        $(this).children('a').children('.uix-vertical-menu__arrow').hide();
      }
    });
  };

  module.components.documentReady.push(module.DROPDOWN_MENU2.documentReady);
  return function DROPDOWN_MENU2() {
    dropdown_menu2_js_classCallCheck(this, DROPDOWN_MENU2);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/form/js/fn/select.js
var fn_select = __webpack_require__(6);

// CONCATENATED MODULE: ./src/components/dynamic-dropdown-list-json/js/index.js
function dynamic_dropdown_list_json_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dynamic_dropdown_list_json_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dynamic_dropdown_list_json_js_typeof = function _typeof(obj) { return typeof obj; }; } else { dynamic_dropdown_list_json_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dynamic_dropdown_list_json_js_typeof(obj); }

/* 
 *************************************
 * <!-- Dynamic Drop Down List from JSON -->
 *************************************
 */


var DYNAMIC_DD_LIST = function (module, $, window, document) {
  if (window.DYNAMIC_DD_LIST === null) return false;
  module.DYNAMIC_DD_LIST = module.DYNAMIC_DD_LIST || {};
  module.DYNAMIC_DD_LIST.version = '0.1.1';

  module.DYNAMIC_DD_LIST.documentReady = function ($) {
    $('[data-ajax-dynamic-dd-json]').each(function () {
      var $this = $(this);
      var ranID = 'dynamic-dd-control-' + UixGUID.create(),
          ID = $this.attr('id');
      var jsonFile = $this.data('ajax-dynamic-dd-json'),
          dataType = $this.data('ajax-dynamic-dd-datatype'),
          method = $this.data('ajax-dynamic-dd-method'),
          paramsWithJson = $this.data('ajax-dynamic-dd-data'),
          placeholderStrArr = $this.data('ajax-dynamic-dd-placeholder-str'),
          controlIDsArr = $this.data('ajax-dynamic-dd-control-ids'),
          appendTemp = $this.data('ajax-dynamic-dd-append-temp'),
          curID;
      if (dynamic_dropdown_list_json_js_typeof(placeholderStrArr) === ( true ? "undefined" : undefined)) placeholderStrArr = [];
      if (dynamic_dropdown_list_json_js_typeof(controlIDsArr) === ( true ? "undefined" : undefined)) controlIDsArr = [];
      if (dynamic_dropdown_list_json_js_typeof(jsonFile) === ( true ? "undefined" : undefined)) jsonFile = '';
      if (dynamic_dropdown_list_json_js_typeof(paramsWithJson) === ( true ? "undefined" : undefined)) paramsWithJson = {};
      if (dynamic_dropdown_list_json_js_typeof(method) === ( true ? "undefined" : undefined)) method = 'POST';
      if (dynamic_dropdown_list_json_js_typeof(appendTemp) === ( true ? "undefined" : undefined)) appendTemp = '';
      if (dynamic_dropdown_list_json_js_typeof(ID) === ( true ? "undefined" : undefined)) $this.attr('id', ranID);
      if (dynamic_dropdown_list_json_js_typeof(dataType) === ( true ? "undefined" : undefined)) dataType = 'category'; // options: category, place

      curID = $this.attr('id'); //Parse the JSON data

      if (jsonFile != '') {
        //Initialize dependent/chained dropdown list
        var dataExist = $this.data('exist');

        if (dynamic_dropdown_list_json_js_typeof(dataExist) === ( true ? "undefined" : undefined) && dataExist != 1) {
          // Add a request or response interceptor
          var axiosInterceptor = axios.interceptors.request.use(function (config) {
            // Do something before request is sent
            //
            return config;
          }, function (error) {
            return Promise.reject(error);
          }); // To send data in the application/x-www-form-urlencoded format instead

          var formData = new FormData();
          var defaultPostData = paramsWithJson;

          for (var k in defaultPostData) {
            formData.append(k, defaultPostData[k]);
          } // Create a request event


          axios({
            timeout: 15000,
            method: method,
            url: jsonFile,
            data: formData,
            responseType: 'json'
          }).then(function (response) {
            var jsonData = response.data; //Recursive and initialized functions
            //------------------------------------

            var initSelectControls = function initSelectControls(selectIndex, nodeName, $select, arr, allControlsLength) {
              //-- Hide or display controls
              var controlView = function controlView() {
                for (var p = 0; p < controlIDsArr.length; p++) {
                  var data = controlIDsArr[p];
                  var curSelInputID = data != null ? controlIDsArr[p].replace('#', '') : data;
                  var curSelWrapperID = curSelInputID + '----select';
                  var isCustomSel = $('#' + curSelWrapperID).hasClass('uix-controls__select');
                  var $curSelWrapper = isCustomSel ? $('#' + curSelWrapperID).parent('.uix-controls__select-wrapper') : $('#' + curSelWrapperID); //hide/display select wrapper

                  if ($('#' + curSelWrapperID).find('select option').length == 0) {
                    $curSelWrapper.hide();
                  } else {
                    $curSelWrapper.show();
                  } //Render the custom select


                  if (isCustomSel) $(document).UixRenderCustomSelect();
                }
              }; //-- Clear the select controls behind       


              var clearAllSelControls = function clearAllSelControls() {
                if (allControlsLength > selectIndex) {
                  for (var i = allControlsLength; i > selectIndex; i--) {
                    var $targetClearSel = $this.find('select').eq(i - 1);
                    var tid = $targetClearSel.closest('.uix-controls').attr('id');
                    var curSelInputID = tid != null ? tid.replace('----select', '') : tid; //Remove options

                    $targetClearSel.empty(); //update a empty value

                    $('#' + curSelInputID).val(''); //Hide or display controls

                    controlView();
                  }
                }
              };

              clearAllSelControls(); //-- Json Infinite Recursion

              if (arr == '') return false; //Empty data sent when the change event is triggered

              if (arr) {
                /*
                console.log( '--------' );
                console.log( '-> target select ID: ' + $select.closest( '.uix-controls' ).attr( 'id' ) );
                console.log( '-> target select data: ' );
                console.log( arr );
                */
                //add empty option
                var emptyOption = '<option value="">' + placeholderStrArr[selectIndex] + '</option>';
                $select.append(emptyOption); //

                for (var i = 0; i < arr.length; i++) {
                  if (arr[i]) {
                    ///////////////////////////////////////
                    //////////////// category /////////////
                    ///////////////////////////////////////
                    if (dataType == 'category') {
                      var _name = arr[i].name;
                      $select.append('<option data-index="' + i + '" value="' + _name + '">' + _name + '</option>');
                    } // endif dataType
                    ///////////////////////////////////////
                    //////////////// place ////////////////
                    /////////////////////////////////////// 


                    if (dataType == 'place') {
                      var _name2 = arr[i].name;

                      if (dynamic_dropdown_list_json_js_typeof(_name2) === ( true ? "undefined" : undefined)) {
                        $select.append('<option data-index="' + i + '" value="' + arr[i] + '">' + arr[i] + '</option>');
                      } else {
                        $select.append('<option data-index="' + i + '" value="' + _name2 + '">' + _name2 + '</option>');
                      }
                    } // endif dataType     

                  }
                } //end for arr  

              } //endif arr
              //-- Hide or display controls


              controlView(); //-- Change Event

              $select.off('change.DYNAMIC_DD_LIST').on('change.DYNAMIC_DD_LIST', function () {
                var curDeep = $(this).find('option:selected').data('index');
                var curVal = $(this[this.selectedIndex]).val();
                var $targetSel = $this.find('select').eq(selectIndex + 1); //update a new value

                var tid = $(this).closest('.uix-controls').attr('id');
                $('#' + (tid != null ? tid.replace('----select', '') : tid)).val(curVal); //Remove options

                if (curVal == '' || curVal == null) {
                  $targetSel.empty();
                } //Hide or display controls


                controlView(); //send new JSON data

                var sendData = arr[curDeep] ? arr[curDeep][nodeName] : '';
                initSelectControls(selectIndex + 1, 'list', $targetSel, sendData, allControlsLength);
              });
            }; // Append the default select control to the container
            //------------------------------------


            for (var p = 0; p < controlIDsArr.length; p++) {
              var data = controlIDsArr[p];
              var curSelInputID = data != null ? controlIDsArr[p].replace('#', '') : data;
              var curSelWrapperID = curSelInputID + '----select';

              if ($('#' + curSelWrapperID).length == 0) {
                $($.parseHTML(appendTemp)).attr('id', curSelWrapperID).appendTo($this);
              }
            } //endfor controlIDsArr 
            // Initialize the selection box
            //------------------------------------


            var lastData = controlIDsArr[controlIDsArr.length - 1];
            var lastSelInputID = lastData != null ? lastData.replace('#', '') : lastData;
            var lastSelWrapperID = lastSelInputID + '-select';
            $.when($('#' + lastSelWrapperID).length > 0).then(function () {
              initSelectControls(0, 'list', $this.find('select').first(), jsonData, controlIDsArr.length); //-- Reset default value and select style

              for (var _p = 0; _p < controlIDsArr.length; _p++) {
                var _data = controlIDsArr[_p];

                var _curSelInputID = _data != null ? controlIDsArr[_p].replace('#', '') : _data;

                var _curSelWrapperID = _curSelInputID + '----select';

                var isCustomSel = $('#' + _curSelWrapperID).hasClass('uix-controls__select');
                var $curSelWrapper = isCustomSel ? $('#' + _curSelWrapperID).parent('.uix-controls__select-wrapper') : $('#' + _curSelWrapperID); //update a new value to select control when the default is not empty

                var defaultVal = $('#' + _curSelInputID).data('default-value');

                if (defaultVal != '' && defaultVal != null) {
                  $('#' + _curSelInputID).val(defaultVal);
                  $curSelWrapper.find('select').val(defaultVal).attr('selected', 'selected').change();
                } //Render the custom select


                if (isCustomSel) {
                  $(document).UixRenderCustomSelect();
                  $curSelWrapper.find('select').attr('selected', 'selected').change();
                }
              }
            });
          })["catch"](function (error) {
            if (error.response) {
              // The request was made and the server responded with a status code
              // that falls out of the range of 2xx
              var status = error.response.status;
              console.log(status);
            } else if (error.request) {
              // The request was made but no response was received
              // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
              // http.ClientRequest in node.js
              console.log(error.request);
            } else {
              // If there was a problem, we need to
              // dispatch the error condition
              console.log(error.message);
            }
          }); // Remove an interceptor later

          axios.interceptors.request.eject(axiosInterceptor); //Prevent the form from being initialized again

          $this.data('exist', 1);
        }
      } // end of jsonFile

    });
  };

  module.components.documentReady.push(module.DYNAMIC_DD_LIST.documentReady);
  return function DYNAMIC_DD_LIST() {
    dynamic_dropdown_list_json_js_classCallCheck(this, DYNAMIC_DD_LIST);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/flexslider/js/third-party/jquery.flexslider.js
var jquery_flexslider = __webpack_require__(24);

// EXTERNAL MODULE: ./src/components/flexslider/scss/_style.scss
var flexslider_scss_style = __webpack_require__(28);

// CONCATENATED MODULE: ./src/components/flexslider/js/index.js
function flexslider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function flexslider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { flexslider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { flexslider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return flexslider_js_typeof(obj); }

/* 
 *************************************
 * <!-- Flexslider (Third-party plugin) -->
 *************************************
 */



var FLEXSLIDER = function (module, $, window, document) {
  if (window.FLEXSLIDER === null) return false;
  module.FLEXSLIDER = module.FLEXSLIDER || {};
  module.FLEXSLIDER.version = '0.1.8';

  module.FLEXSLIDER.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var flexslider = {
      vars: {}
    };
    /*
     * Tiny helper function to add breakpoints.
     *
     * @param  {Number} number           - Number of carousel items that should be visible.
     * @return {Void}
     */

    function getGridSize(number) {
      return window.innerWidth <= 768 ? 1 : number;
    }
    /*
     * Return an event from callback function to each slider.
     *
     * @param  {Element} thisSlider             - The current slider.
     * @param  {Element} sliderWrapper          - The current slider wrapper.
     * @param  {String} fireState              - State of fire asynchronously.
     * @return {Number}                        - Index of current slider .
     */


    function initslides(sliderWrapper, thisSlider, fireState) {
      var prefix = 'uix-flexslider__';
      if (thisSlider.find('.' + prefix + 'item').length == 0) return false;
      var curIndex = thisSlider.currentSlide,
          count = thisSlider.count,
          activeClass = prefix + 'item--active',
          prevClass = activeClass + '-prev',
          nextClass = activeClass + '-next',
          $items = thisSlider.find('.' + prefix + 'item'),
          $current = thisSlider.slides.eq(curIndex),
          $prev = thisSlider.slides.eq(curIndex - 1),
          $next = thisSlider.slides.eq(thisSlider.animatingTo),
          $first = thisSlider.slides.eq(0),
          curHeight = $current.height(),
          dataNhumbs = thisSlider.data('my-nav-thumbs'),
          dataPNThumbs = thisSlider.data('my-prev-next-thumbs'),
          dataTimeline = thisSlider.data('my-nav-timeline'),
          dataCountTotal = thisSlider.data('my-count-total'),
          dataCountCur = thisSlider.data('my-count-now'),
          dataShowItems = thisSlider.data('my-multiple-items'),
          dataShowItemsMove = thisSlider.data('my-multiple-items-move'),
          dataParallax = thisSlider.data('my-parallax');
      if (flexslider_js_typeof(dataPNThumbs) === ( true ? "undefined" : undefined)) dataPNThumbs = false;
      if (flexslider_js_typeof(dataTimeline) === ( true ? "undefined" : undefined)) dataTimeline = false;
      if (flexslider_js_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = false;
      if (flexslider_js_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = false;
      if (flexslider_js_typeof(dataParallax) === ( true ? "undefined" : undefined)) dataParallax = false;
      if (flexslider_js_typeof(dataShowItemsMove) === ( true ? "undefined" : undefined)) dataShowItemsMove = 1; //Total counter selector
      //Current counter selector.

      var countTotalSelector = dataCountTotal ? $(dataCountTotal) : $('.uix-flexslider__mycontrols__count em.count'),
          countCurSelector = dataCountCur ? $(dataCountCur) : $('.uix-flexslider__mycontrols__count em.current'); // Fires when the slider loads the first slide.
      // Fires after each slider animation completes.

      if (fireState == 'start' || fireState == 'after') {
        //Remove the slider loading
        //-------------------------------------
        thisSlider.removeClass(prefix + '-flexslider-loading'); //With Timeline
        //-------------------------------------	

        if (dataTimeline && dataTimeline != '') {
          var curPerMinWidth = curIndex / count * 100 + '%',
              curPerMaxWidth = (curIndex + 1) / count * 100 + '%',
              curTotalWidth = $(dataTimeline).width(); //Fires animation effect of an element width.

          $(dataTimeline).find('> span').css({
            'width': curTotalWidth,
            'transition': 'all ' + parseFloat(thisSlider.vars.slideshowSpeed - thisSlider.vars.animationSpeed) + 'ms linear'
          });
        } //Display Next/Prev image thumbnail in navigation
        //-------------------------------------		


        if (dataPNThumbs && dataPNThumbs != '') {
          var prevIndex = curIndex - 1,
              nextIndex = thisSlider.animatingTo + 1,
              pimg = '',
              nimg = '',
              $plink = $(dataPNThumbs + '> a'),
              $plinkPrev = $plink.filter('.uix-flexslider__mycontrols--thumb__prev'),
              $plinkNext = $plink.filter('.uix-flexslider__mycontrols--thumb__next');
          $plinkPrev.removeClass('is-disabled');
          $plinkNext.removeClass('is-disabled');

          if (!thisSlider.vars.animationLoop) {
            if (prevIndex === -1) $plinkPrev.addClass('is-disabled');
            if (nextIndex === thisSlider.last + 1) $plinkNext.addClass('is-disabled');
          } else {
            if (prevIndex === -1) prevIndex = thisSlider.last;
            if (nextIndex === thisSlider.last + 1) nextIndex = 0;
          } //Get images URL


          pimg = thisSlider.slides.eq(prevIndex).find('img').attr('src');
          nimg = thisSlider.slides.eq(nextIndex).find('img').attr('src');

          if ($(dataPNThumbs).length > 0) {
            $plink.attr('href', 'javascript:void(0);');
            if (flexslider_js_typeof(pimg) != ( true ? "undefined" : undefined)) $plinkPrev.attr('data-goto', prevIndex).find('> span').html('<img src="' + pimg + '" alt="">');
            if (flexslider_js_typeof(nimg) != ( true ? "undefined" : undefined)) $plinkNext.attr('data-goto', nextIndex).find('> span').html('<img src="' + nimg + '" alt="">');
            $plink.off('click').off('click').on('click', function (e) {
              e.preventDefault();
              thisSlider.flexslider(parseInt($(this).attr('data-goto')));
            });
          }
        } // Fires local videos asynchronously with slider switch.
        //-------------------------------------


        videoEmbedInit($items, false);
        videoEmbedInit($current, true); //Auto-restart player if paused after action
        //-------------------------------------

        if (thisSlider.vars.slideshow) {
          if (!thisSlider.playing) {
            thisSlider.play();
          }
        } //Prevent to <a> of page transitions
        //-------------------------------------


        $('a').each(function () {
          var attr = $(this).attr('href');

          if (flexslider_js_typeof(attr) === ( true ? "undefined" : undefined)) {
            $(this).attr('href', '#');
          }
        }); //Thumbnail ControlNav Pattern
        //-------------------------------------

        if (dataNhumbs && dataNhumbs != '') {
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').removeClass('is-active');
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').eq(curIndex).addClass('is-active');
        } //Initialize items background of the slider
        //-------------------------------------


        thisSlider.find('[data-slider-bg]').each(function () {
          $(this).css('background-image', 'url(' + $(this).data('slider-bg') + ')');
        }); //Enable "prettyPhoto" plugin
        //-------------------------------------

        if ($.isFunction($.fn.lightbox)) {
          thisSlider.slides.find("a[rel^='theme-slider-prettyPhoto']").lightbox();
        } //Return an event from callback function to each slider 
        //with dynamic min/max ranges.
        //-------------------------------------


        if (flexslider_js_typeof(dataShowItems) != ( true ? "undefined" : undefined) && dataShowItems != '' && dataShowItems != 0) {
          if (dataShowItemsMove == 1) {
            $items.removeClass(activeClass);
            $items.removeClass(prevClass);
            $items.removeClass(nextClass);

            if (windowWidth <= 768) {
              //Focus slider
              $items.eq(parseFloat(curIndex)).addClass(activeClass);
            } else {
              //Focus slider
              $items.eq(parseFloat(curIndex + 1)).addClass(activeClass); //Previous slider

              $items.eq(parseFloat(curIndex)).addClass(prevClass); //Next slider

              $items.eq(parseFloat(curIndex + 2)).addClass(nextClass);
            }
          } else {
            $items.addClass(activeClass);
          }
        } //Display counter
        //-------------------------------------


        if (sliderWrapper.find('.uix-flexslider__mycontrols__count').length == 0) {
          if (sliderWrapper.closest('section').find('.uix-flexslider__mycontrols__count').length > 0) {
            var showCountTotal = count,
                showCountCur = curIndex + 1;
            if (showCountTotal < 10) showCountTotal = '0' + showCountTotal;
            if (showCountCur < 10) showCountCur = '0' + showCountCur;
            countTotalSelector.text(showCountTotal);
            countCurSelector.text(showCountCur);
          }
        }
      } // Fires asynchronously with each slider animation.


      if (fireState == 'before') {
        //Common images style
        //-------------------------------------	
        $next.find('img').addClass('is-active');
        $current.find('img').removeClass('is-active');
        $prev.find('img').removeClass('is-active');
        $first.find('img').removeClass('is-active'); //With Timeline
        //-------------------------------------	

        if (dataTimeline && dataTimeline != '') {
          //Fires animation effect of an element width.
          $(dataTimeline).find('> span').css({
            'width': 0,
            'transition': 'all 100ms linear'
          });
        }
      } // Fires when the slider reaches the last slide (asynchronous).


      if (fireState == 'end') {
        //Common images style
        //-------------------------------------	
        $first.find('img').addClass('is-active');
      } // Fires asynchronously with each slider animation.
      // Fires when the slider loads the first slide.


      if (fireState == 'before' || fireState == 'start') {
        //Return an event from callback function to each slider to make parallax effect.
        //-------------------------------------
        if (dataParallax) {
          var dir = 'uix-flexslider__item--left';
          $.each(thisSlider.slides, function (i, item) {
            var el = $(item);
            el.removeClass('uix-flexslider__item--right uix-flexslider__item--left');

            if (i >= thisSlider.animatingTo && dir !== 'uix-flexslider__item--right') {
              dir = 'uix-flexslider__item--right';
            } else {
              el.addClass(dir);
            }
          });
        }
      }

      return curIndex;
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function videoEmbedInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('[data-embed-video-wrapper]').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if (flexslider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) {
          dataAuto = true;
        }

        if (flexslider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) {
          dataLoop = true;
        }

        if (flexslider_js_typeof(dataControls) === ( true ? "undefined" : undefined)) {
          dataControls = false;
        }

        if (flexslider_js_typeof(dataW) === ( true ? "undefined" : undefined) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if (flexslider_js_typeof(dataH) === ( true ? "undefined" : undefined) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            //this.muted( true ); 
            //Prevent autoplay error: Uncaught (in promise) DOMException
            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
    /*
     * Make slider image draggable 
     *
     * @param  {Element} $obj             - The current FlexSlider setup using custom selector.
     * @return {Void}
     */


    function slidesExDraggable($obj) {
      var $dragDropTrigger = $obj.find('.uix-flexslider__inner > div.uix-flexslider__item'); //Make the cursor a move icon when a user hovers over an item

      $dragDropTrigger.css('cursor', 'move'); //Mouse event

      $dragDropTrigger.on('mousedown', function (e) {
        e.preventDefault();

        if ($obj.data('flexslider').animating) {
          return;
        }

        $(this).addClass('is-dragging');
        $(this).data('origin_mouse_x', parseInt(e.pageX));
        $(this).data('origin_mouse_y', parseInt(e.pageY));
      }).on('mouseup', function (e) {
        e.preventDefault();

        if ($obj.data('flexslider').animating) {
          return;
        }

        $(this).removeClass('is-dragging');
        var origin_mouse_x = $(this).data('origin_mouse_x'),
            origin_mouse_y = $(this).data('origin_mouse_y');

        if ('horizontal' === $obj.data('flexslider').vars.direction) {
          //right
          if (e.pageX > origin_mouse_x) {
            $obj.flexslider('prev');
          } //left


          if (e.pageX < origin_mouse_x) {
            $obj.flexslider('next');
          }
        } else {
          //down
          if (e.pageY > origin_mouse_y) {
            $obj.flexslider('prev');
          } //up


          if (e.pageY < origin_mouse_y) {
            $obj.flexslider('next');
          }
        }
      });
    }
    /*
     *  Scroll The Slider With Mousewheel
     *
     * @param  {Element} $obj            - The current FlexSlider setup using custom selector.
     * @return {Void}
     */


    function slidesExMousewheel($obj) {
      var timer = null,
          wheeling = false;
      $obj[0].addEventListener('wheel', function (e) {
        //Gets a value that indicates the amount that the mouse wheel has changed.
        var delta = Math.max(-1, Math.min(1, -e.deltaY));

        if (timer) {
          clearTimeout(timer);
        }

        if (!wheeling) {
          if (delta < 0) {
            //scroll down
            $obj.flexslider('next');
          } else {
            //scroll up
            $obj.flexslider('prev');
          }
        }

        wheeling = true;
        timer = setTimeout(function () {
          wheeling = false;
        }, 60);
      }, browser.supportsPassive ? {
        passive: true
      } : false);
    }
    /*
     * Slider With Thumbnail ControlNav Pattern
     *
     * @param  {Element} slider           - The current slider.
     * @param  {String} navThumbClass    - Class name of thumbnail controlNav.
     * @return {Void}
     */


    function initslidesWithNavThumb(slider, navThumbClass) {
      $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').off('click').on('click', function () {
        $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').removeClass('is-active');
        $(this).addClass('is-active');
        slider.flexslider($(this).index());
      });
    }
    /*
    * Method that updates children slides
    * fortunately, since all the children are not animating,
    * they will only update if the main flexslider updates. 
     *
     * @param  {Number} slideNumber          - The current slider index.
     * @param  {Element} childrenSlidesObj    - Target slider.
     * @param  {Boolean} loop                - Gives the slider a seamless infinite loop.
     * @param  {Number} speed                - Set the speed of animations, in milliseconds.
     * @param  {Number} timing               - Set the speed of the slideshow cycling, in milliseconds.
     * @return {Void}
     */


    function updateChildrenSlides(slideNumber, childrenSlidesObj, loop, speed, timing) {
      /** 
      * Create the children flexsliders. Must be array of jquery objects with the
      * flexslider data. Easiest way is to place selector group in a var.
      */
      var childrenSlides = $(childrenSlidesObj).flexslider({
        slideshow: false,
        // Remove the animations
        controlNav: false,
        // Remove the controls
        animationLoop: loop,
        animationSpeed: speed,
        slideshowSpeed: timing
      }); // Iterate through the children slides but not past the max

      for (var i = 0; i < childrenSlides.length; i++) {
        // Run the animate method on the child slide
        $(childrenSlides[i]).data('flexslider').flexAnimate(slideNumber);
      }
    }
    /*! 
     ---------------------------
           Initialize slideshow
     ---------------------------
     */


    var $sliderDefault = $('.uix-flexslider');
    $sliderDefault.each(function () {
      var $this = $(this);
      var dataSpeed = $this.data('speed'),
          dataDrag = $this.data('draggable'),
          dataWheel = $this.data('wheel'),
          dataTiming = $this.data('timing'),
          dataLoop = $this.data('loop'),
          dataPrev = $this.data('prev'),
          dataNext = $this.data('next'),
          dataAnim = $this.data('animation'),
          dataPaging = $this.data('paging'),
          dataArrows = $this.data('arrows'),
          dataAuto = $this.data('auto'),
          dataNhumbs = $this.data('my-nav-thumbs'),
          dataPNThumbs = $this.data('my-prev-next-thumbs'),
          dataTimeline = $this.data('my-nav-timeline'),
          dataCountTotal = $this.data('my-count-total'),
          dataCountCur = $this.data('my-count-now'),
          customConID = $this.data('my-controls'),
          dataShowItems = $this.data('my-multiple-items'),
          dataShowItemsMove = $this.data('my-multiple-items-move'),
          dataParallax = $this.data('my-parallax'),
          dataSync = $this.data('my-sync'); //Fires local videos asynchronously with slider switch.

      videoEmbedInit($this.find('.uix-flexslider__item'), false); // Custom Controls

      var myControlsContainer, myCustomDirectionNav;

      if (flexslider_js_typeof(customConID) === ( true ? "undefined" : undefined) || customConID == '' || customConID == false) {
        myControlsContainer = '';
        myCustomDirectionNav = '';
      } else {
        myControlsContainer = $('.uix-flexslider__mycontrols' + customConID + ' .uix-flexslider__mycontrols__control-paging');
        myCustomDirectionNav = $('.uix-flexslider__mycontrols' + customConID + ' a');
      } // If there is no data-xxx, save current source to it


      if (flexslider_js_typeof(dataSpeed) === ( true ? "undefined" : undefined)) dataSpeed = 600;
      if (flexslider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
      if (flexslider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = true;
      if (flexslider_js_typeof(dataPrev) === ( true ? "undefined" : undefined)) dataPrev = "<i class='fa fa-chevron-left'></i>";
      if (flexslider_js_typeof(dataNext) === ( true ? "undefined" : undefined)) dataNext = "<i class='fa fa-chevron-right'></i>";
      if (flexslider_js_typeof(dataAnim) === ( true ? "undefined" : undefined)) dataAnim = 'slide';
      if (flexslider_js_typeof(dataPaging) === ( true ? "undefined" : undefined)) dataPaging = true;
      if (flexslider_js_typeof(dataArrows) === ( true ? "undefined" : undefined)) dataArrows = true;
      if (flexslider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = true;
      if (flexslider_js_typeof(dataDrag) === ( true ? "undefined" : undefined)) dataDrag = false;
      if (flexslider_js_typeof(dataWheel) === ( true ? "undefined" : undefined)) dataWheel = false;
      if (flexslider_js_typeof(dataNhumbs) === ( true ? "undefined" : undefined)) dataNhumbs = false;
      if (flexslider_js_typeof(dataPNThumbs) === ( true ? "undefined" : undefined)) dataPNThumbs = false;
      if (flexslider_js_typeof(dataTimeline) === ( true ? "undefined" : undefined)) dataTimeline = false;
      if (flexslider_js_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = false;
      if (flexslider_js_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = false;
      if (flexslider_js_typeof(dataParallax) === ( true ? "undefined" : undefined)) dataParallax = false;
      if (flexslider_js_typeof(dataShowItemsMove) === ( true ? "undefined" : undefined)) dataShowItemsMove = 1; //Make slider image draggable 

      if (dataDrag) slidesExDraggable($this); //Scroll The Slider With Mousewheel

      if (dataWheel) slidesExMousewheel($this); //With Thumbnail ControlNav Pattern

      if (dataNhumbs) {
        initslidesWithNavThumb($this, dataNhumbs); //Prevent index error

        dataLoop = false;
      } //Show number of items


      var my_itemWidth = 0,
          my_move = dataShowItemsMove,
          my_minItems = 0,
          my_maxItems = 0;

      if (flexslider_js_typeof(dataShowItems) != ( true ? "undefined" : undefined) && dataShowItems != '' && dataShowItems != 0) {
        my_itemWidth = 1;
        my_minItems = getGridSize(dataShowItems);
        my_maxItems = getGridSize(dataShowItems);
      } // Determine if this slider is added with a synchronization event


      $('[data-my-sync]').each(function () {
        var curSync = $(this).data('my-sync');
        var thisSliderID = $this.attr('id');

        if (flexslider_js_typeof(curSync) != ( true ? "undefined" : undefined)) {
          curSync = curSync.toString().replace('#', '').replace('.', '');
        }

        if (flexslider_js_typeof(thisSliderID) != ( true ? "undefined" : undefined) && thisSliderID == curSync) {
          dataAuto = false; //Set it not to scroll automatically

          dataPaging = false; // break out of jQuery each Loop

          return false;
        }
      });
      $this.flexslider({
        namespace: 'uix-flexslider__',
        animation: dataAnim,
        selector: '.uix-flexslider__inner > div.uix-flexslider__item',
        controlNav: dataPaging,
        smoothHeight: true,
        prevText: dataPrev,
        nextText: dataNext,
        animationSpeed: dataSpeed,
        slideshowSpeed: dataTiming,
        slideshow: dataAuto,
        animationLoop: dataLoop,
        directionNav: dataArrows,
        itemWidth: my_itemWidth,
        move: my_move,
        // Number of carousel items that should move on animation.
        minItems: my_minItems,
        // use function to pull in initial value
        maxItems: my_maxItems,
        // use function to pull in initial value
        controlsContainer: myControlsContainer,
        customDirectionNav: myCustomDirectionNav,
        //Fires when the slider loads the first slide.
        start: function start(slider) {
          //set slider instance to flexslider variable
          if (flexslider_js_typeof(dataShowItems) != ( true ? "undefined" : undefined) && dataShowItems != '' && dataShowItems != 0) {
            flexslider = slider;
          }

          initslides($this, slider, 'start');
        },
        //Fires asynchronously with each slider animation.
        before: function before(slider) {
          initslides($this, slider, 'before'); // Call the updateChildrenSlides which itterates through all children slides 

          if (flexslider_js_typeof(dataSync) != ( true ? "undefined" : undefined) && dataSync != '' && dataSync != 0) {
            updateChildrenSlides(slider.animatingTo, dataSync, dataLoop, dataSpeed, dataTiming);
          }
        },
        //Fires after each slider animation completes.
        after: function after(slider) {
          initslides($this, slider, 'after');
        },
        //Fires when the slider reaches the last slide (asynchronous).
        end: function end(slider) {
          initslides($this, slider, 'end');
        }
      });
    });
    /*! 
     ---------------------------
           Check grid size on resize event
     ---------------------------
     */

    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        $sliderDefault.each(function () {
          if ($(this).length > 0) {
            // check grid size on resize event
            var dataShowItems = $(this).data('my-multiple-items');

            if (flexslider_js_typeof(dataShowItems) != ( true ? "undefined" : undefined) && dataShowItems != '' && dataShowItems != 0) {
              var gridSize = getGridSize(dataShowItems);
              flexslider.vars.minItems = gridSize;
              flexslider.vars.maxItems = gridSize;
            }

            $(this).data('flexslider').setup();
          }
        });
      }
    });
  };

  module.components.documentReady.push(module.FLEXSLIDER.documentReady);
  return function FLEXSLIDER() {
    flexslider_js_classCallCheck(this, FLEXSLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/floating-side-element/scss/_style.scss
var floating_side_element_scss_style = __webpack_require__(29);

// CONCATENATED MODULE: ./src/components/floating-side-element/js/index.js
function floating_side_element_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Floating Side Element -->
 *************************************
 */


var FLOATING_SIDE_EL = function (module, $, window, document) {
  if (window.FLOATING_SIDE_EL === null) return false;
  module.FLOATING_SIDE_EL = module.FLOATING_SIDE_EL || {};
  module.FLOATING_SIDE_EL.version = '0.0.6';

  module.FLOATING_SIDE_EL.documentReady = function ($) {
    var documentHeight = 0,
        $floatingSideEl = $('.uix-floating-side-el'),
        floatingOffset = $floatingSideEl.offset(); //Prevent this module from loading in other pages

    if ($floatingSideEl.length == 0) return false;
    documentHeight = $(document).height(); //Init position

    TweenMax.to($floatingSideEl, 0.3, {
      css: {
        marginTop: -floatingOffset.top + ($(window).height() - $floatingSideEl.height()) / 2
      }
    });
    $(window).off('scroll.FLOATING_SIDE_EL touchmove.FLOATING_SIDE_EL').on('scroll.FLOATING_SIDE_EL touchmove.FLOATING_SIDE_EL', function () {
      var sideBarHeight = $floatingSideEl.height(),
          scrolled = $(this).scrollTop();
      documentHeight = $(document).height();

      if (scrolled > floatingOffset.top) {
        var newPosition = scrolled - floatingOffset.top,
            maxPosition = documentHeight - sideBarHeight;

        if (newPosition > maxPosition) {
          newPosition = maxPosition;
        }

        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: newPosition + (window.innerHeight - sideBarHeight) / 2
          }
        });
      } else {
        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: 0
          }
        });
      }
    });
  };

  module.components.documentReady.push(module.FLOATING_SIDE_EL.documentReady);
  return function FLOATING_SIDE_EL() {
    floating_side_element_js_classCallCheck(this, FLOATING_SIDE_EL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/form-progress/js/fn/form-progress-to-next.js
var form_progress_to_next = __webpack_require__(30);

// EXTERNAL MODULE: ./src/components/form-progress/scss/_style.scss
var form_progress_scss_style = __webpack_require__(31);

// CONCATENATED MODULE: ./src/components/form-progress/js/index.js
function form_progress_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function form_progress_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { form_progress_js_typeof = function _typeof(obj) { return typeof obj; }; } else { form_progress_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return form_progress_js_typeof(obj); }

/* 
 *************************************
 * <!-- Form Progress -->
 *************************************
 */

/*
    Note:
	
	If you want to initialize the indicator to a location when the page is first run,
	you need to call the following function:
	
	$( 'body' ).waitForImages().done(function() {
		$( document ).UixFormProgressToNext({ 
			'selector'         : $( '.uix-form-progress__target .uix-form-progress__target__step' ),
			'formTarget'       : $( '.uix-form-progress__target' ),
			'indicator'        : '.uix-form-progress .uix-form-progress__indicator',
			'index'            : 0
		});
	});


*/




var FORM_PROGRESS = function (module, $, window, document) {
  if (window.FORM_PROGRESS === null) return false;
  module.FORM_PROGRESS = module.FORM_PROGRESS || {};
  module.FORM_PROGRESS.version = '0.0.5';

  module.FORM_PROGRESS.pageLoaded = function () {
    var $progressBar = $('.uix-form-progress progress'),
        $formTarget = $('.uix-form-progress__target'),
        $indicator = $('.uix-form-progress .uix-form-progress__indicator'),
        formAreaH = $formTarget.height(),
        allStep = $indicator.length,
        stepPerValue = 100 / (allStep - 1),
        value = 0,
        transitionEnd = 'webkitTransitionEnd transitionend'; //Get form transition speed

    var dur = $formTarget.data('anime-speed');

    if (form_progress_js_typeof(dur) === ( true ? "undefined" : undefined)) {
      dur = '0.5s';
    }

    var durString = dur.toString().toLowerCase(),
        isMS = durString.indexOf('ms') >= 0,
        numberNum = durString.replace('ms', '').replace('s', ''),
        animeSpeed = isMS ? numberNum : numberNum * 1000; //Gets the party started.

    formReset(); //Display the target

    setTimeout(function () {
      $formTarget.addClass('is-active');
    }, parseFloat(dur) * 1000); // Show next form on continue click

    $(document).off('click.FORM_PROGRESS').on('click.FORM_PROGRESS', '.uix-form-progress__target .go-step:not(.disable)', function (e) {
      e.preventDefault();
      var $sections = $(this).parents('.uix-form-progress__target__step');
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $formTarget,
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': $sections.index() + 1
      }); //Scroll Top

      TweenMax.to(window, 0.5, {
        scrollTo: {
          y: 0,
          autoKill: false
        },
        ease: Power2.easeOut
      });
    }); // Reset form on reset button click

    $(document).off('click.FORM_PROGRESS_RESET').on('click.FORM_PROGRESS_RESET', '.uix-form-progress__target .go-reset', function (e) {
      e.preventDefault();
      formReset();
    });
    /*
     * Resets the form back to the default state.
     *
     * @return {Void}
     */

    function formReset() {
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $('.uix-form-progress__target'),
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': 0
      });
    }
  };

  module.components.pageLoaded.push(module.FORM_PROGRESS.pageLoaded);
  return function FORM_PROGRESS() {
    form_progress_js_classCallCheck(this, FORM_PROGRESS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/form/js/fn/normal-radio.js
var normal_radio = __webpack_require__(32);

// EXTERNAL MODULE: ./src/components/form/js/third-party/jquery.mousewheel.esm.js
var jquery_mousewheel_esm = __webpack_require__(33);

// CONCATENATED MODULE: ./src/components/form/js/third-party/jquery.datetimepicker.esm.js
function jquery_datetimepicker_esm_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { jquery_datetimepicker_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { jquery_datetimepicker_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return jquery_datetimepicker_esm_typeof(obj); }


/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2016
 * @version 1.3.4
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */

var DateFormatter;
!function () {
  "use strict";

  var t, _e, _r, n, a, u, i;

  u = 864e5, i = 3600, t = function t(_t, e) {
    return "string" == typeof _t && "string" == typeof e && _t.toLowerCase() === e.toLowerCase();
  }, _e = function e(t, r, n) {
    var a = n || "0",
        u = t.toString();
    return u.length < r ? _e(a + u, r) : u;
  }, _r = function r(t) {
    var e, n;

    for (t = t || {}, e = 1; e < arguments.length; e++) {
      if (n = arguments[e]) for (var a in n) {
        n.hasOwnProperty(a) && ("object" == jquery_datetimepicker_esm_typeof(n[a]) ? _r(t[a], n[a]) : t[a] = n[a]);
      }
    }

    return t;
  }, n = function n(t, e) {
    for (var r = 0; r < e.length; r++) {
      if (e[r].toLowerCase() === t.toLowerCase()) return r;
    }

    return -1;
  }, a = {
    dateSettings: {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      meridiem: ["AM", "PM"],
      ordinal: function ordinal(t) {
        var e = t % 10,
            r = {
          1: "st",
          2: "nd",
          3: "rd"
        };
        return 1 !== Math.floor(t % 100 / 10) && r[e] ? r[e] : "th";
      }
    },
    separators: /[ \-+\/\.T:@]/g,
    validParts: /[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,
    intParts: /[djwNzmnyYhHgGis]/g,
    tzParts: /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    tzClip: /[^-+\dA-Z]/g
  }, DateFormatter = function DateFormatter(t) {
    var e = this,
        n = _r(a, t);

    e.dateSettings = n.dateSettings, e.separators = n.separators, e.validParts = n.validParts, e.intParts = n.intParts, e.tzParts = n.tzParts, e.tzClip = n.tzClip;
  }, DateFormatter.prototype = {
    constructor: DateFormatter,
    getMonth: function getMonth(t) {
      var e,
          r = this;
      return e = n(t, r.dateSettings.monthsShort) + 1, 0 === e && (e = n(t, r.dateSettings.months) + 1), e;
    },
    parseDate: function parseDate(e, r) {
      var n,
          a,
          u,
          i,
          s,
          o,
          c,
          f,
          l,
          h,
          d = this,
          g = !1,
          m = !1,
          p = d.dateSettings,
          y = {
        date: null,
        year: null,
        month: null,
        day: null,
        hour: 0,
        min: 0,
        sec: 0
      };
      if (!e) return null;
      if (e instanceof Date) return e;
      if ("U" === r) return u = parseInt(e), u ? new Date(1e3 * u) : e;

      switch (jquery_datetimepicker_esm_typeof(e)) {
        case "number":
          return new Date(e);

        case "string":
          break;

        default:
          return null;
      }

      if (n = r.match(d.validParts), !n || 0 === n.length) throw new Error("Invalid date format definition.");

      for (a = e.replace(d.separators, "\x00").split("\x00"), u = 0; u < a.length; u++) {
        switch (i = a[u], s = parseInt(i), n[u]) {
          case "y":
          case "Y":
            if (!s) return null;
            l = i.length, y.year = 2 === l ? parseInt((70 > s ? "20" : "19") + i) : s, g = !0;
            break;

          case "m":
          case "n":
          case "M":
          case "F":
            if (isNaN(s)) {
              if (o = d.getMonth(i), !(o > 0)) return null;
              y.month = o;
            } else {
              if (!(s >= 1 && 12 >= s)) return null;
              y.month = s;
            }

            g = !0;
            break;

          case "d":
          case "j":
            if (!(s >= 1 && 31 >= s)) return null;
            y.day = s, g = !0;
            break;

          case "g":
          case "h":
            if (c = n.indexOf("a") > -1 ? n.indexOf("a") : n.indexOf("A") > -1 ? n.indexOf("A") : -1, h = a[c], c > -1) f = t(h, p.meridiem[0]) ? 0 : t(h, p.meridiem[1]) ? 12 : -1, s >= 1 && 12 >= s && f > -1 ? y.hour = s + f - 1 : s >= 0 && 23 >= s && (y.hour = s);else {
              if (!(s >= 0 && 23 >= s)) return null;
              y.hour = s;
            }
            m = !0;
            break;

          case "G":
          case "H":
            if (!(s >= 0 && 23 >= s)) return null;
            y.hour = s, m = !0;
            break;

          case "i":
            if (!(s >= 0 && 59 >= s)) return null;
            y.min = s, m = !0;
            break;

          case "s":
            if (!(s >= 0 && 59 >= s)) return null;
            y.sec = s, m = !0;
        }
      }

      if (g === !0 && y.year && y.month && y.day) y.date = new Date(y.year, y.month - 1, y.day, y.hour, y.min, y.sec, 0);else {
        if (m !== !0) return null;
        y.date = new Date(0, 0, 0, y.hour, y.min, y.sec, 0);
      }
      return y.date;
    },
    guessDate: function guessDate(t, e) {
      if ("string" != typeof t) return t;
      var r,
          n,
          a,
          u,
          i,
          s,
          o = this,
          c = t.replace(o.separators, "\x00").split("\x00"),
          f = /^[djmn]/g,
          l = e.match(o.validParts),
          h = new Date(),
          d = 0;
      if (!f.test(l[0])) return t;

      for (a = 0; a < c.length; a++) {
        if (d = 2, i = c[a], s = parseInt(i.substr(0, 2)), isNaN(s)) return null;

        switch (a) {
          case 0:
            "m" === l[0] || "n" === l[0] ? h.setMonth(s - 1) : h.setDate(s);
            break;

          case 1:
            "m" === l[0] || "n" === l[0] ? h.setDate(s) : h.setMonth(s - 1);
            break;

          case 2:
            if (n = h.getFullYear(), r = i.length, d = 4 > r ? r : 4, n = parseInt(4 > r ? n.toString().substr(0, 4 - r) + i : i.substr(0, 4)), !n) return null;
            h.setFullYear(n);
            break;

          case 3:
            h.setHours(s);
            break;

          case 4:
            h.setMinutes(s);
            break;

          case 5:
            h.setSeconds(s);
        }

        u = i.substr(d), u.length > 0 && c.splice(a + 1, 0, u);
      }

      return h;
    },
    parseFormat: function parseFormat(t, r) {
      var n,
          a = this,
          s = a.dateSettings,
          o = /\\?(.?)/gi,
          _c = function c(t, e) {
        return n[t] ? n[t]() : e;
      };

      return n = {
        d: function d() {
          return _e(n.j(), 2);
        },
        D: function D() {
          return s.daysShort[n.w()];
        },
        j: function j() {
          return r.getDate();
        },
        l: function l() {
          return s.days[n.w()];
        },
        N: function N() {
          return n.w() || 7;
        },
        w: function w() {
          return r.getDay();
        },
        z: function z() {
          var t = new Date(n.Y(), n.n() - 1, n.j()),
              e = new Date(n.Y(), 0, 1);
          return Math.round((t - e) / u);
        },
        W: function W() {
          var t = new Date(n.Y(), n.n() - 1, n.j() - n.N() + 3),
              r = new Date(t.getFullYear(), 0, 4);
          return _e(1 + Math.round((t - r) / u / 7), 2);
        },
        F: function F() {
          return s.months[r.getMonth()];
        },
        m: function m() {
          return _e(n.n(), 2);
        },
        M: function M() {
          return s.monthsShort[r.getMonth()];
        },
        n: function n() {
          return r.getMonth() + 1;
        },
        t: function t() {
          return new Date(n.Y(), n.n(), 0).getDate();
        },
        L: function L() {
          var t = n.Y();
          return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0 ? 1 : 0;
        },
        o: function o() {
          var t = n.n(),
              e = n.W(),
              r = n.Y();
          return r + (12 === t && 9 > e ? 1 : 1 === t && e > 9 ? -1 : 0);
        },
        Y: function Y() {
          return r.getFullYear();
        },
        y: function y() {
          return n.Y().toString().slice(-2);
        },
        a: function a() {
          return n.A().toLowerCase();
        },
        A: function A() {
          var t = n.G() < 12 ? 0 : 1;
          return s.meridiem[t];
        },
        B: function B() {
          var t = r.getUTCHours() * i,
              n = 60 * r.getUTCMinutes(),
              a = r.getUTCSeconds();
          return _e(Math.floor((t + n + a + i) / 86.4) % 1e3, 3);
        },
        g: function g() {
          return n.G() % 12 || 12;
        },
        G: function G() {
          return r.getHours();
        },
        h: function h() {
          return _e(n.g(), 2);
        },
        H: function H() {
          return _e(n.G(), 2);
        },
        i: function i() {
          return _e(r.getMinutes(), 2);
        },
        s: function s() {
          return _e(r.getSeconds(), 2);
        },
        u: function u() {
          return _e(1e3 * r.getMilliseconds(), 6);
        },
        e: function e() {
          var t = /\((.*)\)/.exec(String(r))[1];
          return t || "Coordinated Universal Time";
        },
        I: function I() {
          var t = new Date(n.Y(), 0),
              e = Date.UTC(n.Y(), 0),
              r = new Date(n.Y(), 6),
              a = Date.UTC(n.Y(), 6);
          return t - e !== r - a ? 1 : 0;
        },
        O: function O() {
          var t = r.getTimezoneOffset(),
              n = Math.abs(t);
          return (t > 0 ? "-" : "+") + _e(100 * Math.floor(n / 60) + n % 60, 4);
        },
        P: function P() {
          var t = n.O();
          return t.substr(0, 3) + ":" + t.substr(3, 2);
        },
        T: function T() {
          var t = (String(r).match(a.tzParts) || [""]).pop().replace(a.tzClip, "");
          return t || "UTC";
        },
        Z: function Z() {
          return 60 * -r.getTimezoneOffset();
        },
        c: function c() {
          return "Y-m-d\\TH:i:sP".replace(o, _c);
        },
        r: function r() {
          return "D, d M Y H:i:s O".replace(o, _c);
        },
        U: function U() {
          return r.getTime() / 1e3 || 0;
        }
      }, _c(t, t);
    },
    formatDate: function formatDate(t, e) {
      var r,
          n,
          a,
          u,
          i,
          s = this,
          o = "",
          c = "\\";
      if ("string" == typeof t && (t = s.parseDate(t, e), !t)) return null;

      if (t instanceof Date) {
        for (a = e.length, r = 0; a > r; r++) {
          i = e.charAt(r), "S" !== i && i !== c && (r > 0 && e.charAt(r - 1) === c ? o += i : (u = s.parseFormat(i, t), r !== a - 1 && s.intParts.test(i) && "S" === e.charAt(r + 1) && (n = parseInt(u) || 0, u += s.dateSettings.ordinal(n)), o += u));
        }

        return o;
      }

      return "";
    }
  };
}();
/**
* @preserve jQuery DateTimePicker
* @homepage http://xdsoft.net/jqplugins/datetimepicker/
* @author Chupurnov Valeriy (<chupurnov@gmail.com>)
*/

(function ($) {
  'use strict';

  var default_options = {
    i18n: {
      ar: {
        // Arabic
        months: ["كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"],
        dayOfWeekShort: ["ن", "ث", "ع", "خ", "ج", "س", "ح"],
        dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
      },
      ro: {
        // Romanian
        months: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"],
        dayOfWeekShort: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"],
        dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
      },
      id: {
        // Indonesian
        months: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
        dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
      },
      is: {
        // Icelandic
        months: ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"],
        dayOfWeekShort: ["Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"],
        dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
      },
      bg: {
        // Bulgarian
        months: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"],
        dayOfWeekShort: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
      },
      fa: {
        // Persian/Farsi
        months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
        dayOfWeekShort: ['یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'],
        dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
      },
      ru: {
        // Russian
        months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
        dayOfWeekShort: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
      },
      uk: {
        // Ukrainian
        months: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
        dayOfWeekShort: ["Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"],
        dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
      },
      en: {
        // English
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      el: {
        // Ελληνικά
        months: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
        dayOfWeekShort: ["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"],
        dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
      },
      de: {
        // German
        months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
        dayOfWeekShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
      },
      nl: {
        // Dutch
        months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        dayOfWeekShort: ["zo", "ma", "di", "wo", "do", "vr", "za"],
        dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
      },
      tr: {
        // Turkish
        months: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
        dayOfWeekShort: ["Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"],
        dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
      },
      fr: {
        //French
        months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
        dayOfWeekShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
        dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
      },
      es: {
        // Spanish
        months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
        dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
      },
      th: {
        // Thai
        months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
        dayOfWeekShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
        dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
      },
      pl: {
        // Polish
        months: ["styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"],
        dayOfWeekShort: ["nd", "pn", "wt", "śr", "cz", "pt", "sb"],
        dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
      },
      pt: {
        // Portuguese
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      ch: {
        // Simplified Chinese
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"]
      },
      se: {
        // Swedish
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
      },
      km: {
        // Khmer (ភាសាខ្មែរ)
        months: ["មករា​", "កុម្ភៈ", "មិនា​", "មេសា​", "ឧសភា​", "មិថុនា​", "កក្កដា​", "សីហា​", "កញ្ញា​", "តុលា​", "វិច្ឆិកា", "ធ្នូ​"],
        dayOfWeekShort: ["អាទិ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហ​​", "សុក្រ​", "សៅរ៍"],
        dayOfWeek: ["អាទិត្យ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហស្បតិ៍​", "សុក្រ​", "សៅរ៍"]
      },
      kr: {
        // Korean
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      it: {
        // Italian
        months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
        dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
      },
      da: {
        // Dansk
        months: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
      },
      no: {
        // Norwegian
        months: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
      },
      ja: {
        // Japanese
        months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
        dayOfWeekShort: ["日", "月", "火", "水", "木", "金", "土"],
        dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
      },
      vi: {
        // Vietnamese
        months: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
        dayOfWeekShort: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
        dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
      },
      sl: {
        // Slovenščina
        months: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
        dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
      },
      cs: {
        // Čeština
        months: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
        dayOfWeekShort: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"]
      },
      hu: {
        // Hungarian
        months: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
        dayOfWeekShort: ["Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"],
        dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
      },
      az: {
        //Azerbaijanian (Azeri)
        months: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"],
        dayOfWeekShort: ["B", "Be", "Ça", "Ç", "Ca", "C", "Ş"],
        dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
      },
      bs: {
        //Bosanski
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ca: {
        //Català
        months: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
        dayOfWeekShort: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
        dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
      },
      'en-GB': {
        //English (British)
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      et: {
        //"Eesti"
        months: ["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"],
        dayOfWeekShort: ["P", "E", "T", "K", "N", "R", "L"],
        dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
      },
      eu: {
        //Euskara
        months: ["Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"],
        dayOfWeekShort: ["Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."],
        dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
      },
      fi: {
        //Finnish (Suomi)
        months: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
        dayOfWeekShort: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
        dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
      },
      gl: {
        //Galego
        months: ["Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"],
        dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
      },
      hr: {
        //Hrvatski
        months: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ko: {
        //Korean (한국어)
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      lt: {
        //Lithuanian (lietuvių)
        months: ["Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"],
        dayOfWeekShort: ["Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"],
        dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
      },
      lv: {
        //Latvian (Latviešu)
        months: ["Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"],
        dayOfWeekShort: ["Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"],
        dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
      },
      mk: {
        //Macedonian (Македонски)
        months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
        dayOfWeekShort: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
        dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
      },
      mn: {
        //Mongolian (Монгол)
        months: ["1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"],
        dayOfWeekShort: ["Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"],
        dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
      },
      'pt-BR': {
        //Português(Brasil)
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      sk: {
        //Slovenčina
        months: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
        dayOfWeekShort: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"],
        dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
      },
      sq: {
        //Albanian (Shqip)
        months: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"],
        dayOfWeekShort: ["Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"],
        dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
      },
      'sr-YU': {
        //Serbian (Srpski)
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"],
        dayOfWeek: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
      },
      sr: {
        //Serbian Cyrillic (Српски)
        months: ["јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"],
        dayOfWeekShort: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
        dayOfWeek: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
      },
      sv: {
        //Svenska
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
        dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
      },
      'zh-TW': {
        //Traditional Chinese (繁體中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      zh: {
        //Simplified Chinese (简体中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      ug: {
        // Uyghur(ئۇيغۇرچە)
        months: ["1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي"],
        dayOfWeek: ["يەكشەنبە", "دۈشەنبە", "سەيشەنبە", "چارشەنبە", "پەيشەنبە", "جۈمە", "شەنبە"]
      },
      he: {
        //Hebrew (עברית)
        months: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
        dayOfWeekShort: ['א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'],
        dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
      },
      hy: {
        // Armenian
        months: ["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"],
        dayOfWeekShort: ["Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"],
        dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
      },
      kg: {
        // Kyrgyz
        months: ['Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'],
        dayOfWeekShort: ["Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"],
        dayOfWeek: ["Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"]
      },
      rm: {
        // Romansh
        months: ["Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"],
        dayOfWeekShort: ["Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"],
        dayOfWeek: ["Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"]
      },
      ka: {
        // Georgian
        months: ['იანვარი', 'თებერვალი', 'მარტი', 'აპრილი', 'მაისი', 'ივნისი', 'ივლისი', 'აგვისტო', 'სექტემბერი', 'ოქტომბერი', 'ნოემბერი', 'დეკემბერი'],
        dayOfWeekShort: ["კვ", "ორშ", "სამშ", "ოთხ", "ხუთ", "პარ", "შაბ"],
        dayOfWeek: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
      }
    },
    ownerDocument: document,
    contentWindow: window,
    value: '',
    rtl: false,
    format: 'Y/m/d H:i',
    formatTime: 'H:i',
    formatDate: 'Y/m/d',
    startDate: false,
    // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
    step: 60,
    monthChangeSpinner: true,
    closeOnDateSelect: false,
    closeOnTimeSelect: true,
    closeOnWithoutClick: true,
    closeOnInputClick: true,
    openOnFocus: true,
    timepicker: true,
    datepicker: true,
    weeks: false,
    defaultTime: false,
    // use formatTime format (ex. '10:00' for formatTime:	'H:i')
    defaultDate: false,
    // use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')
    minDate: false,
    maxDate: false,
    minTime: false,
    maxTime: false,
    minDateTime: false,
    maxDateTime: false,
    allowTimes: [],
    opened: false,
    initTime: true,
    inline: false,
    theme: '',
    touchMovedThreshold: 5,
    onSelectDate: function onSelectDate() {},
    onSelectTime: function onSelectTime() {},
    onChangeMonth: function onChangeMonth() {},
    onGetWeekOfYear: function onGetWeekOfYear() {},
    onChangeYear: function onChangeYear() {},
    onChangeDateTime: function onChangeDateTime() {},
    onShow: function onShow() {},
    onClose: function onClose() {},
    onGenerate: function onGenerate() {},
    withoutCopyright: true,
    inverseButton: false,
    hours12: false,
    next: 'xdsoft_next',
    prev: 'xdsoft_prev',
    dayOfWeekStart: 0,
    parentID: 'body',
    timeHeightInTimePicker: 25,
    timepickerScrollbar: true,
    todayButton: true,
    prevButton: true,
    nextButton: true,
    defaultSelect: true,
    scrollMonth: true,
    scrollTime: true,
    scrollInput: true,
    lazyInit: false,
    mask: false,
    validateOnBlur: true,
    allowBlank: true,
    yearStart: 1950,
    yearEnd: 2050,
    monthStart: 0,
    monthEnd: 11,
    style: '',
    id: '',
    fixed: false,
    roundTime: 'round',
    // ceil, floor
    className: '',
    weekends: [],
    highlightedDates: [],
    highlightedPeriods: [],
    allowDates: [],
    allowDateRe: null,
    disabledDates: [],
    disabledWeekDays: [],
    yearOffset: 0,
    beforeShowDay: null,
    enterLikeTab: true,
    showApplyButton: false,
    insideParent: false
  };
  var dateHelper = null,
      defaultDateHelper = null,
      globalLocaleDefault = 'en',
      globalLocale = 'en';
  var dateFormatterOptionsDefault = {
    meridiem: ['AM', 'PM']
  };

  var initDateFormatter = function initDateFormatter() {
    var locale = default_options.i18n[globalLocale],
        opts = {
      days: locale.dayOfWeek,
      daysShort: locale.dayOfWeekShort,
      months: locale.months,
      monthsShort: $.map(locale.months, function (n) {
        return n.substring(0, 3);
      })
    };

    if (typeof DateFormatter === 'function') {
      dateHelper = defaultDateHelper = new DateFormatter({
        dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
      });
    }
  };

  var dateFormatters = {
    moment: {
      default_options: {
        format: 'YYYY/MM/DD HH:mm',
        formatDate: 'YYYY/MM/DD',
        formatTime: 'HH:mm'
      },
      formatter: {
        parseDate: function parseDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.parseDate(date, format);
          }

          var d = moment(date, format);
          return d.isValid() ? d.toDate() : false;
        },
        formatDate: function formatDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.formatDate(date, format);
          }

          return moment(date).format(format);
        },
        formatMask: function formatMask(format) {
          return format.replace(/Y{4}/g, '9999').replace(/Y{2}/g, '99').replace(/M{2}/g, '19').replace(/D{2}/g, '39').replace(/H{2}/g, '29').replace(/m{2}/g, '59').replace(/s{2}/g, '59');
        }
      }
    }
  }; // for locale settings

  $.datetimepicker = {
    setLocale: function setLocale(locale) {
      var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;

      if (globalLocale !== newLocale) {
        globalLocale = newLocale; // reinit date formatter

        initDateFormatter();
      }
    },
    setDateFormatter: function setDateFormatter(dateFormatter) {
      if (typeof dateFormatter === 'string' && dateFormatters.hasOwnProperty(dateFormatter)) {
        var df = dateFormatters[dateFormatter];
        $.extend(default_options, df.default_options);
        dateHelper = df.formatter;
      } else {
        dateHelper = dateFormatter;
      }
    }
  };
  var standardFormats = {
    RFC_2822: 'D, d M Y H:i:s O',
    ATOM: 'Y-m-d\TH:i:sP',
    ISO_8601: 'Y-m-d\TH:i:sO',
    RFC_822: 'D, d M y H:i:s O',
    RFC_850: 'l, d-M-y H:i:s T',
    RFC_1036: 'D, d M y H:i:s O',
    RFC_1123: 'D, d M Y H:i:s O',
    RSS: 'D, d M Y H:i:s O',
    W3C: 'Y-m-d\TH:i:sP'
  };

  var isFormatStandard = function isFormatStandard(format) {
    return Object.values(standardFormats).indexOf(format) === -1 ? false : true;
  };

  $.extend($.datetimepicker, standardFormats); // first init date formatter

  initDateFormatter(); // fix for ie8

  if (!window.getComputedStyle) {
    window.getComputedStyle = function (el) {
      this.el = el;

      this.getPropertyValue = function (prop) {
        var re = /(-([a-z]))/g;

        if (prop === 'float') {
          prop = 'styleFloat';
        }

        if (re.test(prop)) {
          prop = prop.replace(re, function (a, b, c) {
            return c.toUpperCase();
          });
        }

        return el.currentStyle[prop] || null;
      };

      return this;
    };
  }

  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (obj, start) {
      var i, j;

      for (i = start || 0, j = this.length; i < j; i += 1) {
        if (this[i] === obj) {
          return i;
        }
      }

      return -1;
    };
  }

  Date.prototype.countDaysInMonth = function () {
    return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
  };

  $.fn.xdsoftScroller = function (options, percent) {
    return this.each(function () {
      var timeboxparent = $(this),
          pointerEventToXY = function pointerEventToXY(e) {
        var out = {
          x: 0,
          y: 0
        },
            touch;

        if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
          touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
          out.x = touch.clientX;
          out.y = touch.clientY;
        } else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
          out.x = e.clientX;
          out.y = e.clientY;
        }

        return out;
      },
          timebox,
          parentHeight,
          height,
          scrollbar,
          scroller,
          maximumOffset = 100,
          start = false,
          startY = 0,
          startTop = 0,
          h1 = 0,
          touchStart = false,
          startTopScroll = 0,
          calcOffset = function calcOffset() {};

      if (percent === 'hide') {
        timeboxparent.find('.xdsoft_scrollbar').hide();
        return;
      }

      if (!$(this).hasClass('xdsoft_scroller_box')) {
        timebox = timeboxparent.children().eq(0);
        parentHeight = timeboxparent[0].clientHeight;
        height = timebox[0].offsetHeight;
        scrollbar = $('<div class="xdsoft_scrollbar"></div>');
        scroller = $('<div class="xdsoft_scroller"></div>');
        scrollbar.append(scroller);
        timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);

        calcOffset = function calcOffset(event) {
          var offset = pointerEventToXY(event).y - startY + startTopScroll;

          if (offset < 0) {
            offset = 0;
          }

          if (offset + scroller[0].offsetHeight > h1) {
            offset = h1 - scroller[0].offsetHeight;
          }

          timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
        };

        scroller.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
          }

          startY = pointerEventToXY(event).y;
          startTopScroll = parseInt(scroller.css('margin-top'), 10);
          h1 = scrollbar[0].offsetHeight;

          if (event.type === 'mousedown' || event.type === 'touchstart') {
            if (options.ownerDocument) {
              $(options.ownerDocument.body).addClass('xdsoft_noselect');
            }

            $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
              $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft_scroller', arguments_callee).off('mousemove.xdsoft_scroller', calcOffset).removeClass('xdsoft_noselect');
            });
            $(options.ownerDocument.body).on('mousemove.xdsoft_scroller', calcOffset);
          } else {
            touchStart = true;
            event.stopPropagation();
            event.preventDefault();
          }
        }).on('touchmove', function (event) {
          if (touchStart) {
            event.preventDefault();
            calcOffset(event);
          }
        }).on('touchend touchcancel', function () {
          touchStart = false;
          startTopScroll = 0;
        });
        timeboxparent.on('scroll_element.xdsoft_scroller', function (event, percentage) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
          }

          percentage = percentage > 1 ? 1 : percentage < 0 || isNaN(percentage) ? 0 : percentage;
          scroller.css('margin-top', maximumOffset * percentage);
          setTimeout(function () {
            timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
          }, 10);
        }).on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
          var percent, sh;
          parentHeight = timeboxparent[0].clientHeight;
          height = timebox[0].offsetHeight;
          percent = parentHeight / height;
          sh = percent * scrollbar[0].offsetHeight;

          if (percent > 1) {
            scroller.hide();
          } else {
            scroller.show();
            scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
            maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;

            if (noTriggerScroll !== true) {
              timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
            }
          }
        });
        timeboxparent.on('mousewheel', function (event) {
          var top = Math.abs(parseInt(timebox.css('marginTop'), 10));
          top = top - event.deltaY * 20;

          if (top < 0) {
            top = 0;
          }

          timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
          event.stopPropagation();
          return false;
        });
        timeboxparent.on('touchstart', function (event) {
          start = pointerEventToXY(event);
          startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
        });
        timeboxparent.on('touchmove', function (event) {
          if (start) {
            event.preventDefault();
            var coord = pointerEventToXY(event);
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
          }
        });
        timeboxparent.on('touchend touchcancel', function () {
          start = false;
          startTop = 0;
        });
      }

      timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
    });
  };

  $.fn.datetimepicker = function (opt, opt2) {
    var result = this,
        KEY0 = 48,
        KEY9 = 57,
        _KEY0 = 96,
        _KEY9 = 105,
        CTRLKEY = 17,
        CMDKEY = 91,
        DEL = 46,
        ENTER = 13,
        ESC = 27,
        BACKSPACE = 8,
        ARROWLEFT = 37,
        ARROWUP = 38,
        ARROWRIGHT = 39,
        ARROWDOWN = 40,
        TAB = 9,
        F5 = 116,
        AKEY = 65,
        CKEY = 67,
        VKEY = 86,
        ZKEY = 90,
        YKEY = 89,
        ctrlDown = false,
        cmdDown = false,
        options = $.isPlainObject(opt) || !opt ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),
        lazyInitTimer = 0,
        createDateTimePicker,
        destroyDateTimePicker,
        lazyInit = function lazyInit(input) {
      input.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
        if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
          return;
        }

        clearTimeout(lazyInitTimer);
        lazyInitTimer = setTimeout(function () {
          if (!input.data('xdsoft_datetimepicker')) {
            createDateTimePicker(input);
          }

          input.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback).trigger('open.xdsoft');
        }, 100);
      });
    };

    createDateTimePicker = function createDateTimePicker(input) {
      var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
          xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
          datepicker = $('<div class="xdsoft_datepicker active"></div>'),
          month_picker = $('<div class="xdsoft_monthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' + '<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' + '<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' + '<button type="button" class="xdsoft_next"></button></div>'),
          calendar = $('<div class="xdsoft_calendar"></div>'),
          timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
          timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
          timebox = $('<div class="xdsoft_time_variant"></div>'),
          applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),
          monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
          yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
          triggerAfterOpen = false,
          XDSoft_datetime,
          xchangeTimer,
          timerclick,
          current_time_index,
          setPos,
          timer = 0,
          _xdsoft_datetime,
          forEachAncestorOf;

      if (options.id) {
        datetimepicker.attr('id', options.id);
      }

      if (options.style) {
        datetimepicker.attr('style', options.style);
      }

      if (options.weeks) {
        datetimepicker.addClass('xdsoft_showweeks');
      }

      if (options.rtl) {
        datetimepicker.addClass('xdsoft_rtl');
      }

      datetimepicker.addClass('xdsoft_' + options.theme);
      datetimepicker.addClass(options.className);
      month_picker.find('.xdsoft_month span').after(monthselect);
      month_picker.find('.xdsoft_year span').after(yearselect);
      month_picker.find('.xdsoft_month,.xdsoft_year').on('touchstart mousedown.xdsoft', function (event) {
        var select = $(this).find('.xdsoft_select').eq(0),
            val = 0,
            top = 0,
            visible = select.is(':visible'),
            items,
            i;
        month_picker.find('.xdsoft_select').hide();

        if (_xdsoft_datetime.currentTime) {
          val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
        }

        select[visible ? 'hide' : 'show']();

        for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
          if (items.eq(i).data('value') === val) {
            break;
          } else {
            top += items[0].offsetHeight;
          }
        }

        select.xdsoftScroller(options, top / (select.children()[0].offsetHeight - select[0].clientHeight));
        event.stopPropagation();
        return false;
      });

      var handleTouchMoved = function handleTouchMoved(event) {
        var evt = event.originalEvent;
        var touchPosition = evt.touches ? evt.touches[0] : evt;
        this.touchStartPosition = this.touchStartPosition || touchPosition;
        var xMovement = Math.abs(this.touchStartPosition.clientX - touchPosition.clientX);
        var yMovement = Math.abs(this.touchStartPosition.clientY - touchPosition.clientY);
        var distance = Math.sqrt(xMovement * xMovement + yMovement * yMovement);

        if (distance > options.touchMovedThreshold) {
          this.touchMoved = true;
        }
      };

      month_picker.find('.xdsoft_select').xdsoftScroller(options).on('touchstart mousedown.xdsoft', function (event) {
        var evt = event.originalEvent;
        this.touchMoved = false;
        this.touchStartPosition = evt.touches ? evt.touches[0] : evt;
        event.stopPropagation();
        event.preventDefault();
      }).on('touchmove', '.xdsoft_option', handleTouchMoved).on('touchend mousedown.xdsoft', '.xdsoft_option', function () {
        if (!this.touchMoved) {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }

          var year = _xdsoft_datetime.currentTime.getFullYear();

          if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
            _xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
          }

          $(this).parent().parent().hide();
          datetimepicker.trigger('xchange.xdsoft');

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
        }
      });

      datetimepicker.getValue = function () {
        return _xdsoft_datetime.getCurrentTime();
      };

      datetimepicker.setOptions = function (_options) {
        var highlightedDates = {};
        options = $.extend(true, {}, options, _options);

        if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
          options.allowTimes = $.extend(true, [], _options.allowTimes);
        }

        if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
          options.weekends = $.extend(true, [], _options.weekends);
        }

        if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
          options.allowDates = $.extend(true, [], _options.allowDates);
        }

        if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe) === "[object String]") {
          options.allowDateRe = new RegExp(_options.allowDateRe);
        }

        if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
          $.each(_options.highlightedDates, function (index, value) {
            var splitData = $.map(value.split(','), $.trim),
                exDesc,
                hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]),
                // date, desc, style
            keyDate = dateHelper.formatDate(hDate.date, options.formatDate);

            if (highlightedDates[keyDate] !== undefined) {
              exDesc = highlightedDates[keyDate].desc;

              if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
              }
            } else {
              highlightedDates[keyDate] = hDate;
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }

        if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
          highlightedDates = $.extend(true, [], options.highlightedDates);
          $.each(_options.highlightedPeriods, function (index, value) {
            var dateTest, // start date
            dateEnd, desc, hDate, keyDate, exDesc, style;

            if ($.isArray(value)) {
              dateTest = value[0];
              dateEnd = value[1];
              desc = value[2];
              style = value[3];
            } else {
              var splitData = $.map(value.split(','), $.trim);
              dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
              dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
              desc = splitData[2];
              style = splitData[3];
            }

            while (dateTest <= dateEnd) {
              hDate = new HighlightedDate(dateTest, desc, style);
              keyDate = dateHelper.formatDate(dateTest, options.formatDate);
              dateTest.setDate(dateTest.getDate() + 1);

              if (highlightedDates[keyDate] !== undefined) {
                exDesc = highlightedDates[keyDate].desc;

                if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                  highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                }
              } else {
                highlightedDates[keyDate] = hDate;
              }
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }

        if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
          options.disabledDates = $.extend(true, [], _options.disabledDates);
        }

        if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
          options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
        }

        if ((options.open || options.opened) && !options.inline) {
          input.trigger('open.xdsoft');
        }

        if (options.inline) {
          triggerAfterOpen = true;
          datetimepicker.addClass('xdsoft_inline');
          input.after(datetimepicker).hide();
        }

        if (options.inverseButton) {
          options.next = 'xdsoft_prev';
          options.prev = 'xdsoft_next';
        }

        if (options.datepicker) {
          datepicker.addClass('active');
        } else {
          datepicker.removeClass('active');
        }

        if (options.timepicker) {
          timepicker.addClass('active');
        } else {
          timepicker.removeClass('active');
        }

        if (options.value) {
          _xdsoft_datetime.setCurrentTime(options.value);

          if (input && input.val) {
            input.val(_xdsoft_datetime.str);
          }
        }

        if (isNaN(options.dayOfWeekStart)) {
          options.dayOfWeekStart = 0;
        } else {
          options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
        }

        if (!options.timepickerScrollbar) {
          timeboxparent.xdsoftScroller(options, 'hide');
        }

        if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
          options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
        }

        if (options.maxDate && /^[\+\-](.*)$/.test(options.maxDate)) {
          options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
        }

        if (options.minDateTime && /^\+(.*)$/.test(options.minDateTime)) {
          options.minDateTime = _xdsoft_datetime.strToDateTime(options.minDateTime).dateFormat(options.formatDate);
        }

        if (options.maxDateTime && /^\+(.*)$/.test(options.maxDateTime)) {
          options.maxDateTime = _xdsoft_datetime.strToDateTime(options.maxDateTime).dateFormat(options.formatDate);
        }

        applyButton.toggle(options.showApplyButton);
        month_picker.find('.xdsoft_today_button').css('visibility', !options.todayButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.prev).css('visibility', !options.prevButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.next).css('visibility', !options.nextButton ? 'hidden' : 'visible');
        setMask(options);

        if (options.validateOnBlur) {
          input.off('blur.xdsoft').on('blur.xdsoft', function () {
            if (options.allowBlank && (!$.trim($(this).val()).length || typeof options.mask === "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_'))) {
              $(this).val(null);
              datetimepicker.data('xdsoft_datetime').empty();
            } else {
              var d = dateHelper.parseDate($(this).val(), options.format);

              if (d) {
                // parseDate() may skip some invalid parts like date or time, so make it clear for user: show parsed date/time
                $(this).val(dateHelper.formatDate(d, options.format));
              } else {
                var splittedHours = +[$(this).val()[0], $(this).val()[1]].join(''),
                    splittedMinutes = +[$(this).val()[2], $(this).val()[3]].join(''); // parse the numbers as 0312 => 03:12

                if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
                  $(this).val([splittedHours, splittedMinutes].map(function (item) {
                    return item > 9 ? item : '0' + item;
                  }).join(':'));
                } else {
                  $(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
                }
              }

              datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
            }

            datetimepicker.trigger('changedatetime.xdsoft');
            datetimepicker.trigger('close.xdsoft');
          });
        }

        options.dayOfWeekStartPrev = options.dayOfWeekStart === 0 ? 6 : options.dayOfWeekStart - 1;
        datetimepicker.trigger('xchange.xdsoft').trigger('afterOpen.xdsoft');
      };

      datetimepicker.data('options', options).on('touchstart mousedown.xdsoft', function (event) {
        event.stopPropagation();
        event.preventDefault();
        yearselect.hide();
        monthselect.hide();
        return false;
      }); //scroll_element = timepicker.find('.xdsoft_time_box');

      timeboxparent.append(timebox);
      timeboxparent.xdsoftScroller(options);
      datetimepicker.on('afterOpen.xdsoft', function () {
        timeboxparent.xdsoftScroller(options);
      });
      datetimepicker.append(datepicker).append(timepicker);

      if (options.withoutCopyright !== true) {
        datetimepicker.append(xdsoft_copyright);
      }

      datepicker.append(month_picker).append(calendar).append(applyButton);

      if (options.insideParent) {
        $(input).parent().append(datetimepicker);
      } else {
        $(options.parentID).append(datetimepicker);
      }

      XDSoft_datetime = function XDSoft_datetime() {
        var _this = this;

        _this.now = function (norecursion) {
          var d = new Date(),
              date,
              time;

          if (!norecursion && options.defaultDate) {
            date = _this.strToDateTime(options.defaultDate);
            d.setFullYear(date.getFullYear());
            d.setMonth(date.getMonth());
            d.setDate(date.getDate());
          }

          d.setFullYear(d.getFullYear());

          if (!norecursion && options.defaultTime) {
            time = _this.strtotime(options.defaultTime);
            d.setHours(time.getHours());
            d.setMinutes(time.getMinutes());
            d.setSeconds(time.getSeconds());
            d.setMilliseconds(time.getMilliseconds());
          }

          return d;
        };

        _this.isValidDate = function (d) {
          if (Object.prototype.toString.call(d) !== "[object Date]") {
            return false;
          }

          return !isNaN(d.getTime());
        };

        _this.setCurrentTime = function (dTime, requireValidDate) {
          if (typeof dTime === 'string') {
            _this.currentTime = _this.strToDateTime(dTime);
          } else if (_this.isValidDate(dTime)) {
            _this.currentTime = dTime;
          } else if (!dTime && !requireValidDate && options.allowBlank && !options.inline) {
            _this.currentTime = null;
          } else {
            _this.currentTime = _this.now();
          }

          datetimepicker.trigger('xchange.xdsoft');
        };

        _this.empty = function () {
          _this.currentTime = null;
        };

        _this.getCurrentTime = function () {
          return _this.currentTime;
        };

        _this.nextMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }

          var month = _this.currentTime.getMonth() + 1,
              year;

          if (month === 12) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);

            month = 0;
          }

          year = _this.currentTime.getFullYear();

          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));

          _this.currentTime.setMonth(month);

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };

        _this.prevMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }

          var month = _this.currentTime.getMonth() - 1;

          if (month === -1) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);

            month = 11;
          }

          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));

          _this.currentTime.setMonth(month);

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };

        _this.getWeekOfYear = function (datetime) {
          if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
            var week = options.onGetWeekOfYear.call(datetimepicker, datetime);

            if (typeof week !== 'undefined') {
              return week;
            }
          }

          var onejan = new Date(datetime.getFullYear(), 0, 1); //First week of the year is th one with the first Thursday according to ISO8601

          if (onejan.getDay() !== 4) {
            onejan.setMonth(0, 1 + (4 - onejan.getDay() + 7) % 7);
          }

          return Math.ceil(((datetime - onejan) / 86400000 + onejan.getDay() + 1) / 7);
        };

        _this.strToDateTime = function (sDateTime) {
          var tmpDate = [],
              timeOffset,
              currentTime;

          if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
            return sDateTime;
          }

          tmpDate = /^([+-]{1})(.*)$/.exec(sDateTime);

          if (tmpDate) {
            tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
          }

          if (tmpDate && tmpDate[2]) {
            timeOffset = tmpDate[2].getTime() - tmpDate[2].getTimezoneOffset() * 60000;
            currentTime = new Date(_this.now(true).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
          } else {
            currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
          }

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now();
          }

          return currentTime;
        };

        _this.strToDate = function (sDate) {
          if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
            return sDate;
          }

          var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }

          return currentTime;
        };

        _this.strtotime = function (sTime) {
          if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
            return sTime;
          }

          var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }

          return currentTime;
        };

        _this.str = function () {
          var format = options.format;

          if (options.yearOffset) {
            format = format.replace('Y', _this.currentTime.getFullYear() + options.yearOffset);
            format = format.replace('y', String(_this.currentTime.getFullYear() + options.yearOffset).substring(2, 4));
          }

          return dateHelper.formatDate(_this.currentTime, format);
        };

        _this.currentTime = this.now();
      };

      _xdsoft_datetime = new XDSoft_datetime();
      applyButton.on('touchend click', function (e) {
        //pathbrite
        e.preventDefault();
        datetimepicker.data('changed', true);

        _xdsoft_datetime.setCurrentTime(getCurrentValue());

        input.val(_xdsoft_datetime.str());
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_today_button').on('touchend mousedown.xdsoft', function () {
        datetimepicker.data('changed', true);

        _xdsoft_datetime.setCurrentTime(0, true);

        datetimepicker.trigger('afterOpen.xdsoft');
      }).on('dblclick.xdsoft', function () {
        var currentDate = _xdsoft_datetime.getCurrentTime(),
            minDate,
            maxDate;

        currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
        minDate = _xdsoft_datetime.strToDate(options.minDate);
        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());

        if (currentDate < minDate) {
          return;
        }

        maxDate = _xdsoft_datetime.strToDate(options.maxDate);
        maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());

        if (currentDate > maxDate) {
          return;
        }

        input.val(_xdsoft_datetime.str());
        input.trigger('change');
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
            timer = 0,
            stop = false;

        (function arguments_callee1(v) {
          if ($this.hasClass(options.next)) {
            _xdsoft_datetime.nextMonth();
          } else if ($this.hasClass(options.prev)) {
            _xdsoft_datetime.prevMonth();
          }

          if (options.monthChangeSpinner) {
            if (!stop) {
              timer = setTimeout(arguments_callee1, v || 100);
            }
          }
        })(500);

        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee2() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee2);
        });
      });
      timepicker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
            timer = 0,
            stop = false,
            period = 110;

        (function arguments_callee4(v) {
          var pheight = timeboxparent[0].clientHeight,
              height = timebox[0].offsetHeight,
              top = Math.abs(parseInt(timebox.css('marginTop'), 10));

          if ($this.hasClass(options.next) && height - pheight - options.timeHeightInTimePicker >= top) {
            timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
          } else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
            timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
          }
          /**
           * Fixed bug:
           * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
           * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
           * would cause a bug when you use jquery.css method.
           * Let's say: * { transition: all .5s ease; }
           * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
           * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
           * next/prev button.
           *
           * What we should do:
           * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
           */


          timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
          period = period > 10 ? 10 : period - 10;

          if (!stop) {
            timer = setTimeout(arguments_callee4, v || period);
          }
        })(500);

        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee5() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee5);
        });
      });
      xchangeTimer = 0; // base handler - generating a calendar and timepicker

      datetimepicker.on('xchange.xdsoft', function (event) {
        clearTimeout(xchangeTimer);
        xchangeTimer = setTimeout(function () {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }

          var table = '',
              start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
              i = 0,
              j,
              today = _xdsoft_datetime.now(),
              maxDate = false,
              minDate = false,
              minDateTime = false,
              maxDateTime = false,
              hDate,
              day,
              d,
              y,
              m,
              w,
              classes = [],
              customDateSettings,
              newRow = true,
              time = '',
              h,
              line_time,
              description;

          while (start.getDay() !== options.dayOfWeekStart) {
            start.setDate(start.getDate() - 1);
          }

          table += '<table><thead><tr>';

          if (options.weeks) {
            table += '<th></th>';
          }

          for (j = 0; j < 7; j += 1) {
            table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
          }

          table += '</tr></thead>';
          table += '<tbody>';

          if (options.maxDate !== false) {
            maxDate = _xdsoft_datetime.strToDate(options.maxDate);
            maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
          }

          if (options.minDate !== false) {
            minDate = _xdsoft_datetime.strToDate(options.minDate);
            minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
          }

          if (options.minDateTime !== false) {
            minDateTime = _xdsoft_datetime.strToDate(options.minDateTime);
            minDateTime = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), minDateTime.getHours(), minDateTime.getMinutes(), minDateTime.getSeconds());
          }

          if (options.maxDateTime !== false) {
            maxDateTime = _xdsoft_datetime.strToDate(options.maxDateTime);
            maxDateTime = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), maxDateTime.getHours(), maxDateTime.getMinutes(), maxDateTime.getSeconds());
          }

          var maxDateTimeDay;

          if (maxDateTime !== false) {
            maxDateTimeDay = (maxDateTime.getFullYear() * 12 + maxDateTime.getMonth()) * 31 + maxDateTime.getDate();
          }

          while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
            classes = [];
            i += 1;
            day = start.getDay();
            d = start.getDate();
            y = start.getFullYear();
            m = start.getMonth();
            w = _xdsoft_datetime.getWeekOfYear(start);
            description = '';
            classes.push('xdsoft_date');

            if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
              customDateSettings = options.beforeShowDay.call(datetimepicker, start);
            } else {
              customDateSettings = null;
            }

            if (options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]") {
              if (!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))) {
                classes.push('xdsoft_disabled');
              }
            }

            if (options.allowDates && options.allowDates.length > 0) {
              if (options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1) {
                classes.push('xdsoft_disabled');
              }
            }

            var currentDay = (start.getFullYear() * 12 + start.getMonth()) * 31 + start.getDate();

            if (maxDate !== false && start > maxDate || minDateTime !== false && start < minDateTime || minDate !== false && start < minDate || maxDateTime !== false && currentDay > maxDateTimeDay || customDateSettings && customDateSettings[0] === false) {
              classes.push('xdsoft_disabled');
            }

            if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_disabled');
            }

            if (options.disabledWeekDays.indexOf(day) !== -1) {
              classes.push('xdsoft_disabled');
            }

            if (input.is('[disabled]')) {
              classes.push('xdsoft_disabled');
            }

            if (customDateSettings && customDateSettings[1] !== "") {
              classes.push(customDateSettings[1]);
            }

            if (_xdsoft_datetime.currentTime.getMonth() !== m) {
              classes.push('xdsoft_other_month');
            }

            if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_current');
            }

            if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_today');
            }

            if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_weekend');
            }

            if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
              hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
              classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
              description = hDate.desc === undefined ? '' : hDate.desc;
            }

            if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
              classes.push(options.beforeShowDay(start));
            }

            if (newRow) {
              table += '<tr>';
              newRow = false;

              if (options.weeks) {
                table += '<th>' + w + '</th>';
              }
            }

            table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' + '<div>' + d + '</div>' + '</td>';

            if (start.getDay() === options.dayOfWeekStartPrev) {
              table += '</tr>';
              newRow = true;
            }

            start.setDate(d + 1);
          }

          table += '</tbody></table>';
          calendar.html(table);
          month_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
          month_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear() + options.yearOffset); // generate timebox

          time = '';
          h = '';
          m = '';
          var minTimeMinutesOfDay = 0;

          if (options.minTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.minTime);

            minTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }

          var maxTimeMinutesOfDay = 24 * 60;

          if (options.maxTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.maxTime);

            maxTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }

          if (options.minDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.minDateTime);

            var currentDayIsMinDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);

            if (currentDayIsMinDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m > minTimeMinutesOfDay) minTimeMinutesOfDay = m;
            }
          }

          if (options.maxDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.maxDateTime);

            var currentDayIsMaxDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);

            if (currentDayIsMaxDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m < maxTimeMinutesOfDay) maxTimeMinutesOfDay = m;
            }
          }

          line_time = function line_time(h, m) {
            var now = _xdsoft_datetime.now(),
                current_time,
                isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;

            now.setHours(h);
            h = parseInt(now.getHours(), 10);
            now.setMinutes(m);
            m = parseInt(now.getMinutes(), 10);
            classes = [];
            var currentMinutesOfDay = 60 * h + m;

            if (input.is('[disabled]') || currentMinutesOfDay >= maxTimeMinutesOfDay || currentMinutesOfDay < minTimeMinutesOfDay) {
              classes.push('xdsoft_disabled');
            }

            current_time = new Date(_xdsoft_datetime.currentTime);
            current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));

            if (!isALlowTimesInit) {
              current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
            }

            if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && (!isALlowTimesInit && options.step > 59 || current_time.getMinutes() === parseInt(m, 10))) {
              if (options.defaultSelect || datetimepicker.data('changed')) {
                classes.push('xdsoft_current');
              } else if (options.initTime) {
                classes.push('xdsoft_init_time');
              }
            }

            if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
              classes.push('xdsoft_today');
            }

            time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
          };

          if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
            for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
              for (j = 0; j < 60; j += options.step) {
                var currentMinutesOfDay = i * 60 + j;
                if (currentMinutesOfDay < minTimeMinutesOfDay) continue;
                if (currentMinutesOfDay >= maxTimeMinutesOfDay) continue;
                h = (i < 10 ? '0' : '') + i;
                m = (j < 10 ? '0' : '') + j;
                line_time(h, m);
              }
            }
          } else {
            for (i = 0; i < options.allowTimes.length; i += 1) {
              h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
              m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
              line_time(h, m);
            }
          }

          timebox.html(time);
          opt = '';

          for (i = parseInt(options.yearStart, 10); i <= parseInt(options.yearEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + (i + options.yearOffset) + '</div>';
          }

          yearselect.children().eq(0).html(opt);

          for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
          }

          monthselect.children().eq(0).html(opt);
          $(datetimepicker).trigger('generate.xdsoft');
        }, 10);
        event.stopPropagation();
      }).on('afterOpen.xdsoft', function () {
        if (options.timepicker) {
          var classType, pheight, height, top;

          if (timebox.find('.xdsoft_current').length) {
            classType = '.xdsoft_current';
          } else if (timebox.find('.xdsoft_init_time').length) {
            classType = '.xdsoft_init_time';
          }

          if (classType) {
            pheight = timeboxparent[0].clientHeight;
            height = timebox[0].offsetHeight;
            top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;

            if (height - pheight < top) {
              top = height - pheight;
            }

            timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
          } else {
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
          }
        }
      });
      timerclick = 0;
      calendar.on('touchend click.xdsoft', 'td', function (xdevent) {
        xdevent.stopPropagation(); // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap

        timerclick += 1;
        var $this = $(this),
            currentTime = _xdsoft_datetime.currentTime;

        if (currentTime === undefined || currentTime === null) {
          _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          currentTime = _xdsoft_datetime.currentTime;
        }

        if ($this.hasClass('xdsoft_disabled')) {
          return false;
        }

        currentTime.setDate(1);
        currentTime.setFullYear($this.data('year'));
        currentTime.setMonth($this.data('month'));
        currentTime.setDate($this.data('date'));
        datetimepicker.trigger('select.xdsoft', [currentTime]);
        input.val(_xdsoft_datetime.str());

        if (options.onSelectDate && $.isFunction(options.onSelectDate)) {
          options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
        }

        datetimepicker.data('changed', true);
        datetimepicker.trigger('xchange.xdsoft');
        datetimepicker.trigger('changedatetime.xdsoft');

        if ((timerclick > 1 || options.closeOnDateSelect === true || options.closeOnDateSelect === false && !options.timepicker) && !options.inline) {
          datetimepicker.trigger('close.xdsoft');
        }

        setTimeout(function () {
          timerclick = 0;
        }, 200);
      });
      timebox.on('touchstart', 'div', function (xdevent) {
        this.touchMoved = false;
      }).on('touchmove', 'div', handleTouchMoved).on('touchend click.xdsoft', 'div', function (xdevent) {
        if (!this.touchMoved) {
          xdevent.stopPropagation();
          var $this = $(this),
              currentTime = _xdsoft_datetime.currentTime;

          if (currentTime === undefined || currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
            currentTime = _xdsoft_datetime.currentTime;
          }

          if ($this.hasClass('xdsoft_disabled')) {
            return false;
          }

          currentTime.setHours($this.data('hour'));
          currentTime.setMinutes($this.data('minute'));
          datetimepicker.trigger('select.xdsoft', [currentTime]);
          datetimepicker.data('input').val(_xdsoft_datetime.str());

          if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
            options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
          }

          datetimepicker.data('changed', true);
          datetimepicker.trigger('xchange.xdsoft');
          datetimepicker.trigger('changedatetime.xdsoft');

          if (options.inline !== true && options.closeOnTimeSelect === true) {
            datetimepicker.trigger('close.xdsoft');
          }
        }
      });
      datepicker.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollMonth) {
          return true;
        }

        if (event.deltaY < 0) {
          _xdsoft_datetime.nextMonth();
        } else {
          _xdsoft_datetime.prevMonth();
        }

        return false;
      });
      input.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollInput) {
          return true;
        }

        if (!options.datepicker && options.timepicker) {
          current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;

          if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
            current_time_index += event.deltaY;
          }

          if (timebox.children().eq(current_time_index).length) {
            timebox.children().eq(current_time_index).trigger('mousedown');
          }

          return false;
        }

        if (options.datepicker && !options.timepicker) {
          datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);

          if (input.val) {
            input.val(_xdsoft_datetime.str());
          }

          datetimepicker.trigger('changedatetime.xdsoft');
          return false;
        }
      });
      datetimepicker.on('changedatetime.xdsoft', function (event) {
        if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
          var $input = datetimepicker.data('input');
          options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
          delete options.value;
          $input.trigger('change');
        }
      }).on('generate.xdsoft', function () {
        if (options.onGenerate && $.isFunction(options.onGenerate)) {
          options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
        }

        if (triggerAfterOpen) {
          datetimepicker.trigger('afterOpen.xdsoft');
          triggerAfterOpen = false;
        }
      }).on('click.xdsoft', function (xdevent) {
        xdevent.stopPropagation();
      });
      current_time_index = 0;
      /**
       * Runs the callback for each of the specified node's ancestors.
       *
       * Return FALSE from the callback to stop ascending.
       *
       * @param {DOMNode} node
       * @param {Function} callback
       * @returns {undefined}
       */

      forEachAncestorOf = function forEachAncestorOf(node, callback) {
        do {
          node = node.parentNode;

          if (!node || callback(node) === false) {
            break;
          }
        } while (node.nodeName !== 'HTML');
      };
      /**
       * Sets the position of the picker.
       *
       * @returns {undefined}
       */


      setPos = function setPos() {
        var dateInputOffset, dateInputElem, verticalPosition, left, position, datetimepickerElem, dateInputHasFixedAncestor, $dateInput, windowWidth, verticalAnchorEdge, datetimepickerCss, windowHeight, windowScrollTop;
        $dateInput = datetimepicker.data('input');
        dateInputOffset = $dateInput.offset();
        dateInputElem = $dateInput[0];
        verticalAnchorEdge = 'top';
        verticalPosition = dateInputOffset.top + dateInputElem.offsetHeight - 1;
        left = dateInputOffset.left;
        position = "absolute";
        windowWidth = $(options.contentWindow).width();
        windowHeight = $(options.contentWindow).height();
        windowScrollTop = $(options.contentWindow).scrollTop();

        if (options.ownerDocument.documentElement.clientWidth - dateInputOffset.left < datepicker.parent().outerWidth(true)) {
          var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
          left = left - diff;
        }

        if ($dateInput.parent().css('direction') === 'rtl') {
          left -= datetimepicker.outerWidth() - $dateInput.outerWidth();
        }

        if (options.fixed) {
          verticalPosition -= windowScrollTop;
          left -= $(options.contentWindow).scrollLeft();
          position = "fixed";
        } else {
          dateInputHasFixedAncestor = false;
          forEachAncestorOf(dateInputElem, function (ancestorNode) {
            if (ancestorNode === null) {
              return false;
            }

            if (options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
              dateInputHasFixedAncestor = true;
              return false;
            }
          });

          if (dateInputHasFixedAncestor && !options.insideParent) {
            position = 'fixed'; //If the picker won't fit entirely within the viewport then display it above the date input.

            if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
              verticalAnchorEdge = 'bottom';
              verticalPosition = windowHeight + windowScrollTop - dateInputOffset.top;
            } else {
              verticalPosition -= windowScrollTop;
            }
          } else {
            if (verticalPosition + datetimepicker[0].offsetHeight > windowHeight + windowScrollTop) {
              verticalPosition = dateInputOffset.top - datetimepicker[0].offsetHeight + 1;
            }
          }

          if (verticalPosition < 0) {
            verticalPosition = 0;
          }

          if (left + dateInputElem.offsetWidth > windowWidth) {
            left = windowWidth - dateInputElem.offsetWidth;
          }
        }

        datetimepickerElem = datetimepicker[0];
        forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
          var ancestorNodePosition;
          ancestorNodePosition = options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position');

          if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
            left = left - (windowWidth - ancestorNode.offsetWidth) / 2;
            return false;
          }
        });
        datetimepickerCss = {
          position: position,
          left: options.insideParent ? dateInputElem.offsetLeft : left,
          top: '',
          //Initialize to prevent previous values interfering with new ones.
          bottom: '' //Initialize to prevent previous values interfering with new ones.

        };

        if (options.insideParent) {
          datetimepickerCss[verticalAnchorEdge] = dateInputElem.offsetTop + dateInputElem.offsetHeight;
        } else {
          datetimepickerCss[verticalAnchorEdge] = verticalPosition;
        }

        datetimepicker.css(datetimepickerCss);
      };

      datetimepicker.on('open.xdsoft', function (event) {
        var onShow = true;

        if (options.onShow && $.isFunction(options.onShow)) {
          onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }

        if (onShow !== false) {
          datetimepicker.show();
          setPos();
          $(options.contentWindow).off('resize.xdsoft', setPos).on('resize.xdsoft', setPos);

          if (options.closeOnWithoutClick) {
            $([options.ownerDocument.body, options.contentWindow]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
              datetimepicker.trigger('close.xdsoft');
              $([options.ownerDocument.body, options.contentWindow]).off('touchstart mousedown.xdsoft', arguments_callee6);
            });
          }
        }
      }).on('close.xdsoft', function (event) {
        var onClose = true;
        month_picker.find('.xdsoft_month,.xdsoft_year').find('.xdsoft_select').hide();

        if (options.onClose && $.isFunction(options.onClose)) {
          onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }

        if (onClose !== false && !options.opened && !options.inline) {
          datetimepicker.hide();
        }

        event.stopPropagation();
      }).on('toggle.xdsoft', function () {
        if (datetimepicker.is(':visible')) {
          datetimepicker.trigger('close.xdsoft');
        } else {
          datetimepicker.trigger('open.xdsoft');
        }
      }).data('input', input);
      timer = 0;
      datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
      datetimepicker.setOptions(options);

      function getCurrentValue() {
        var ct = false,
            time;

        if (options.startDate) {
          ct = _xdsoft_datetime.strToDate(options.startDate);
        } else {
          ct = options.value || (input && input.val && input.val() ? input.val() : '');

          if (ct) {
            ct = _xdsoft_datetime.strToDateTime(ct);

            if (options.yearOffset) {
              ct = new Date(ct.getFullYear() - options.yearOffset, ct.getMonth(), ct.getDate(), ct.getHours(), ct.getMinutes(), ct.getSeconds(), ct.getMilliseconds());
            }
          } else if (options.defaultDate) {
            ct = _xdsoft_datetime.strToDateTime(options.defaultDate);

            if (options.defaultTime) {
              time = _xdsoft_datetime.strtotime(options.defaultTime);
              ct.setHours(time.getHours());
              ct.setMinutes(time.getMinutes());
            }
          }
        }

        if (ct && _xdsoft_datetime.isValidDate(ct)) {
          datetimepicker.data('changed', true);
        } else {
          ct = '';
        }

        return ct || 0;
      }

      function setMask(options) {
        var isValidValue = function isValidValue(mask, value) {
          var reg = mask.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1').replace(/_/g, '{digit+}').replace(/([0-9]{1})/g, '{digit$1}').replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}').replace(/\{digit[\+]\}/g, '[0-9_]{1}');
          return new RegExp(reg).test(value);
        },
            getCaretPos = function getCaretPos(input) {
          try {
            if (options.ownerDocument.selection && options.ownerDocument.selection.createRange) {
              var range = options.ownerDocument.selection.createRange();
              return range.getBookmark().charCodeAt(2) - 2;
            }

            if (input.setSelectionRange) {
              return input.selectionStart;
            }
          } catch (e) {
            return 0;
          }
        },
            setCaretPos = function setCaretPos(node, pos) {
          node = typeof node === "string" || node instanceof String ? options.ownerDocument.getElementById(node) : node;

          if (!node) {
            return false;
          }

          if (node.createTextRange) {
            var textRange = node.createTextRange();
            textRange.collapse(true);
            textRange.moveEnd('character', pos);
            textRange.moveStart('character', pos);
            textRange.select();
            return true;
          }

          if (node.setSelectionRange) {
            node.setSelectionRange(pos, pos);
            return true;
          }

          return false;
        };

        if (options.mask) {
          input.off('keydown.xdsoft');
        }

        if (options.mask === true) {
          if (dateHelper.formatMask) {
            options.mask = dateHelper.formatMask(options.format);
          } else {
            options.mask = options.format.replace(/Y/g, '9999').replace(/F/g, '9999').replace(/m/g, '19').replace(/d/g, '39').replace(/H/g, '29').replace(/i/g, '59').replace(/s/g, '59');
          }
        }

        if ($.type(options.mask) === 'string') {
          if (!isValidValue(options.mask, input.val())) {
            input.val(options.mask.replace(/[0-9]/g, '_'));
            setCaretPos(input[0], 0);
          }

          input.on('paste.xdsoft', function (event) {
            // couple options here
            // 1. return false - tell them they can't paste
            // 2. insert over current characters - minimal validation
            // 3. full fledged parsing and validation
            // let's go option 2 for now
            // fires multiple times for some reason
            // https://stackoverflow.com/a/30496488/1366033
            var clipboardData = event.clipboardData || event.originalEvent.clipboardData || window.clipboardData,
                pastedData = clipboardData.getData('text'),
                val = this.value,
                pos = this.selectionStart;
            var valueBeforeCursor = val.substr(0, pos);
            var valueAfterPaste = val.substr(pos + pastedData.length);
            val = valueBeforeCursor + pastedData + valueAfterPaste;
            pos += pastedData.length;

            if (isValidValue(options.mask, val)) {
              this.value = val;
              setCaretPos(this, pos);
            } else if ($.trim(val) === '') {
              this.value = options.mask.replace(/[0-9]/g, '_');
            } else {
              input.trigger('error_input.xdsoft');
            }

            event.preventDefault();
            return false;
          });
          input.on('keydown.xdsoft', function (event) {
            var val = this.value,
                key = event.which,
                pos = this.selectionStart,
                selEnd = this.selectionEnd,
                hasSel = pos !== selEnd,
                digit; // only alow these characters

            if (key >= KEY0 && key <= KEY9 || key >= _KEY0 && key <= _KEY9 || key === BACKSPACE || key === DEL) {
              // get char to insert which is new character or placeholder ('_')
              digit = key === BACKSPACE || key === DEL ? '_' : String.fromCharCode(_KEY0 <= key && key <= _KEY9 ? key - KEY0 : key); // we're deleting something, we're not at the start, and have normal cursor, move back one
              // if we have a selection length, cursor actually sits behind deletable char, not in front

              if (key === BACKSPACE && pos && !hasSel) {
                pos -= 1;
              } // don't stop on a separator, continue whatever direction you were going
              //   value char - keep incrementing position while on separator char and we still have room
              //   del char   - keep decrementing position while on separator char and we still have room


              while (true) {
                var maskValueAtCurPos = options.mask.substr(pos, 1);
                var posShorterThanMaskLength = pos < options.mask.length;
                var posGreaterThanZero = pos > 0;
                var notNumberOrPlaceholder = /[^0-9_]/;
                var curPosOnSep = notNumberOrPlaceholder.test(maskValueAtCurPos);
                var continueMovingPosition = curPosOnSep && posShorterThanMaskLength && posGreaterThanZero; // if we hit a real char, stay where we are

                if (!continueMovingPosition) break; // hitting backspace in a selection, you can possibly go back any further - go forward

                pos += key === BACKSPACE && !hasSel ? -1 : 1;
              }

              if (event.metaKey) {
                // cmd has been pressed
                pos = 0;
                hasSel = true;
              }

              if (hasSel) {
                // pos might have moved so re-calc length
                var selLength = selEnd - pos; // if we have a selection length we will wipe out entire selection and replace with default template for that range

                var defaultBlank = options.mask.replace(/[0-9]/g, '_');
                var defaultBlankSelectionReplacement = defaultBlank.substr(pos, selLength);
                var selReplacementRemainder = defaultBlankSelectionReplacement.substr(1); // might be empty

                var valueBeforeSel = val.substr(0, pos);
                var insertChars = digit + selReplacementRemainder;
                var charsAfterSelection = val.substr(pos + selLength);
                val = valueBeforeSel + insertChars + charsAfterSelection;
              } else {
                var valueBeforeCursor = val.substr(0, pos);
                var insertChar = digit;
                var valueAfterNextChar = val.substr(pos + 1);
                val = valueBeforeCursor + insertChar + valueAfterNextChar;
              }

              if ($.trim(val) === '') {
                // if empty, set to default
                val = defaultBlank;
              } else {
                // if at the last character don't need to do anything
                if (pos === options.mask.length) {
                  event.preventDefault();
                  return false;
                }
              } // resume cursor location


              pos += key === BACKSPACE ? 0 : 1; // don't stop on a separator, continue whatever direction you were going

              while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                pos += key === BACKSPACE ? 0 : 1;
              }

              if (isValidValue(options.mask, val)) {
                this.value = val;
                setCaretPos(this, pos);
              } else if ($.trim(val) === '') {
                this.value = options.mask.replace(/[0-9]/g, '_');
              } else {
                input.trigger('error_input.xdsoft');
              }
            } else {
              if ([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
                return true;
              }
            }

            event.preventDefault();
            return false;
          });
        }
      }

      _xdsoft_datetime.setCurrentTime(getCurrentValue());

      input.data('xdsoft_datetimepicker', datetimepicker).on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
        if (input.is(':disabled') || input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick) {
          return;
        }

        if (!options.openOnFocus) {
          return;
        }

        clearTimeout(timer);
        timer = setTimeout(function () {
          if (input.is(':disabled')) {
            return;
          }

          triggerAfterOpen = true;

          _xdsoft_datetime.setCurrentTime(getCurrentValue(), true);

          if (options.mask) {
            setMask(options);
          }

          datetimepicker.trigger('open.xdsoft');
        }, 100);
      }).on('keydown.xdsoft', function (event) {
        var elementSelector,
            key = event.which;

        if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
          elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
          datetimepicker.trigger('close.xdsoft');
          elementSelector.eq(elementSelector.index(this) + 1).focus();
          return false;
        }

        if ([TAB].indexOf(key) !== -1) {
          datetimepicker.trigger('close.xdsoft');
          return true;
        }
      }).on('blur.xdsoft', function () {
        datetimepicker.trigger('close.xdsoft');
      });
    };

    destroyDateTimePicker = function destroyDateTimePicker(input) {
      var datetimepicker = input.data('xdsoft_datetimepicker');

      if (datetimepicker) {
        datetimepicker.data('xdsoft_datetime', null);
        datetimepicker.remove();
        input.data('xdsoft_datetimepicker', null).off('.xdsoft');
        $(options.contentWindow).off('resize.xdsoft');
        $([options.contentWindow, options.ownerDocument.body]).off('mousedown.xdsoft touchstart');

        if (input.unmousewheel) {
          input.unmousewheel();
        }
      }
    };

    $(options.ownerDocument).off('keydown.xdsoftctrl keyup.xdsoftctrl').off('keydown.xdsoftcmd keyup.xdsoftcmd').on('keydown.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = true;
      }
    }).on('keyup.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = false;
      }
    }).on('keydown.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = true;
      }
    }).on('keyup.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = false;
      }
    });
    this.each(function () {
      var datetimepicker = $(this).data('xdsoft_datetimepicker'),
          $input;

      if (datetimepicker) {
        if ($.type(opt) === 'string') {
          switch (opt) {
            case 'show':
              $(this).select().focus();
              datetimepicker.trigger('open.xdsoft');
              break;

            case 'hide':
              datetimepicker.trigger('close.xdsoft');
              break;

            case 'toggle':
              datetimepicker.trigger('toggle.xdsoft');
              break;

            case 'destroy':
              destroyDateTimePicker($(this));
              break;

            case 'reset':
              this.value = this.defaultValue;

              if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
                datetimepicker.data('changed', false);
              }

              datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
              break;

            case 'validate':
              $input = datetimepicker.data('input');
              $input.trigger('blur.xdsoft');
              break;

            default:
              if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
                result = datetimepicker[opt](opt2);
              }

          }
        } else {
          datetimepicker.setOptions(opt);
        }

        return 0;
      }

      if ($.type(opt) !== 'string') {
        if (!options.lazyInit || options.open || options.inline) {
          createDateTimePicker($(this));
        } else {
          lazyInit($(this));
        }
      }
    });
    return result;
  };

  $.fn.datetimepicker.defaults = default_options;

  function HighlightedDate(date, desc, style) {
    "use strict";

    this.date = date;
    this.desc = desc;
    this.style = style;
  }
})(jQuery);
// CONCATENATED MODULE: ./src/components/form/js/fn/datepicker.js
function datepicker_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { datepicker_typeof = function _typeof(obj) { return typeof obj; }; } else { datepicker_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return datepicker_typeof(obj); }

/*
 * Render Date Picker
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixRenderDatePicker = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '[data-picker]'
    }, options);
    this.each(function () {
      if ($.isFunction($.fn.datetimepicker)) {
        $(settings.controls).each(function () {
          var $this = $(this);
          var dateFormat = $this.data('picker-format'),
              timeEnable = $this.data('picker-timepicker'),
              lang = $this.data('picker-lang'),
              myminDate = $this.data('picker-min-date'),
              mymaxDate = $this.data('picker-max-date'),
              rtlEnable = false; // If there is no data-xxx, save current source to it

          if (datepicker_typeof(dateFormat) === ( true ? "undefined" : undefined)) dateFormat = 'M d, Y'; //Y-m-d H:i:s

          if (datepicker_typeof(timeEnable) === ( true ? "undefined" : undefined)) timeEnable = false;
          if (datepicker_typeof(lang) === ( true ? "undefined" : undefined)) lang = 'en';
          if (datepicker_typeof(myminDate) === ( true ? "undefined" : undefined)) myminDate = false; //yesterday is minimum date(for today use 0 or -1970/01/01)

          if (datepicker_typeof(mymaxDate) === ( true ? "undefined" : undefined)) mymaxDate = false; //tomorrow is maximum date calendar, such as '+2050/01/01'

          if (datepicker_typeof(rtlEnable) === ( true ? "undefined" : undefined)) rtlEnable = false;
          $.datetimepicker.setLocale(lang); //RTL 

          if ($('body').hasClass('rtl')) {
            rtlEnable = true;
          } //hide or display time selector


          if (timeEnable) {
            $(document).on('mouseenter', 'td.xdsoft_date[data-date]', function () {
              if ($(this).hasClass('xdsoft_disabled')) {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').hide();
              } else {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').show();
              }
            });
          }

          $this.datetimepicker({
            rtl: rtlEnable,
            timepicker: timeEnable,
            format: dateFormat,
            formatTime: 'H:i',
            formatDate: 'Y/m/d',
            minDate: myminDate,
            maxDate: mymaxDate
          });
        }); //Dynamic listening for the latest value

        $(document).on('mouseleave', '[data-handler]', function () {
          $('[data-picker]').each(function () {
            $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
          });
        });
      } // function datetimepicker is exist

    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/fn/controls-hover.js
var controls_hover = __webpack_require__(34);

// EXTERNAL MODULE: ./src/components/form/js/fn/single-seletor.js
var single_seletor = __webpack_require__(35);

// EXTERNAL MODULE: ./src/components/form/js/fn/multi-seletor.js
var multi_seletor = __webpack_require__(36);

// EXTERNAL MODULE: ./src/components/form/js/fn/file-dropzone.js
var file_dropzone = __webpack_require__(37);

// EXTERNAL MODULE: ./src/components/form/js/fn/upload.js
var upload = __webpack_require__(38);

// EXTERNAL MODULE: ./src/components/form/js/fn/controls-disable.js
var controls_disable = __webpack_require__(39);

// EXTERNAL MODULE: ./src/components/form/js/fn/controls-line.js
var controls_line = __webpack_require__(40);

// EXTERNAL MODULE: ./src/components/form/js/fn/radio-and-checkbox.js
var radio_and_checkbox = __webpack_require__(41);

// EXTERNAL MODULE: ./src/components/form/scss/_basic.scss
var scss_basic = __webpack_require__(42);

// EXTERNAL MODULE: ./src/components/form/scss/_layout.scss
var _layout = __webpack_require__(43);

// EXTERNAL MODULE: ./src/components/form/scss/_theme_material.scss
var _theme_material = __webpack_require__(44);

// EXTERNAL MODULE: ./src/components/form/scss/_jquery.datetimepicker.scss
var _jquery_datetimepicker = __webpack_require__(45);

// CONCATENATED MODULE: ./src/components/form/js/index.js
function form_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function form_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { form_js_typeof = function _typeof(obj) { return typeof obj; }; } else { form_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return form_js_typeof(obj); }

/* 
 *************************************
 * <!-- Form -->
 *************************************
 */

/*
    Note:
	
	If you use the "change" event to asynchronously change a custom control of select, radio or checkbox, 
	you need add a callback function that initializes the style:
	

	$( document ).UixRenderCustomSelect(); //Render Custom Select
	$( document ).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox
	$( document ).UixRenderControlsLineEff(); //Create Line Effect on Click
	$( document ).UixRenderControlsDisable(); //Disabled Controls Status
	$( document ).UixRenderCustomFile(); //Render Custom File Type
	$( document ).UixRenderCustomFileDropzone(); //Render Custom File Dropzone
	$( document ).UixRenderControlsHover(); //Hover Effect
	$( document ).UixRenderCustomMultiSel(); //Render Multiple Selector Status
	$( document ).UixRenderCustomSingleSel(); //Render Single Selector Status
	$( document ).UixRenderNormalRadio(); //Render Normal Radio Status
	$( document ).UixRenderDatePicker(); //Render Date Picker

	
*/
















var FORM = function (module, $, window, document) {
  if (window.FORM === null) return false;
  module.FORM = module.FORM || {};
  module.FORM.version = '0.1.8';

  module.FORM.documentReady = function ($) {
    /*
     * Callbacks for special forms (supports asynchronous)
     * Add this code to initialize the style when calling 
     * the form externally with other scripts
     *
     * @return {Void}
     */
    var customSpecialFormsInit = function customSpecialFormsInit() {
      $(document).UixRenderCustomSelect(); //Render Custom Select

      $(document).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox

      $(document).UixRenderControlsLineEff(); //Create Line Effect on Click

      $(document).UixRenderControlsDisable(); //Disabled Controls Status

      $(document).UixRenderCustomFile(); //Render Custom File Type

      $(document).UixRenderCustomFileDropzone(); //Render Custom File Dropzone

      $(document).UixRenderControlsHover(); //Hover Effect

      $(document).UixRenderCustomMultiSel(); //Render Multiple Selector Status

      $(document).UixRenderCustomSingleSel(); //Render Single Selector Status

      $(document).UixRenderNormalRadio(); //Render Normal Radio Status

      $(document).UixRenderDatePicker(); //Render Date Picker	
    };

    customSpecialFormsInit();
    /* 
     ---------------------------
     Click Event of Submit Button
     ---------------------------
     */
    //Search Submit Event in WordPress

    $('.uix-search-box__submit').off('click').on('click', function () {
      $(this).closest('form').submit();
    });
    /* 
     ---------------------------
     Click Event of add / remove input field dynamically
     ---------------------------
     */

    $('.uix-controls__dynamic-fields-container').each(function () {
      var $this = $(this);
      var $addButton = $this.find('.uix-controls__dynamic-fields__addbtn'),
          //The add button
      $appendWrapper = $this.find('.uix-controls__dynamic-fields__append'),
          //The field wrapper ID or class 
      loopCls = '.uix-controls__dynamic-fields__tmpl__wrapper',
          defaultItems = $appendWrapper.find(loopCls).length;
      var x = defaultItems == 0 ? 1 : defaultItems + 1,
          maxField = $this.data('max-fields'),
          fieldHTML = ''; //Maximum number of forms added

      if (form_js_typeof(maxField) === ( true ? "undefined" : undefined)) {
        maxField = 5;
      } //Add a field


      var addOne = function addOne(fieldCode) {
        //replace the index of field name
        fieldCode = fieldCode.replace(/___GUID___/gi, UixGUID.create()); //hide add button

        if (x == maxField) $addButton.hide();

        if (x <= maxField) {
          $appendWrapper.append(fieldCode);
          $.when($appendWrapper.length > 0).then(function () {
            //Initialize Form
            customSpecialFormsInit();
          });
          x++;
        }
      }; // default item


      if (defaultItems == 0) {
        addOne($this.find('.uix-controls__dynamic-fields__tmpl').html());
      } //Prevent duplicate function assigned


      $addButton.off('click').off('click').on('click', function (e) {
        e.preventDefault(); //template init

        addOne($this.find('.uix-controls__dynamic-fields__tmpl').html()); //Remove per item
        //Prevent duplicate function assigned

        $this.find('.uix-controls__dynamic-fields__removebtn').off('click').on('click', function (e) {
          e.preventDefault(); //display add button

          $addButton.show(); //remove current item

          $(this).closest(loopCls).remove();
          x--;
        });
        return false;
      });
    });
    /* 
     ---------------------------
     Click Event of Custom Input Number 
     ---------------------------
     */

    $(document).off('click.FORM_NUMBER_BTN_ADD').on('click.FORM_NUMBER_BTN_ADD', '.uix-controls__number__btn--add', function (e) {
      var step = parseFloat($(this).data('step')),
          decimals = $(this).data('decimals'),
          $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
          numberInputVal = parseFloat($numberInput.val()),
          max = $numberInput.attr('max');
      if (form_js_typeof(step) === ( true ? "undefined" : undefined) || isNaN(step)) step = 1;
      if (form_js_typeof(decimals) === ( true ? "undefined" : undefined)) decimals = 0;

      if (form_js_typeof(max) != ( true ? "undefined" : undefined) && parseFloat(numberInputVal + step) > max) {
        step = 0;
      }

      numberInputVal = parseFloat(numberInputVal + step);
      $numberInput.val(numberInputVal.toFixed(decimals));
    });
    $(document).off('click.FORM_NUMBER_BTN_REMOVE').on('click.FORM_NUMBER_BTN_REMOVE', '.uix-controls__number__btn--remove', function (e) {
      var step = $(this).data('step'),
          decimals = $(this).data('decimals'),
          $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
          numberInputVal = parseFloat($numberInput.val()),
          min = $numberInput.attr('min');
      if (form_js_typeof(step) === ( true ? "undefined" : undefined) || isNaN(step)) step = 1;
      if (form_js_typeof(decimals) === ( true ? "undefined" : undefined)) decimals = 0;

      if (form_js_typeof(min) != ( true ? "undefined" : undefined) && parseFloat(numberInputVal - step) < min) {
        step = 0;
      }

      numberInputVal -= step;
      $numberInput.val(numberInputVal.toFixed(decimals));
    });
    /* 
     ---------------------------
     Click Event of Multiple Selector
     ---------------------------
     */

    var multiSel = '.uix-controls__multi-sel',
        multiSelItem = multiSel + ' > span';
    $(document).off('click.FORM_MULTI_SEL').on('click.FORM_MULTI_SEL', multiSelItem, function (e) {
      e.preventDefault();
      var $selector = $(this).parent(),
          $option = $(this),
          targetID = '#' + $selector.data("targetid"),
          curVal = $option.data('value'),
          tarVal = $(targetID).val() + ',',
          resVal = '';
      $option.toggleClass('is-active').attr('aria-checked', function (index, attr) {
        return attr == 'true' ? false : true;
      });

      if (tarVal.indexOf(curVal + ',') < 0) {
        resVal = tarVal + curVal + ',';
      } else {
        resVal = tarVal.replace(curVal + ',', '');
      }

      resVal = resVal.replace(/,\s*$/, '').replace(/^,/, '');
      $(targetID).val(resVal); //Dynamic listening for the latest value

      $(targetID).focus().blur();
    });
    /* 
     ---------------------------
     Click Event of Single Selector
     ---------------------------
     */

    var singleSel = '.uix-controls__single-sel',
        singleSelItem = singleSel + ' > span';
    /*
     * Initialize single switch
     *
     * @param  {Element} obj                 - Radio controls. 
     * @return {Void}
     */

    var hideAllSingleSelItems = function hideAllSingleSelItems(obj) {
      obj.each(function (index) {
        var $sel = $(this),
            defaultValue = $('#' + $sel.attr('data-targetid')).val(),
            deffaultSwitchIndex = 0; //get default selected switch index

        $sel.find('> span').each(function (index) {
          if (defaultValue == $(this).data('value')) {
            deffaultSwitchIndex = index;
          }
        });

        if (form_js_typeof($sel.data('switchids')) != ( true ? "undefined" : undefined) && $sel.data('switchids') != '') {
          var _switchIDsArr = $sel.data('switchids').split(',');

          _switchIDsArr.forEach(function (element, index) {
            if (deffaultSwitchIndex != index) {
              $('#' + element).hide();
            } else {
              $('#' + element).show();
            }
          });
        }
      });
    };

    hideAllSingleSelItems($(singleSel));
    $(document).off('click.FORM_SINGLE_SEL').on('click.FORM_SINGLE_SEL', singleSelItem, function (e) {
      e.preventDefault();
      var $selector = $(this).parent(),
          $option = $(this),
          targetID = '#' + $selector.data("targetid"),
          switchID = '#' + $option.data("switchid"),
          curVal = $option.data('value'); //Radio Selector

      $selector.find('> span').removeClass('is-active').attr('aria-checked', false);
      $(targetID).val(curVal);
      $option.addClass('is-active').attr('aria-checked', true); //Switch some options

      if (form_js_typeof($option.data("switchid")) != ( true ? "undefined" : undefined)) {
        hideAllSingleSelItems($selector);
        $(switchID).show();
      } //Dynamic listening for the latest value


      $(targetID).focus().blur();
    });
    /* 
     ---------------------------
     Click Event of Normal Radio
     ---------------------------
     */

    var normalRadio = '.uix-controls__radio',
        normalRadioItem = normalRadio + ' > label';
    /*
     * Initialize single switch
     *
     * @param  {Element} obj                 - Radio controls. 
     * @return {Void}
     */

    var hideAllNormalRadioItems = function hideAllNormalRadioItems(obj) {
      obj.each(function (index) {
        var $sel = $(this),
            defaultValue = $('#' + $sel.attr("data-targetid")).val(),
            deffaultSwitchIndex = 0; //get default selected switch index

        $sel.find('> label').each(function (index) {
          if (defaultValue == $(this).data('value')) {
            deffaultSwitchIndex = index;
          }
        });

        if (form_js_typeof($sel.data('switchids')) != ( true ? "undefined" : undefined) && $sel.data('switchids') != '') {
          var _switchIDsArr = $sel.data('switchids').split(',');

          _switchIDsArr.forEach(function (element, index) {
            if (deffaultSwitchIndex != index) {
              $('#' + element).hide();
            } else {
              $('#' + element).show();
            }
          });
        }
      });
    };

    hideAllNormalRadioItems($(normalRadio));
    $(document).off('click.FORM_NORMAL_RADIO').on('click.FORM_NORMAL_RADIO', normalRadioItem, function (e) {
      e.preventDefault();
      var $selector = $(this).parent(),
          $option = $(this),
          targetID = '#' + $selector.data("targetid"),
          switchID = '#' + $option.data("switchid"),
          curVal = $option.data('value'); //Radio Selector

      $selector.find('> label').removeClass('is-active').find('[type="radio"]').prop('checked', false);
      $(targetID).val(curVal);
      $option.addClass('is-active').find('[type="radio"]').prop('checked', true); //Switch some options

      if (form_js_typeof($option.data("switchid")) != ( true ? "undefined" : undefined)) {
        hideAllNormalRadioItems($selector);
        $(switchID).show();
      } //Dynamic listening for the latest value


      $(targetID).focus().blur();
    });
    /* 
     ---------------------------
     Click Event of Checkbox and Toggle 
     ---------------------------
     */

    var checkboxSel = '.uix-controls__toggle [type="checkbox"], .uix-controls__checkbox [type="checkbox"]';
    $(document).on('change', checkboxSel, function (e) {
      //hide or display a associated div
      var $obj = $(this).closest('.uix-controls'),
          targetID = '#' + $obj.attr('data-targetid');

      if (this.checked) {
        $obj.addClass('is-active').attr('aria-checked', true);
        $(targetID).show();
      } else {
        $obj.removeClass('is-active').attr('aria-checked', false);
        $(targetID).hide();
      }
    });
  };

  module.components.documentReady.push(module.FORM.documentReady);
  return function FORM() {
    form_js_classCallCheck(this, FORM);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/gallery/scss/_style.scss
var gallery_scss_style = __webpack_require__(46);

// CONCATENATED MODULE: ./src/components/gallery/js/index.js
function gallery_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Gallery -->
 *************************************
 */


var GALLERY = function (module, $, window, document) {
  if (window.GALLERY === null) return false;
  module.GALLERY = module.GALLERY || {};
  module.GALLERY.version = '0.0.5';

  module.GALLERY.documentReady = function ($) {
    $('.uix-gallery').each(function () {
      var galleryType = $(this).data('show-type');
      /* 
       ---------------------------
       Add a tagname to each list item
       ---------------------------
       */
      // Masonry

      if (galleryType.indexOf('masonry') >= 0) {
        $(this).addClass('masonry-container');
        $(this).find('.uix-gallery__item').addClass('masonry-item');
      } // Filterable


      if (galleryType.indexOf('filter') >= 0) {
        $(this).addClass('filter-container');
        $(this).find('.uix-gallery__item').addClass('filter-item');
      }

      if (galleryType.indexOf('filter') >= 0 || galleryType.indexOf('masonry') >= 0) {
        var filterCat = $(this).data('filter-id'),
            $grid = $(this).find('.uix-gallery__tiles'),
            $allItems = $(this).find('.uix-gallery__item'),
            $filterOptions = $(filterCat);
        var MuuriGrid = new Muuri($grid.get(0), {
          items: $grid.get(0).querySelectorAll('.uix-gallery__item'),
          // Default show animation
          showDuration: 300,
          showEasing: 'ease',
          // Default hide animation
          hideDuration: 300,
          hideEasing: 'ease',
          // Item's visible/hidden state styles
          visibleStyles: {
            opacity: '1',
            transform: 'scale(1)'
          },
          hiddenStyles: {
            opacity: '0',
            transform: 'scale(0.5)'
          },
          // Layout
          layout: {
            fillGaps: false,
            horizontal: false,
            alignRight: false,
            alignBottom: false,
            rounding: true
          },
          layoutOnResize: 100,
          layoutOnInit: true,
          layoutDuration: 300,
          layoutEasing: 'ease',
          //// Drag & Drop
          dragEnabled: false
        }); // When all items have loaded refresh their
        // dimensions and layout the grid.

        $grid.waitForImages().done(function () {
          MuuriGrid.refreshItems().layout(); // For a little finishing touch, let's fade in
          // the images after all them have loaded and
          // they are corrertly positioned.

          $('body').addClass('images-loaded');
        });
        /* 
         ---------------------------
         Function of Filterable and Masonry
         ---------------------------
         */

        if (galleryType.indexOf('filter') >= 0) {
          $filterOptions.find('li > a').off('click').on('click', function () {
            var $this = $(this);
            var activeClass = 'current-cat',
                isActive = $this.parent().hasClass(activeClass),
                group = isActive ? 'all' : $this.data('group'); // Hide current label, show current label in title

            if (!isActive) {
              $filterOptions.find('.' + activeClass).removeClass(activeClass);
            }

            $this.parent().toggleClass(activeClass); // Filter elements

            var filterFieldValue = group;
            MuuriGrid.filter(function (item) {
              var element = item.getElement(),
                  curCats = element.getAttribute('data-groups').toString().replace(/^\,|\,$/g, '').replace(/^\[|\]$/g, '') + ',all',
                  isFilterMatch = !filterFieldValue ? true : (curCats || '').indexOf(filterFieldValue) > -1;
              return isFilterMatch;
            });
            return false;
          });
        } else {
          //remove filter button of all
          $filterOptions.find('[data-group="all"]').parent('li').remove();
        }
      }
    });
  };

  module.components.documentReady.push(module.GALLERY.documentReady);
  return function GALLERY() {
    gallery_js_classCallCheck(this, GALLERY);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/hybrid-content-slider/scss/_style.scss
var hybrid_content_slider_scss_style = __webpack_require__(47);

// CONCATENATED MODULE: ./src/components/hybrid-content-slider/js/index.js
function hybrid_content_slider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function hybrid_content_slider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hybrid_content_slider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { hybrid_content_slider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hybrid_content_slider_js_typeof(obj); }

/* 
 *************************************
 * <!-- Hybrid Content Slider -->
 *************************************
 */


var HYBRID_CONTENT_SLIDER = function (module, $, window, document) {
  if (window.HYBRID_CONTENT_SLIDER === null) return false;
  module.HYBRID_CONTENT_SLIDER = module.HYBRID_CONTENT_SLIDER || {};
  module.HYBRID_CONTENT_SLIDER.version = '0.0.95';

  module.HYBRID_CONTENT_SLIDER.pageLoaded = function () {
    $('.uix-hybrid-content-slider').each(function () {
      var $carouselWrapper = $(this),
          $carousel = $carouselWrapper.find('.uix-hybrid-content-slider__items'),
          $carouselItem = $carouselWrapper.find('.uix-hybrid-content-slider__items > div'),
          itemTotal = $carouselItem.length,
          amountVisible = 1,
          carouselDir = $carouselWrapper.data('dir'),
          carouselSpeed = $carouselWrapper.data('speed'),
          carouselNext = $carouselWrapper.data('next'),
          carouselPrev = $carouselWrapper.data('prev'),
          carouselPagination = $carouselWrapper.data('pagination'),
          carouseDraggable = $carouselWrapper.data('draggable'),
          carouseDraggableCursor = $carouselWrapper.data('draggable-cursor');
      if (hybrid_content_slider_js_typeof(carouselDir) === ( true ? "undefined" : undefined)) carouselDir = 'horizontal';
      if (hybrid_content_slider_js_typeof(carouselSpeed) === ( true ? "undefined" : undefined)) carouselSpeed = 250;
      if (hybrid_content_slider_js_typeof(carouselNext) === ( true ? "undefined" : undefined)) carouselNext = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--next';
      if (hybrid_content_slider_js_typeof(carouselPrev) === ( true ? "undefined" : undefined)) carouselPrev = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--prev';
      if (hybrid_content_slider_js_typeof(carouselPagination) === ( true ? "undefined" : undefined)) carouselPagination = '#uix-hybrid-content-slider__pagination-123';
      if (hybrid_content_slider_js_typeof(carouseDraggable) === ( true ? "undefined" : undefined)) carouseDraggable = false;
      if (hybrid_content_slider_js_typeof(carouseDraggableCursor) === ( true ? "undefined" : undefined)) carouseDraggableCursor = 'move'; //Autoplay parameters

      var dataAuto = $carouselWrapper.data('auto'),
          dataTiming = $carouselWrapper.data('timing'),
          dataLoop = $carouselWrapper.data('loop');
      if (hybrid_content_slider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
      if (hybrid_content_slider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
      if (hybrid_content_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

      var playTimes; //A function called "timer" once every second (like a digital watch).

      $carouselWrapper[0].animatedSlides; //Store the latest position (X,Y) in a temporary variable

      var tempItemsPos = []; //each item width and height

      var eachItemNewWidth,
          eachItemNewHeight = []; // Returns the value of a number rounded to the nearest integer.

      var midIndex = 0; // Get the width and height of each item

      $carouselItem.each(function (index) {
        var _height = $(this).height();

        eachItemNewHeight.push(_height);
        $(this).attr({
          'data-height': _height,
          'data-index': index
        });
      }); //Returns the total height of items

      var totalItemsHeight = 0;

      for (var i = 0; i < eachItemNewHeight.length; i++) {
        totalItemsHeight += eachItemNewHeight[i];
        if (i + 1 == itemTotal - amountVisible) break;
      } //Set target index of the carousel buttons


      setButtonTargetIndex($(carouselNext), $(carouselPrev), 'init', null); //set actived item & initialize the height of container

      setContainerSize(0);
      $carouselItem.addClass('js-is-ready'); // Activate the current item from carouse

      setItemState(0);
      /* 
       ---------------------------
       Initialize carousel
       ---------------------------
       */

      var eachItemOldWidth = $carousel.width() / amountVisible;
      eachItemNewWidth = $carouselWrapper.width() / amountVisible;

      if (carouselDir == 'horizontal') {
        $carousel.css('width', itemTotal * eachItemOldWidth);
      } // Re-order all items


      carouselReOrder(); //default button status

      $(carouselPrev).addClass('is-disabled').data('disabled', 1);
      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */

      function carouselReOrder() {
        //Initialize the width and height of each item
        if (carouselDir == 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($carouselItem, {
            width: boxWidth,
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            x: function x(i, target) {
              return i * boxWidth;
            }
          });
        } else {
          TweenMax.set($carouselItem, {
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            y: function y(i, target) {
              var yIncrement = 0;

              for (var k = 0; k < eachItemNewHeight.length; k++) {
                var tempY = hybrid_content_slider_js_typeof(eachItemNewHeight[k - 1]) === ( true ? "undefined" : undefined) ? 0 : eachItemNewHeight[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }

              return yIncrement;
            }
          });
        }
      }
      /* 
       ---------------------------
       Move left/up
       ---------------------------
       */


      $(carouselNext).off('click').on('click', $carouselWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(carouselSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        movePositionWithButton(false, $(this), e, 'next'); //Pause the auto play event

        clearInterval($carouselWrapper[0].animatedSlides);
      });
      /* 
       ---------------------------
       Move right/down
       ---------------------------
       */

      $(carouselPrev).off('click').on('click', $carouselWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(carouselSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        movePositionWithButton(false, $(this), e, 'prev'); //Pause the auto play event

        clearInterval($carouselWrapper[0].animatedSlides);
      });
      /* 
       ---------------------------
       Pagination
       ---------------------------
       */

      if ($(carouselPagination).length > 0 && $(carouselPagination).html().length == 0) {
        //Button to add pagination automatically
        var _dot = '';
        _dot += '<ul class="uix-hybrid-content-slider__pagination--default">';

        for (var _i = 0; _i < itemTotal; _i++) {
          _dot += '<li><a data-target-index="' + _i + '" href="javascript:void(0);"></a></li>';
        }

        _dot += '</ul>';
        $(carouselPagination).html(_dot).promise().done(function () {
          // Activate the currently selected Pagination
          setPaginationState(0);
        });
      } else {
        // Activate the currently selected Pagination
        setPaginationState(0);
      }

      $(carouselPagination).find('li a').off('click').on('click', $carouselWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(carouselPagination).find('li a').attr('aria-disabled', 'true');
        $(carouselPagination).find('li a').delay(carouselSpeed).queue(function (next) {
          $(carouselPagination).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).parent().hasClass('is-active')) {
          movePositionWithButton(true, $(this), e, 'next'); //Pause the auto play event

          clearInterval($carouselWrapper[0].animatedSlides);
        }
      }); //Drag and Drop
      //-------------------------------------	

      var $dragDropTrigger = $carouselWrapper;
      var hammerProps = {}; //Make the cursor a move icon when a user hovers over an item

      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);

      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true;
      var targetIndex = 0; //Temporarily store arrays as strings
      //!!!important ///////////////////////////////////////
      //!!! Prevent dragging events from nesting multiple 
      //!!! times to reduce subscripts.
      //!!!important ///////////////////////////////////////

      var allHeightStr = eachItemNewHeight.toString(); // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type; //Get the current item index

        targetIndex = $(ev.target).data('index');
        if (hybrid_content_slider_js_typeof(targetIndex) === ( true ? "undefined" : undefined)) targetIndex = $(ev.target).closest('.uix-hybrid-content-slider__item').data('index');
        if (hybrid_content_slider_js_typeof(targetIndex) === ( true ? "undefined" : undefined)) targetIndex = $(ev.target).find('.uix-hybrid-content-slider__item').data('index');

        switch (direction) {
          case 'panleft':
          case 'panup':
            targetIndex = targetIndex + 1;
            break;

          case 'panright':
          case 'pandown':
            targetIndex = targetIndex;
            break;
        } //Determine whether it is the first or the last    


        var currentIsFirstOrLast = false;
        var firstItemOffset = carouselDir == 'horizontal' ? $carousel.find('[data-index="0"]')[0]._gsTransform.x : $carousel.find('[data-index="0"]')[0]._gsTransform.y;
        var maxMoveOffset = carouselDir == 'horizontal' ? -eachItemNewWidth * (itemTotal - amountVisible) : -totalItemsHeight; //

        if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
          //first item
          currentIsFirstOrLast = true;
        }

        if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
          //last item
          currentIsFirstOrLast = true;
        } //Rebound effect of drag offset 
        //
        //!important -> Please do not use multiple case conditions, 
        //otherwise it may cause vertical data problems


        if (carouselDir == 'horizontal') {
          switch (direction) {
            case 'panleft':
              if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
                elAnim = false;
                var simulationButtonNext = $(carouselNext);
                itemUpdates($carouselWrapper, simulationButtonNext, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;

            case 'panright':
              if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
                elAnim = false;
                var simulationButtonPrev = $(carouselPrev);
                itemUpdates($carouselWrapper, simulationButtonPrev, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;
          }
        } else {
          var draggingItemHeight = hybrid_content_slider_js_typeof(allHeightStr.split(',')[targetIndex - 1]) === ( true ? "undefined" : undefined) ? allHeightStr.split(',')[targetIndex] : allHeightStr.split(',')[targetIndex - 1];

          switch (direction) {
            case 'panup':
              if (ev.deltaY > -draggingItemHeight / 4 && ev.deltaY < 0) {
                elAnim = false;

                var _simulationButtonNext = $(carouselNext);

                itemUpdates($carouselWrapper, _simulationButtonNext, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;

            case 'pandown':
              if (ev.deltaY < draggingItemHeight / 4 && ev.deltaY > 0) {
                elAnim = false;

                var _simulationButtonPrev = $(carouselPrev);

                itemUpdates($carouselWrapper, _simulationButtonPrev, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;
          }
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          //
          //!important -> Please do not use multiple case conditions, 
          //otherwise it may cause vertical data problems
          if (carouselDir == 'horizontal') {
            switch (direction) {
              case 'panleft':
                var deltaNext = -eachItemNewWidth;
                var simulationButtonNext = $(carouselNext);
                itemUpdates($carouselWrapper, simulationButtonNext, deltaNext, null, false, targetIndex, allHeightStr);
                break;

              case 'panright':
                var deltaPrev = eachItemNewWidth;
                var simulationButtonPrev = $(carouselPrev);
                itemUpdates($carouselWrapper, simulationButtonPrev, deltaPrev, null, false, targetIndex, allHeightStr);
                break;
            }
          } else {
            switch (direction) {
              case 'panup':
                var _deltaNext = -1;

                var _simulationButtonNext2 = $(carouselNext);

                itemUpdates($carouselWrapper, _simulationButtonNext2, _deltaNext, null, false, targetIndex, allHeightStr);
                break;

              case 'pandown':
                var _deltaPrev = -1;

                var _simulationButtonPrev2 = $(carouselPrev);

                itemUpdates($carouselWrapper, _simulationButtonPrev2, _deltaPrev, null, false, targetIndex, allHeightStr);
                break;
            }
          }
        } else {
          //Rebound effect of drag offset 
          itemUpdates($carouselWrapper, null, tempItemsPos, null, false, targetIndex, allHeightStr);
        } //Pause the auto play event


        clearInterval($carouselWrapper[0].animatedSlides);
      }); //Autoplay Slider
      //-------------------------------------		

      if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
        sliderAutoPlay(playTimes, dataTiming, dataLoop);
        $carouselWrapper.on({
          mouseenter: function mouseenter() {
            clearInterval($carouselWrapper[0].animatedSlides);
          },
          mouseleave: function mouseleave() {
            sliderAutoPlay(playTimes, dataTiming, dataLoop);
          }
        });
      }
      /*
       * Trigger slider autoplay
       *
       * @param  {Function} playTimes      - Number of times.
       * @param  {Number} timing           - Autoplay interval.
       * @param  {Boolean} loop            - Gives the slider a seamless infinite loop.
       * @return {Void}             
       */


      function sliderAutoPlay(playTimes, timing, loop) {
        $carouselWrapper[0].animatedSlides = setInterval(function () {
          var autoMove = function autoMove(indexGo) {
            // Retrieve the position (X,Y) of an element 
            var moveX = eachItemNewWidth * indexGo;
            var moveYIncrement = 0;

            for (var k = 0; k < eachItemNewHeight.length; k++) {
              var tempY = hybrid_content_slider_js_typeof(eachItemNewHeight[k - 1]) === ( true ? "undefined" : undefined) ? 0 : eachItemNewHeight[k - 1];
              moveYIncrement += tempY;
              if (k == indexGo) break;
            }

            var moveY = moveYIncrement; //

            var delta = carouselDir == 'horizontal' ? -moveX : -moveY; //

            itemUpdates($carouselWrapper, 'auto', delta, null, false, indexGo, eachItemNewHeight);
          };

          playTimes = parseFloat($carouselItem.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < itemTotal && playTimes >= 0) {
              autoMove(playTimes);
            }
          } else {
            if (playTimes == itemTotal) playTimes = 0;
            if (playTimes < 0) playTimes = itemTotal - 1;
            autoMove(playTimes);
          }
        }, timing);
      }
      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper            - Wrapper of carousel.
       * @param  {?Element|String} curBtn     - The button that currently triggers the move.
                * @param  {Number|Array} delta         - The value returned will need to be adjusted according to the offset rate.
                * @param  {?Number} speed              - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging           - Determine if the object is being dragged.
                * @param  {!Number} indexGo            - The target item index.
                * @param  {String|Array} itemsHeight   - Return all items height.
       * @return {Void}
       */


      function itemUpdates(wrapper, curBtn, delta, speed, dragging, indexGo, itemsHeight) {
        if (speed == null) speed = carouselSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-hybrid-content-slider__items'),
            //Default: $carousel
        $curItems = $curWrapper.find('> div'); //Default: $carouselItem
        //Get height constant

        var itemsHeightArr = [];

        var _itemsHeight = itemsHeight.toString().split(',');

        _itemsHeight.forEach(function (element) {
          itemsHeightArr.push(parseFloat(element));
        }); //Check next or previous event


        var btnType = 'init';

        if (curBtn != null && curBtn != 'auto') {
          if (hybrid_content_slider_js_typeof(curBtn.attr('class')) !== ( true ? "undefined" : undefined)) {
            btnType = curBtn.attr('class').indexOf('--next') >= 0 ? 'next' : 'prev';
          } else {
            btnType = 'next';
          }
        } //Check next or previous event ( Autoplay )


        if (curBtn == 'auto') btnType = 'next';
        ; //Clone the first element to the last position

        if (carouselDir == 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var xIncrement = 0;

              for (var k = 0; k < itemTotal; k++) {
                var tempX = k == 0 ? 0 : boxWidth;
                xIncrement += tempX;
                if (k == i) break;
              }

              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? xIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );
                  var curWidthIncrement = 0;

                  for (var m = 0; m < itemTotal; m++) {
                    var tempW = m == 0 ? 0 : boxWidth;
                    curWidthIncrement += tempW;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }

                  return xIncrement + -curWidthIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
                  return x + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //Get index of current element
                var currentIndex = 0; //The state of the control button

                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth)); //Initialize the height of container

                currentIndex = Math.round($curItems.first()[0]._gsTransform.x / boxWidth);
                setContainerSize(currentIndex); //Set target index of the carousel buttons

                setButtonTargetIndex($(carouselNext), $(carouselPrev), btnType, btnType == 'next' ? Math.abs(currentIndex) : Math.abs(currentIndex) + 1); // Activate the currently selected Pagination

                setPaginationState(Math.abs(currentIndex)); // Activate the current item from carouse

                setItemState(Math.abs(currentIndex)); //Store the latest position (X,Y) in a temporary variable

                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        } else {
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var yIncrement = 0;

              for (var k = 0; k < itemsHeightArr.length; k++) {
                var tempY = hybrid_content_slider_js_typeof(itemsHeightArr[k - 1]) === ( true ? "undefined" : undefined) ? 0 : itemsHeightArr[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }

              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? yIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );
                  var curHeightIncrement = 0;

                  for (var m = 0; m < itemsHeightArr.length; m++) {
                    var tempH = hybrid_content_slider_js_typeof(itemsHeightArr[m - 1]) === ( true ? "undefined" : undefined) ? 0 : itemsHeightArr[m - 1];
                    curHeightIncrement += tempH;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }

                  return yIncrement + -curHeightIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var draggingItemHeight = hybrid_content_slider_js_typeof(itemsHeightArr[indexGo - 1]) === ( true ? "undefined" : undefined) ? itemsHeightArr[indexGo] : itemsHeightArr[indexGo - 1];
                  var y = Math.round(target._gsTransform.y / draggingItemHeight) * draggingItemHeight;
                  return y + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //The state of the control button
                setButtonState($curItems.first()[0]._gsTransform.y, totalItemsHeight); //Set target index of the carousel buttons

                setButtonTargetIndex($(carouselNext), $(carouselPrev), btnType, indexGo); //set actived item & initialize the height of container

                setContainerSize(btnType == 'next' ? indexGo : indexGo - 1); // Activate the currently selected Pagination

                setPaginationState(btnType == 'next' ? indexGo : indexGo - 1); // Activate the current item from carouse

                setItemState(btnType == 'next' ? indexGo : indexGo - 1); //Store the latest position (X,Y) in a temporary variable

                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        }
      }
      /*
       * Use the button to trigger the transition between the two sliders
       *
       * @param  {Boolean} paginationEnable   - Determine whether it is triggered by pagination
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {Object} event               - Bind an event handler to the "click" JavaScript event,
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */


      function movePositionWithButton(paginationEnable, $btn, event, type) {
        var $curWrapper = $(event.data[0]),
            //Protection button is not triggered multiple times.
        btnDisabled = $btn.data('disabled'),
            //Get current button index
        tIndex = parseFloat($btn.attr('data-target-index')); // Retrieve the position (X,Y) of an element 

        var moveX = eachItemNewWidth,
            moveY = hybrid_content_slider_js_typeof(eachItemNewHeight[tIndex - 1]) === ( true ? "undefined" : undefined) ? 0 : eachItemNewHeight[tIndex - 1];

        if (paginationEnable) {
          //--
          moveX = eachItemNewWidth * tIndex; //--

          var moveYIncrement = 0;

          for (var k = 0; k < eachItemNewHeight.length; k++) {
            var tempY = hybrid_content_slider_js_typeof(eachItemNewHeight[k - 1]) === ( true ? "undefined" : undefined) ? 0 : eachItemNewHeight[k - 1];
            moveYIncrement += tempY;
            if (k == tIndex) break;
          }

          moveY = moveYIncrement;
        } //


        var delta;

        if (type == 'next') {
          delta = carouselDir == 'horizontal' ? -moveX : -moveY;
        } else {
          delta = carouselDir == 'horizontal' ? moveX : moveY;
        }

        if (hybrid_content_slider_js_typeof(btnDisabled) === ( true ? "undefined" : undefined)) {
          itemUpdates($curWrapper, $btn, delta, null, false, tIndex, eachItemNewHeight);
        }
      }
      /*
       * Activate the currently selected Pagination
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setPaginationState(index) {
        $(carouselPagination).find('li').removeClass('is-active');
        $(carouselPagination).find('li a[data-target-index="' + index + '"]').parent().addClass('is-active');
      }
      /*
       * Activate the current item from carouse
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setItemState(index) {
        $carouselItem.removeClass('is-active');
        $carouselItem.eq(index).addClass('is-active');
      }
      /*
       * Store the latest position (X,Y) in a temporary variable
       *
       * @return {Array}              - Return to a new position.
       */


      function createStoreLatestPosition() {
        var pos = []; // Retrieve the temporary variable of each item.

        $carouselItem.each(function () {
          pos.push(carouselDir == 'horizontal' ? $(this)[0]._gsTransform.x : $(this)[0]._gsTransform.y);
        });
        return pos;
      }
      /*
       * Initialize the height of container
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setContainerSize(index) {
        var _h = eachItemNewHeight[Math.abs(index)];

        if (hybrid_content_slider_js_typeof(_h) !== ( true ? "undefined" : undefined)) {
          TweenMax.to($carousel, 0.2, {
            height: eachItemNewHeight[Math.abs(index)]
          });
        }
      }
      /*
       * Set target index of the carousel buttons
       *
       * @param  {Element} nextBtn      - The next move button.
       * @param  {Element} prevBtn      - The previous move button.
                * @param  {String} type          - The type of button is triggered. Values: next, prev, init
                * @param  {?Number} indexGo      - The target item index.
       * @return {Void}
       */


      function setButtonTargetIndex(nextBtn, prevBtn, type, indexGo) {
        switch (type) {
          case 'init':
            nextBtn.attr({
              'data-target-index': 1
            });
            prevBtn.attr({
              'data-target-index': 0
            });
            break;

          case 'next':
            var nextBtnOldTargetIndex1 = parseFloat(nextBtn.attr('data-target-index'));
            var prevBtnOldTargetIndex1 = parseFloat(prevBtn.attr('data-target-index'));

            if (indexGo != null) {
              nextBtnOldTargetIndex1 = indexGo;
              prevBtnOldTargetIndex1 = indexGo - 1;
            }

            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex1 + 1
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex1 + 1
            });
            break;

          case 'prev':
            var nextBtnOldTargetIndex2 = parseFloat(nextBtn.attr('data-target-index')) - 1;
            var prevBtnOldTargetIndex2 = parseFloat(prevBtn.attr('data-target-index')) - 1;

            if (indexGo != null) {
              nextBtnOldTargetIndex2 = indexGo;
              prevBtnOldTargetIndex2 = indexGo - 1;
            }

            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex2
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex2
            });
            break;
        }
      }
      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */


      function setButtonState(firstOffset, lastOffset) {
        if (Math.abs(firstOffset) == lastOffset) {
          $(carouselNext).addClass('is-disabled').data('disabled', 1);
          $(carouselPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(carouselNext).removeClass('is-disabled').removeData('disabled');
          $(carouselPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(carouselNext).removeClass('is-disabled').removeData('disabled');
          $(carouselPrev).removeClass('is-disabled').removeData('disabled');
        }
      }
    });
  };

  module.components.pageLoaded.push(module.HYBRID_CONTENT_SLIDER.pageLoaded);
  return function HYBRID_CONTENT_SLIDER() {
    hybrid_content_slider_js_classCallCheck(this, HYBRID_CONTENT_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/hover-delay-interaction/js/index.js
function hover_delay_interaction_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Hover Delay Interaction -->
 *************************************
 */

var HOVER_DELAY_INTERACTION = function (module, $, window, document) {
  if (window.HOVER_DELAY_INTERACTION === null) return false;
  module.HOVER_DELAY_INTERACTION = module.HOVER_DELAY_INTERACTION || {};
  module.HOVER_DELAY_INTERACTION.version = '0.0.1';

  module.HOVER_DELAY_INTERACTION.documentReady = function ($) {
    var delayTime = 250;
    $('.uix-hover-delay-el').on('mouseover', function () {
      var $this = $(this);

      if ($this.prop('hoverTimeout')) {
        $this.prop('hoverTimeout', clearTimeout($this.prop('hoverTimeout')));
      }

      $this.prop('hoverIntent', setTimeout(function () {
        $this.find('> div').html('Okay!');
      }, delayTime));
    }).on('mouseleave', function () {
      var $this = $(this);

      if ($this.prop('hoverIntent')) {
        $this.prop('hoverIntent', clearTimeout($this.prop('hoverIntent')));
      }

      $this.prop('hoverTimeout', setTimeout(function () {
        $this.find('> div').html('Touch Me');
      }, delayTime));
    });
  };

  module.components.documentReady.push(module.HOVER_DELAY_INTERACTION.documentReady);
  return function HOVER_DELAY_INTERACTION() {
    hover_delay_interaction_js_classCallCheck(this, HOVER_DELAY_INTERACTION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/image-shapes/scss/_style.scss
var image_shapes_scss_style = __webpack_require__(48);

// CONCATENATED MODULE: ./src/components/image-shapes/js/index.js
function image_shapes_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Image Shapes -->
 *************************************
 */


var IMAGE_SHAPES = function (module, $, window, document) {
  if (window.IMAGE_SHAPES === null) return false;
  module.IMAGE_SHAPES = module.IMAGE_SHAPES || {};
  module.IMAGE_SHAPES.version = '0.0.1';

  module.IMAGE_SHAPES.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    shapesInit(windowWidth);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        shapesInit(windowWidth);
      }
    });
    /*
     * Initialize Shapes
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function shapesInit(w) {
      $('.uix-shape-img').each(function () {
        var $this = $(this);
        var ranID = 'uix-shape-img-' + UixGUID.create(),
            svgPath = $this.data('path'),
            svgW = parseFloat($this.data('svg-const-width')),
            svgH = parseFloat($this.data('svg-const-height')),
            svgRatio = svgW / svgH,
            curImgURL = $this.find('img').attr('src');
        var imgW = parseFloat($this.data('img-width'));
        var imgRatio = null,
            bothWidthRatio = null,
            newSvgHeight = null,
            newImgHeight = null,
            svgOut = '',
            curImgW = imgW,
            curImgH = null;

        if (imgW > w) {
          imgW = w;
        } //Check if the picture is loaded on the page


        var img = new Image();

        img.onload = function () {
          curImgH = $this.find('img').height();
          curImgW = $this.find('img').width();
          imgRatio = curImgW / curImgH; //Add a custom shape SVG to the page

          bothWidthRatio = imgW / svgW;
          newSvgHeight = imgW / svgRatio;
          newImgHeight = svgW / imgRatio;
          svgOut += '<svg fill-rule="evenodd" clip-rule="evenodd" width="' + imgW + 'px" height="' + newSvgHeight + 'px" viewBox="0 0 ' + imgW + ' ' + newSvgHeight + '" >';
          svgOut += '	<pattern id="' + ranID + '" patternUnits="userSpaceOnUse" width="' + svgW + '" height="' + svgH + '">';
          svgOut += '		  <image xlink:href="' + curImgURL + '" width="' + svgW + 'px" height="' + newImgHeight + 'px" x="0" y="0" />';
          svgOut += '	</pattern> ';
          svgOut += '	<path fill="url(#' + ranID + ')" transform="scale(' + bothWidthRatio + ')" d="' + svgPath + '"/>';
          svgOut += '</svg>';
          $this.addClass('is-active').html(svgOut);
        };

        img.src = curImgURL;
      });
    }
  };

  module.components.documentReady.push(module.IMAGE_SHAPES.documentReady);
  return function IMAGE_SHAPES() {
    image_shapes_js_classCallCheck(this, IMAGE_SHAPES);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/infinite-scrolling-element/scss/_style.scss
var infinite_scrolling_element_scss_style = __webpack_require__(49);

// CONCATENATED MODULE: ./src/components/infinite-scrolling-element/js/index.js
function infinite_scrolling_element_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function infinite_scrolling_element_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { infinite_scrolling_element_js_typeof = function _typeof(obj) { return typeof obj; }; } else { infinite_scrolling_element_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return infinite_scrolling_element_js_typeof(obj); }

/* 
 *************************************
 * <!-- Infinite Scrolling Element -->
 *************************************
 */


var INFINITE_SCROLLING_EL = function (module, $, window, document) {
  if (window.INFINITE_SCROLLING_EL === null) return false;
  module.INFINITE_SCROLLING_EL = module.INFINITE_SCROLLING_EL || {};
  module.INFINITE_SCROLLING_EL.version = '0.0.2';

  module.INFINITE_SCROLLING_EL.documentReady = function ($) {
    $('.uix-infinite-scrolling').each(function () {
      var $this = $(this);
      var speed = $this.data('speed');

      if (infinite_scrolling_element_js_typeof(speed) === ( true ? "undefined" : undefined)) {
        speed = 3000;
      }

      var $list = $this.find('> ul');
      var $clonedList = $list.clone(); //Calculate the total width

      var listWidth = $list.find('li:first').width();
      $list.find('li').each(function (i) {
        listWidth += $(this, i).width();
      }); // Set the width of the outer container to match the width of the content

      $this.css('width', listWidth + 'px'); //

      $list.add($clonedList);
      $clonedList.addClass('cloned').appendTo($this); //TimelineMax

      var tl = new TimelineMax({
        repeat: -1,
        paused: true
      });
      var time = speed / 1000;
      tl.fromTo($list, time, {
        rotation: 0.01,
        x: 0
      }, {
        force3D: true,
        x: -listWidth,
        ease: Linear.easeNone
      }, 0).fromTo($clonedList, time, {
        rotation: 0.01,
        x: listWidth
      }, {
        force3D: true,
        x: 0,
        ease: Linear.easeNone
      }, 0).set($list, {
        force3D: true,
        rotation: 0.01,
        x: listWidth
      }).to($clonedList, time, {
        force3D: true,
        rotation: 0.01,
        x: -listWidth,
        ease: Linear.easeNone
      }, time).to($list, time, {
        force3D: true,
        rotation: 0.01,
        x: 0,
        ease: Linear.easeNone
      }, time).progress(1).progress(0).play(); //Pause/Play		

      $this.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();
      });
    });
  };

  module.components.documentReady.push(module.INFINITE_SCROLLING_EL.documentReady);
  return function INFINITE_SCROLLING_EL() {
    infinite_scrolling_element_js_classCallCheck(this, INFINITE_SCROLLING_EL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/lava-lamp-style-menu/scss/_style.scss
var lava_lamp_style_menu_scss_style = __webpack_require__(50);

// CONCATENATED MODULE: ./src/components/lava-lamp-style-menu/js/index.js
function lava_lamp_style_menu_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Lava-Lamp Style Menu -->
 *************************************
 */


var LAVA_LAMP_STYLE_MENU = function (module, $, window, document) {
  if (window.LAVA_LAMP_STYLE_MENU === null) return false;
  module.LAVA_LAMP_STYLE_MENU = module.LAVA_LAMP_STYLE_MENU || {};
  module.LAVA_LAMP_STYLE_MENU.version = '0.0.3';

  module.LAVA_LAMP_STYLE_MENU.documentReady = function ($) {
    var $menuContainer = $('.uix-lavalamp-menu__container'),
        menu = 'ul.uix-lavalamp-menu',
        followEl = menu + ' .uix-lavalamp-menu__slide-line'; //Prevent this module from loading in other pages

    if ($menuContainer.length == 0) return false; // adds sliding underline HTML

    $(menu).append('<span class="uix-lavalamp-menu__slide-line"></span>'); // set initial position of element

    TweenMax.set(followEl, {
      css: {
        width: 0,
        x: 0,
        y: 0
      }
    });

    function mouseFollowEv(index) {
      var $this = $(menu + ' > li').eq(index).find('a'),
          offset = $this.offset(),
          offsetBody = $('.uix-lavalamp-menu__container').offset(); //find the offset of the wrapping div  
      //Activate navigation style

      $(menu + ' > li').removeClass('is-active');
      $this.parent().addClass('is-active'); // GSAP animate to clicked menu item

      TweenMax.to(followEl, 1, {
        css: {
          width: parseFloat($this.outerWidth() + 0) + 'px',
          x: offset.left - offsetBody.left + 'px'
        },
        ease: Elastic.easeOut.config(1, 0.5)
      });
    } //!import: Please do not try `$( document ).on( MOUSE_EVENT )` to improve performance


    $(menu + ' > li a').on('mouseover', function () {
      mouseFollowEv($(this).parent().index());
    });
    mouseFollowEv(0);
  };

  module.components.documentReady.push(module.LAVA_LAMP_STYLE_MENU.documentReady);
  return function LAVA_LAMP_STYLE_MENU() {
    lava_lamp_style_menu_js_classCallCheck(this, LAVA_LAMP_STYLE_MENU);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/third-party-plugins/esm/Miscellaneous/scrollLock.js
var scrollLock = __webpack_require__(3);

// EXTERNAL MODULE: ./src/components/lightbox/scss/_style.scss
var lightbox_scss_style = __webpack_require__(51);

// CONCATENATED MODULE: ./src/components/lightbox/js/index.js
function lightbox_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lightbox_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lightbox_js_typeof = function _typeof(obj) { return typeof obj; }; } else { lightbox_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lightbox_js_typeof(obj); }

/* 
 *************************************
 * <!-- Custom Lightbox -->
 *************************************
 */




var LIGHTBOX = function (module, $, window, document) {
  if (window.LIGHTBOX === null) return false;
  module.LIGHTBOX = module.LIGHTBOX || {};
  module.LIGHTBOX.version = '0.2.1';

  module.LIGHTBOX.pageLoaded = function () {
    if ($('.uix-lightbox__container').length == 0) {
      $('body').prepend('<div class="uix-lightbox__loading is-loaded uix-t-c"><i class="fa fa-spinner fa-spin"></i> Loading...</div><a class="uix-lightbox__original__close" href="javascript:void(0);"></a><div class="uix-lightbox__container"><div class="uix-lightbox__inner"><div class="uix-lightbox__html"></div><p class="title"></p></div></div><div class="uix-lightbox__container-mask"></div><div class="uix-lightbox__close"><button type="button"></button></div>');
    } // To display the template tag content.


    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
        return html.replace(/[\r\n]/g, '');
      }).context.innerHTML,
          _id = $(this).attr('id'); //If it is dialog, clone the contents of the <template> into the body


      if (lightbox_js_typeof(_id) !== ( true ? "undefined" : undefined) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id); //append content to body

        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });
    var innerEl = '.uix-lightbox__inner',
        wrapperEl = '.uix-lightbox__container',
        loaderEl = '.uix-lightbox__loading',
        maskEl = '.uix-lightbox__container-mask',
        closeEl = '.uix-lightbox__close',
        largeImgCloseEl = '.uix-lightbox__original__close',
        triggerEl = '.uix-lightbox__trigger',
        docURL = window.location.href,
        $content = $(innerEl).find('.uix-lightbox__html'),
        customWidth = 1000; //Match the width in the css file;
    //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null;
      $('[data-lb-ajax]').each(function () {
        var prevURL = decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent('uix-lightbox-ajaxURL').replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;

        if ($(this).attr('href') === prevURL) {
          eleTarget = this;
        }
      });
      var backURL = $(eleTarget).data('lb-ajax-doc-url');

      if (lightbox_js_typeof(backURL) != ( true ? "undefined" : undefined)) {
        lightboxClose(backURL);
      }
    });
    $(document).off('click.LIGHTBOX_TRIGGER').on('click.LIGHTBOX_TRIGGER', triggerEl, function () {
      var $this = $(this);
      var dataPhoto = $this.data('lb-src'),
          dataHtmlID = $this.data('lb-html'),
          dataFixed = $this.data('lb-fixed'),
          dataMaskClose = $this.data('lb-mask-close'),
          dataAjax = $this.data('lb-ajax'),
          htmlContent = '',
          imgSrcStr = '',
          imgSrcStrToW = '';

      if (lightbox_js_typeof(dataFixed) === ( true ? "undefined" : undefined)) {
        dataFixed = true;
      }

      if (lightbox_js_typeof(dataMaskClose) === ( true ? "undefined" : undefined)) {
        dataMaskClose = false;
      }

      if (lightbox_js_typeof(dataAjax) === ( true ? "undefined" : undefined)) {
        dataAjax = false;
      }

      if (dataAjax) {
        $(wrapperEl).addClass('js-uix-ajax'); //Record current page URL for history

        if (lightbox_js_typeof($this.data('lb-ajax-doc-url')) === ( true ? "undefined" : undefined)) $this.data('lb-ajax-doc-url', docURL);
      } //Display loading


      $(loaderEl).removeClass('is-loaded'); //Reset the wrapper position

      $(wrapperEl).css('margin-top', 0);

      if (!dataFixed) {
        $(wrapperEl).addClass('js-uix-no-fixed');
        $(closeEl).addClass('is-active'); //Initialize the wrapper position

        $(wrapperEl).css('margin-top', $(window).scrollTop() + 'px');
      } //Reset current container type


      $(innerEl).removeClass('js-uix-custom js-uix-pure-image'); // Locks the page

      if (!$(wrapperEl).hasClass('js-uix-no-fixed')) {
        $.scrollLock(true);
      } // Show the lightbox


      var showLightbox = function showLightbox() {
        $(closeEl).addClass('is-active');
        $(wrapperEl).show();
        $(maskEl).show();
        $(innerEl).show();
      }; // hide the content container


      var hideLightboxContent = function hideLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'none'
          }
        });
      }; // show the content container


      var showLightboxContent = function showLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };

      hideLightboxContent(); ////////////////////////
      //////// PHOTOS ///////
      ////////////////////////  

      if (lightbox_js_typeof(dataPhoto) != ( true ? "undefined" : undefined) && dataPhoto != '') {
        //show the lightbox
        showLightbox();

        if (dataPhoto.indexOf('[') >= 0 && dataPhoto.indexOf(']') >= 0) {
          imgSrcStr = JSON.parse(dataPhoto.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
        } else {
          imgSrcStr = dataPhoto;
        } //Judging whether multiple image sets


        if (Object.prototype.toString.call(imgSrcStr) == '[object Array]') {
          var largePhotos = '',
              thumbs = '';
          imgSrcStrToW = imgSrcStr[0].large; //push the large photos

          largePhotos += '<div class="uix-lightbox__photo-container uix-lightbox__photo-sets-container"><a href="javascript:" class="uix-lightbox__photo-sets__prev"></a><a href="javascript:" class="uix-lightbox__photo-sets__next"></a><ul>';

          for (var i = 0; i < imgSrcStr.length; i++) {
            var tempID = 'lightbox-' + UixGUID.create();
            largePhotos += '<li>';
            largePhotos += '	<a class="uix-lightbox__original__link" data-target-id="' + tempID + '-sets-' + i + '" href="javascript:void(0);">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</a>';
            largePhotos += '	<div class="uix-lightbox__original__target" id="' + tempID + '-sets-' + i + '">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</div>';
            largePhotos += '</li>';
          }

          largePhotos += '</ul></div>'; //push the thumbs

          thumbs += '<div class="uix-lightbox__thumb-container"><ul>';

          for (var k = 0; k < imgSrcStr.length; k++) {
            var active = k == 0 ? 'class="is-active"' : '';
            thumbs += '<li ' + active + '><img src="' + imgSrcStr[k].thumb + '" alt=""></li>';
          }

          thumbs += '</ul></div>';
          htmlContent = largePhotos + thumbs;
        } else {
          var _tempID = 'lightbox-' + UixGUID.create(); //Only one image


          imgSrcStrToW = imgSrcStr;
          htmlContent += '<div class="uix-lightbox__photo-container">';
          htmlContent += '	<a class="uix-lightbox__original__link" data-target-id="' + _tempID + '" href="javascript:void(0);">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</a>';
          htmlContent += '	<div class="uix-lightbox__original__target" id="' + _tempID + '">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</div>';
          htmlContent += '</div>';
        }

        $content.html(htmlContent).promise().done(function () {
          //Set current container type
          $(innerEl).addClass('js-uix-pure-image'); //Set container width

          var img = new Image();
          img.src = imgSrcStrToW;

          img.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded'); // show the content container

            showLightboxContent();
            var sw = window.innerWidth - 30,
                ow = this.width,
                oh = this.height,
                ratioH = oh / ow,
                ratioW = ow / oh,
                w = ow > customWidth ? customWidth : ow,
                h;
            if (w > sw) w = sw;
            h = w * ratioH; //Prevent height overflow

            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $(innerEl).css({
              'width': w + 'px'
            }); //Don't write variables outside

            var $lbSetsContainer = $('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container');
            $lbSetsContainer.css({
              'height': h + 'px'
            }); //Set a new height & width of inside images

            $content.find('.uix-lightbox__photo-sets-container ul > li img').css({
              'height': h + 'px'
            });

            if (!$('body').hasClass('rtl')) {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-left': '-3rem'
              });
            } else {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-right': '-3rem'
              });
            } //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside


            var $lbTarImg = $('.uix-lightbox__photo-container > .uix-lightbox__original__target');

            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }
          };

          $(innerEl).find('> .uix-lightbox__html').removeClass('js-uix-no-img');
        });
      } ////////////////////////
      //////// HTML /////////
      ////////////////////////  


      if (lightbox_js_typeof(dataHtmlID) != ( true ? "undefined" : undefined) && dataHtmlID != '') {
        dataHtmlID = dataHtmlID.replace('#', '');
        var $htmlAjaxContainer = $('#' + dataHtmlID).find('.uix-lightbox__content > div'); //show the lightbox

        showLightbox(); // Content pushing completed

        var htmlContentLoaded = function htmlContentLoaded() {
          //remove loading
          $(loaderEl).addClass('is-loaded'); //Set current container type

          $(innerEl).addClass('js-uix-custom'); //Set container width

          if ($(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').length > 0) {
            if (window.innerWidth <= 768) {
              $(innerEl).css('width', window.innerWidth - 10 + 'px');
            } else {
              $(innerEl).css('width', $(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').width() + 'px');
            }

            $(innerEl).find('> .uix-lightbox__html').addClass('js-uix-no-img');
          }
        };

        if ($(wrapperEl).hasClass('js-uix-ajax')) {
          //Add content to the dynamic AJAX container
          var ajaxURL = $this.attr('href'),
              ajaxConfig = dataAjax; // Modify the URL without reloading the page

          if (history.pushState) {
            history.pushState(null, null, ajaxURL);
          } else {
            location.hash = ajaxURL;
          }

          document.cookie = 'uix-lightbox-ajaxURL=' + ajaxURL; // Add a request or response interceptor

          var axiosInterceptor = axios.interceptors.request.use(function (config) {
            // Do something before request is sent
            //
            return config;
          }, function (error) {
            return Promise.reject(error);
          }); // To send data in the application/x-www-form-urlencoded format instead

          var formData = new FormData();
          var defaultPostData = {
            action: 'load_singlepages_ajax_content'
          };

          for (var _k in defaultPostData) {
            formData.append(_k, defaultPostData[_k]);
          } // Create a request event


          axios({
            timeout: 15000,
            method: ajaxConfig.method,
            url: ajaxURL,
            data: formData,
            responseType: 'text'
          }).then(function (response) {
            var htmlCode = response.data;
            $htmlAjaxContainer.html($(htmlCode).find(dataAjax.target).html()).promise().done(function () {
              $content.html($('#' + dataHtmlID).html()).promise().done(function () {
                // Apply some asynchronism scripts
                $(document).UixApplyAsyncScripts({
                  lightBox: false,
                  ajaxPostList: false
                }); // show the content container

                showLightboxContent(); // Content pushing completed

                htmlContentLoaded();
              });
            });
          })["catch"](function (error) {
            if (error.response) {
              // The request was made and the server responded with a status code
              // that falls out of the range of 2xx
              var status = error.response.status;
              console.log(status);
              if (status == 404 || status == 405) window.location.href = ajaxURL;
            } else if (error.request) {
              // The request was made but no response was received
              // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
              // http.ClientRequest in node.js
              console.log(error.request); //

              window.location.href = ajaxURL;
            } else {
              // If there was a problem, we need to
              // dispatch the error condition
              console.log(error.message);
            }
          }); // Remove an interceptor later

          axios.interceptors.request.eject(axiosInterceptor);
        } else {
          // show the content container
          showLightboxContent();
          $content.html($('#' + dataHtmlID).html()).promise().done(function () {
            // Content pushing completed
            htmlContentLoaded();
          });
        } //endif $( wrapperEl ).hasClass( 'js-uix-ajax' )

      }

      return false;
    });
    /* end click event for triggerEl */
    ////////////////////////
    // Close the lightbox //
    ////////////////////////   	

    $(document).off('click.LIGHTBOX_CLOSE').on('click.LIGHTBOX_CLOSE', closeEl + ',' + maskEl, function () {
      lightboxClose(docURL);
    });
    $(document).off('click.LIGHTBOX_THUMB').on('click.LIGHTBOX_THUMB', '.uix-lightbox__thumb-container li', function () {
      lightboxThumbSwitch($(this).index(), $(this));
    });
    $(document).off('click.LIGHTBOX_PHOTO_SETS').on('click.LIGHTBOX_PHOTO_SETS', '.uix-lightbox__photo-sets-container > a', function () {
      var $largePhoto = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
          $thumb = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li'),
          total = $thumb.length,
          curIndex = $thumb.filter('.is-active').index();
      var prevIndex = curIndex - 1,
          nextIndex = curIndex + 1;
      if (prevIndex < 0) prevIndex = total - 1;
      if (nextIndex > total - 1) nextIndex = 0;

      if ($(this).hasClass('uix-lightbox__photo-sets__prev')) {
        lightboxThumbSwitch(prevIndex, $thumb.eq(prevIndex));
      }

      if ($(this).hasClass('uix-lightbox__photo-sets__next')) {
        lightboxThumbSwitch(nextIndex, $thumb.eq(nextIndex));
      }
    }); ////////////////////////////////
    // Close/Open enlarge image //
    ///////////////////////////////	

    if (window.innerWidth > 768) {
      $(document).off('click.LIGHTBOX_ORGINAL_LINK').on('click.LIGHTBOX_ORGINAL_LINK', '.uix-lightbox__original__link', function (e) {
        $('.uix-lightbox__original__target#' + $(this).data('target-id')).addClass('is-active');

        if ($(this).closest('.uix-lightbox__container.js-uix-no-fixed').length > 0) {
          $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').addClass('no-fixed-imgEnlarged');
        } //---


        $('html').css('overflow-y', 'hidden');
        $(largeImgCloseEl).addClass('is-active');
      });
      $(document).off('click.LIGHTBOX_LARGE_IMG_CLOSE').on('click.LIGHTBOX_LARGE_IMG_CLOSE', largeImgCloseEl, function (e) {
        $('.uix-lightbox__original__target').removeClass('is-active');
        $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').removeClass('no-fixed-imgEnlarged'); //---

        $(this).removeClass('is-active');
        $('html').css('overflow-y', 'auto');
      });
    }
    /*
     * Click thumbnail to show large photo
     *
     * @param  {Number} index           - The target index of large photo.
     * @param  {Element} obj             - Target large image <li>.
     * @return {Void}
     */


    function lightboxThumbSwitch(index, obj) {
      var $largePhoto = obj.closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
          $thumb = obj.closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li'); // show the content container

      var showLightboxContent = function showLightboxContent() {
        TweenMax.set(obj.closest('.uix-lightbox__html'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };

      $thumb.removeClass('is-active');
      obj.addClass('is-active'); //all items

      TweenMax.set($largePhoto.find('li'), {
        css: {
          'display': 'none',
          'opacity': 0
        },
        onComplete: function onComplete() {
          $(this.target).removeClass('is-active');
        }
      }); //current item

      TweenMax.set($largePhoto.find('li').eq(index), {
        css: {
          'display': 'block',
          'opacity': 0
        },
        onComplete: function onComplete() {
          var _cur = this.target;
          $(_cur).addClass('is-active'); //
          //Reset the container height

          var imgClick = new Image();
          imgClick.src = $largePhoto.find('li').eq(index).find('img').attr('src');

          imgClick.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded'); // show the content container

            showLightboxContent();
            var sw = window.innerWidth - 30,
                ow = this.width,
                oh = this.height,
                ratioH = oh / ow,
                w = ow > customWidth ? customWidth : ow,
                h;
            if (w > sw) w = sw;
            h = w * ratioH; //Prevent height overflow

            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $largePhoto.css({
              'height': h + 'px'
            }).find('img').css({
              'height': h + 'px'
            }); //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside

            var $lbTarImg = $largePhoto.find('li').eq(index).find('.uix-lightbox__original__target');

            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }

            TweenMax.to(_cur, 0.5, {
              alpha: 1
            });
          }; //imgClick.onload       

        }
      });
    }
    /*
     * Close the lightbox
     *
     * @param  {String} url             - The current page URL for history.
     * @return {Void}
     */


    function lightboxClose(url) {
      //Detect URL change when AJAX calls are done
      if ($(wrapperEl).hasClass('js-uix-ajax')) {
        history.pushState(null, null, url);
      } //Remove all dynamic classes


      $(wrapperEl).removeClass('js-uix-no-fixed js-uix-ajax');
      $(closeEl).removeClass('is-active'); //Add a scroll bar.

      $('html').css('overflow-y', 'auto'); //Reset current container type

      $(innerEl).removeClass('js-uix-custom js-uix-pure-image'); //close windows

      $(wrapperEl).hide();
      $(maskEl).hide(); // Unlocks the page

      $.scrollLock(false);
    }
  };

  module.components.pageLoaded.push(module.LIGHTBOX.pageLoaded);
  return function LIGHTBOX() {
    lightbox_js_classCallCheck(this, LIGHTBOX);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/list-bulleted/scss/_style.scss
var list_bulleted_scss_style = __webpack_require__(52);

// CONCATENATED MODULE: ./src/components/list-bulleted/js/index.js
function list_bulleted_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Bulleted List -->
 *************************************
 */


var BULLETED_LIST = function (module, $, window, document) {
  if (window.BULLETED_LIST === null) return false;
  module.BULLETED_LIST = module.BULLETED_LIST || {};
  module.BULLETED_LIST.version = '0.0.1';

  module.BULLETED_LIST.documentReady = function ($) {
    // Icon bulleted lists
    $('[data-list-bullet]').each(function () {
      var bullet = $(this).attr('data-list-bullet');
      $(this).find('li').prepend('<i class="' + bullet + '" aria-hidden="true"></i>');
    });
  };

  module.components.documentReady.push(module.BULLETED_LIST.documentReady);
  return function BULLETED_LIST() {
    list_bulleted_js_classCallCheck(this, BULLETED_LIST);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/list-posts/scss/_basic.scss
var list_posts_scss_basic = __webpack_require__(53);

// EXTERNAL MODULE: ./src/components/list-posts/scss/_split.scss
var _split = __webpack_require__(54);

// CONCATENATED MODULE: ./src/components/list-posts/js/index.js
function list_posts_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function list_posts_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { list_posts_js_typeof = function _typeof(obj) { return typeof obj; }; } else { list_posts_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return list_posts_js_typeof(obj); }

/* 
 *************************************
 * <!-- Posts List With Ajax -->
 *************************************
 */





var POST_LIST_AJAX = function (module, $, window, document) {
  if (window.POST_LIST_AJAX === null) return false;
  module.POST_LIST_AJAX = module.POST_LIST_AJAX || {};
  module.POST_LIST_AJAX.version = '0.1.7';

  module.POST_LIST_AJAX.documentReady = function ($) {
    $(window).off('scroll.POST_LIST_AJAX touchmove.POST_LIST_AJAX');
    $('[data-ajax-list-json]').each(function () {
      var $this = $(this);
      var wrapperID = 'refresh-all-waypoint-' + UixGUID.create();
      var curPage = $this.data('ajax-list-page-now'),
          initCurPage = curPage,
          perShow = $this.data('ajax-list-page-per'),
          totalPage = $this.data('ajax-list-page-total'),
          method = $this.data('ajax-list-method'),
          trigger = $this.data('ajax-list-trigger'),
          infinitescroll = $this.data('ajax-list-infinitescroll'),
          jsonFile = $this.data('ajax-list-json'),
          render = $this.data('ajax-list-render'),
          template7ID = $this.data('ajax-list-temp-id'),
          pushContainer = $this.data('ajax-list-push-container-class'),
          triggerActive = $this.data('ajax-list-trigger-active-class'),
          pageParmStr = $this.data('ajax-list-page-parm-str'),
          noneInfo = $this.data('ajax-list-none-info');
      $this.attr('id', wrapperID);

      if (list_posts_js_typeof(pageParmStr) === ( true ? "undefined" : undefined)) {
        pageParmStr = {
          'totalPage': 'total',
          'currentPage': 'page',
          'displayPerPage': 'per'
        };
      }

      if (list_posts_js_typeof(curPage) === ( true ? "undefined" : undefined)) {
        curPage = 1;
      }

      if (list_posts_js_typeof(perShow) === ( true ? "undefined" : undefined)) {
        perShow = 8;
      }

      if (list_posts_js_typeof(totalPage) === ( true ? "undefined" : undefined)) {
        totalPage = 3;
      }

      if (list_posts_js_typeof(totalPage) != ( true ? "undefined" : undefined) && totalPage == '-1') {
        totalPage = 9999;
      }

      if (list_posts_js_typeof(trigger) === ( true ? "undefined" : undefined)) {
        trigger = '.uix-load-more';
      }

      if (list_posts_js_typeof(infinitescroll) === ( true ? "undefined" : undefined)) {
        infinitescroll = false;
      }

      if (list_posts_js_typeof(render) === ( true ? "undefined" : undefined)) {
        render = 'before';
      }

      if (list_posts_js_typeof(jsonFile) === ( true ? "undefined" : undefined)) {
        jsonFile = '';
      }

      if (list_posts_js_typeof(template7ID) === ( true ? "undefined" : undefined)) {
        template7ID = '';
      }

      if (list_posts_js_typeof(triggerActive) === ( true ? "undefined" : undefined)) {
        triggerActive = 'wait';
      }

      if (list_posts_js_typeof(method) === ( true ? "undefined" : undefined)) {
        method = 'POST';
      }

      if (list_posts_js_typeof(noneInfo) === ( true ? "undefined" : undefined)) {
        noneInfo = '{"none":"","error":""}';
      }

      triggerActive = triggerActive.replace('.', '');

      if (list_posts_js_typeof(pushContainer) === ( true ? "undefined" : undefined)) {
        pushContainer = '.uix-ajax-items__container';

        if ($this.find(pushContainer).length == 0) {
          $('#' + template7ID).after('<div class="uix-ajax-items__container"></div>');
        }
      } //Get all attributes of an element and push the new attributes like "data-*"


      var curAttrs = $this.attr(),
          defaultPostData = '',
          customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-ajax-list-field-') >= 0) {
          customPostData += '"' + i.replace('data-ajax-list-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, ''); //Parse the JSON data

      if (jsonFile != '' && template7ID != '') {
        //Default output of the first page
        if (curPage == 2) {
          //Perform dynamic loading
          if (customPostData != '') {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1, ' + customPostData + ' }');
          } else {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1 }');
          }

          ajaxLoadInit($this, defaultPostData, $(trigger), curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
        }

        if (infinitescroll) {
          /* 
           ---------------------------
           Infinite scroll
           ---------------------------
           */
          var $button = $(trigger),
              btnTop = $button.offset().top; //Add default page number to the button

          $button.attr('data-cur-page', initCurPage); //Hide the next button 

          if (totalPage == 1) {
            $button.addClass('is-hide');
          } // Please do not use scroll's off method in each


          $(window).on('scroll.POST_LIST_AJAX touchmove.POST_LIST_AJAX', function () {
            var spyTop = parseFloat($button[0].getBoundingClientRect().top + $button.outerHeight(true));

            if (spyTop < window.innerHeight && !$button.hasClass(triggerActive)) {
              // Active this button
              $button.addClass(triggerActive);

              var _curPage = $button.attr('data-cur-page'); //Add next page number to the button


              _curPage = parseFloat(_curPage) + 1;
              $button.attr('data-cur-page', _curPage); //Avoid touching the same button multiple times

              if (_curPage == totalPage + 1) return false; //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, _curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
            }
          });
        } else {
          /* 
           ---------------------------
           Ajax with JSON data
           ---------------------------
           */
          var triggerStr = '';

          if (trigger.indexOf('[') >= 0 && trigger.indexOf(']') >= 0) {
            triggerStr = JSON.parse(trigger.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
          } else {
            triggerStr = trigger;
          } //Whether there are two flip buttons "Previous" and "Next"


          if (Object.prototype.toString.call(triggerStr) == '[object Array]') {
            var prevTrigger = triggerStr[0].prev,
                nextTrigger = triggerStr[1].next; //Add default page number to the button

            $(nextTrigger).parent().attr('data-cur-page', initCurPage); //--------------- Next Button ------------------
            //Hide the next button 

            if (totalPage == 1) {
              $(nextTrigger).addClass('is-hide');
            } //Avoid using $( document ) to cause an asynchronous load without counting from 1


            $(nextTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) + 1;
              $button.parent().attr('data-cur-page', curPage); //Init button status

              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(prevTrigger).removeClass('is-hide'); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            }); //----------------- Previous Button ----------------
            //Hide the prev button 

            $(prevTrigger).addClass('is-hide'); //Avoid using $( document ) to cause an asynchronous load without counting from 1

            $(prevTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) - 1;
              $button.parent().attr('data-cur-page', curPage); //Init button status

              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass('is-hide'); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          } else {
            //----------------- More Button ----------------
            //Add default page number to the button
            $(trigger).attr('data-cur-page', initCurPage); //Hide the next button 

            if (totalPage == 1) {
              $(trigger).addClass('is-hide');
            } //Avoid using $( document ) to cause an asynchronous load without counting from 1


            $(trigger).off('click.POST_LIST_AJAX').on('click.POST_LIST_AJAX', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) + 1;
              $button.attr('data-cur-page', curPage); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          }
        } //end if

      }
    });
    /*
     * Ajax with JSON data
     *
     * @param  {Element} ajaxWrapper     - The outermost container of list.
     * @param  {Object} defaultPostData - Data to be sent to the server which is custom JSON fields.
     * @param  {String} trigger         - Trigger ajax loaded button object.
     * @param  {Number} curPage         - The current page to load.
     * @param  {Number} perShow         - The amount to load each time.
     * @param  {Number} totalPage       - The total page to load.
     * @param  {String} template7ID     - HTML template ID
     * @param  {String} jsonFile        - JSON file path to docking data
     * @param  {String} triggerActive   - The class name of trigger button actived.
     * @param  {String} pushContainer   - This container is used to display the loaded dynamic data.
     * @param  {String} method          - The type of request to make, which can be either "POST" or "GET".
     * @param  {String} render          - Rendering mode of display information. ==> before | html | append
     * @param  {String} noneInfo        - Returns information of ajax asynchronous callback when the content is empty.
     * @return {Void}
     */

    function ajaxLoadInit(ajaxWrapper, defaultPostData, trigger, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo) {
      var $divRoot = ajaxWrapper,
          template = document.getElementById(template7ID).innerHTML,
          compiledTemplate = Template7.compile(template),
          $button = $(trigger); //hide the button and callback the information

      var returnEmptyInfo = function returnEmptyInfo() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.none);
      };

      var returnDataError = function returnDataError() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.error);
      }; // Add a request or response interceptor


      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent
        //
        return config;
      }, function (error) {
        return Promise.reject(error);
      }); // To send data in the application/x-www-form-urlencoded format instead

      var formData = new FormData();

      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      } // Create a request event


      axios({
        timeout: 15000,
        method: method,
        url: jsonFile,
        data: formData,
        responseType: 'json'
      }).then(function (response) {
        var jsonData = response.data; //If the data is empty

        if (jsonData && (jsonData == null || Object.prototype.toString.call(jsonData.items) == '[object String]')) {
          returnEmptyInfo();
        } //Check if a key exists inside a json object


        if (jsonData && jsonData.hasOwnProperty('items') && Object.prototype.toString.call(jsonData.items) == '[object Array]') {
          //Data overflow may occur when the total number of pages is not posted
          try {
            var html = compiledTemplate(jsonData),
                curHtml = $divRoot.find(pushContainer).html();
            var result = null,
                htmlEl = null; //--------- Do or not append to the original content

            if (render == 'before') {
              result = curHtml + html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).before(htmlEl);
            }

            if (render == 'html') {
              result = html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).html(htmlEl);
            }

            if (render == 'append') {
              $divRoot.find(pushContainer).append(html);
            } //--------- Apply some asynchronism scripts


            $(document).UixApplyAsyncScripts({
              ajaxPostList: false
            }); //--------- Remove this button

            $button.removeClass(triggerActive); //--------- Hidden button when the page total number is set and does not equal -1 or 9999

            if (curPage == totalPage && totalPage != 9999 && totalPage != -1 && totalPage != 1) {
              returnEmptyInfo();
            }
          } catch (err) {
            console.log(err.message);
            returnDataError();
          }
        } else {
          //if not array
          returnEmptyInfo();
        }
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request); //

          returnEmptyInfo();
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      }); // Remove an interceptor later

      axios.interceptors.request.eject(axiosInterceptor);
    }
  };

  module.components.documentReady.push(module.POST_LIST_AJAX.documentReady);
  return function POST_LIST_AJAX() {
    list_posts_js_classCallCheck(this, POST_LIST_AJAX);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/fullwidth-column-to-edge/scss/_style.scss
var fullwidth_column_to_edge_scss_style = __webpack_require__(55);

// CONCATENATED MODULE: ./src/components/fullwidth-column-to-edge/js/index.js
function fullwidth_column_to_edge_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function fullwidth_column_to_edge_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { fullwidth_column_to_edge_js_typeof = function _typeof(obj) { return typeof obj; }; } else { fullwidth_column_to_edge_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return fullwidth_column_to_edge_js_typeof(obj); }

/* 
 *************************************
 * <!-- Full Width Column to Edge -->
 *************************************
 */


var FULL_WIDTH_COLUMN_TO_EDGE = function (module, $, window, document) {
  if (window.FULL_WIDTH_COLUMN_TO_EDGE === null) return false;
  module.FULL_WIDTH_COLUMN_TO_EDGE = module.FULL_WIDTH_COLUMN_TO_EDGE || {};
  module.FULL_WIDTH_COLUMN_TO_EDGE.version = '0.0.2';

  module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded = function () {
    $('.js-uix-fullwidth-column-to-edge--extend-right').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if (fullwidth_column_to_edge_js_typeof(actived) === ( true ? "undefined" : undefined)) {
        fullwidthToDir($(this), 'right', window.innerWidth); //Prevents front-end javascripts that are activated in the background to repeat loading.

        $el.data('activated', 1);
      } //endif actived

    });
    $('.js-uix-fullwidth-column-to-edge--extend-left').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if (fullwidth_column_to_edge_js_typeof(actived) === ( true ? "undefined" : undefined)) {
        fullwidthToDir($(this), 'left', window.innerWidth); //Prevents front-end javascripts that are activated in the background to repeat loading.

        $el.data('activated', 1);
      } //endif actived

    });

    function fullwidthToDir(obj, dir, w) {
      var dividerPosition = obj.offset();
      var dividerWidth = $(window).width() - dividerPosition.left;
      var bsGridGutter = 15;

      if (w > 768) {
        obj.css('width', dividerWidth + bsGridGutter);

        if (dir == 'left') {
          var _dis = -(dividerPosition.left + bsGridGutter * 2);

          obj.css('margin-left', _dis + 'px');
        }
      } else {
        obj.css('width', 'inherit');

        if (dir == 'left') {
          obj.css('margin-left', -bsGridGutter + 'px');
        }
      }
    }
  };

  module.components.pageLoaded.push(module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded);
  return function FULL_WIDTH_COLUMN_TO_EDGE() {
    fullwidth_column_to_edge_js_classCallCheck(this, FULL_WIDTH_COLUMN_TO_EDGE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/login-templates/scss/_style.scss
var login_templates_scss_style = __webpack_require__(56);

// CONCATENATED MODULE: ./src/components/login-templates/js/index.js
function login_templates_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Login Templates -->
 *************************************
 */


var LOGIN_UI = function (module, $, window, document) {
  if (window.LOGIN_UI === null) return false;
  module.LOGIN_UI = module.LOGIN_UI || {};
  module.LOGIN_UI.version = '0.0.2';

  module.LOGIN_UI.documentReady = function ($) {
    var $loginToggle = $('.uix-special-login__toggle'),
        $loginForms = $('.uix-special-login__form');
    $loginToggle.data('switched', true).off('click').on('click', function (e) {
      e.preventDefault();
      var $form1 = $loginForms.eq(0),
          $form2 = $loginForms.eq(1);

      if ($(this).data('switched')) {
        $(this).data('switched', false);
        TweenMax.set($form2, {
          height: 'auto'
        });
        TweenMax.from($form2, 0.5, {
          height: 0
        });
        TweenMax.to($form1, 0.5, {
          height: 0
        }); // Switches the Icon

        $(this).find('> span i').eq(0).hide();
        $(this).find('> span i').eq(1).show();
      } else {
        $(this).data('switched', true);
        TweenMax.set($form1, {
          height: 'auto'
        });
        TweenMax.from($form1, 0.5, {
          height: 0
        });
        TweenMax.to($form2, 0.5, {
          height: 0
        }); // Switches the Icon

        $(this).find('> span i').eq(1).hide();
        $(this).find('> span i').eq(0).show();
      }
    });
  };

  module.components.documentReady.push(module.LOGIN_UI.documentReady);
  return function LOGIN_UI() {
    login_templates_js_classCallCheck(this, LOGIN_UI);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/fire-modal-dialog.js
function fire_modal_dialog_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { fire_modal_dialog_typeof = function _typeof(obj) { return typeof obj; }; } else { fire_modal_dialog_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return fire_modal_dialog_typeof(obj); }

/*
 * Fire Modal Dialog
 *
 * @param  {String} id                   - Modal's unique identifier.
 * @param  {Number|Boolean} height       - Custom modal height whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number|Boolean} width        - Custom modal width whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number} speed                - Delay Time when Full Screen Effect is fired.   
 * @param  {?Element|Boolean} btn          - Link or button that fires an event.
 * @param  {Boolean} lightbox            - Whether to enable the lightbox effect.
 * @param  {Number|Boolean} autoClose    - Specify auto-close time. This function is not enabled when this value is false.
 * @param  {Boolean} closeOnlyBtn        - Disable mask to close the window.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixFireModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      id: 'demo',
      height: false,
      width: false,
      speed: 500,
      btn: false,
      lightbox: true,
      autoClose: false,
      closeOnlyBtn: false
    }, options);
    this.each(function () {
      if (settings.id == '') return false; //Add modal mask to stage

      if ($('.uix-modal-mask').length == 0) {
        $('body').prepend('<div class="uix-modal-mask"></div>');
      }

      $.when($('.uix-modal-mask').length > 0).then(function () {
        if (settings.closeOnlyBtn) {
          $('.uix-modal-mask').addClass('js-uix-disabled');
        } else {
          $('.uix-modal-mask').removeClass('js-uix-disabled');
        }

        var dataID = settings.id,
            dataH = settings.height,
            dataW = settings.width,
            linkBtn = settings.btn,
            closeTime = settings.autoClose,
            $obj = $('.uix-modal-box#' + dataID); // Initializate modal

        if (linkBtn) {
          linkBtn.attr('href', 'javascript:void(0)');
          $obj.find('.uix-modal-box__content').addClass('js-uix-no-fullscreen');

          if (linkBtn.data('video-win')) {
            $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
          }
        }

        if ($obj.length > 0) {
          // Locks the page
          $.scrollLock(true);

          if (fire_modal_dialog_typeof(dataH) != ( true ? "undefined" : undefined) && dataH != '' && dataH) {
            $obj.css({
              'height': dataH
            });
          }

          if (fire_modal_dialog_typeof(dataW) != ( true ? "undefined" : undefined) && dataW != '' && dataW) {
            $obj.css({
              'width': dataW
            });
          } //Enable the lightbox effect.


          if (settings.lightbox) {
            TweenMax.set('.uix-modal-mask', {
              css: {
                opacity: 0,
                display: 'none'
              },
              onComplete: function onComplete() {
                TweenMax.to(this.target, 0.3, {
                  css: {
                    opacity: 1,
                    display: 'block'
                  }
                });
              }
            });
          }

          $obj.addClass('is-active'); //auto close

          if (closeTime && !isNaN(closeTime)) {
            window.setCloseModalDialog = setTimeout(function () {
              $(document).closeModalDialog();
            }, closeTime);
          }
        }

        if ($obj.hasClass('is-fullscreen')) {
          setTimeout(function () {
            if (!$obj.hasClass('is-video')) {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'scroll');
            } else {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
            }
          }, settings.speed);
        }
      });
    });
  };
})(jQuery);
// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/close-modal-dialog.js
/*
 * Close Modal Dialog
 *
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixCloseModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      target: '.uix-modal-box'
    }, options);
    this.each(function () {
      //Enable mask to close the window.
      $('.uix-modal-mask').removeClass('js-uix-disabled');
      $(settings.target).removeClass('is-active');
      TweenMax.to('.uix-modal-mask', 0.3, {
        css: {
          opacity: 0,
          display: 'none'
        }
      });
      $(settings.target).find('.uix-modal-box__content').removeClass('js-uix-no-fullscreen'); // Unlocks the page

      $.scrollLock(false); //Prevent automatic close from affecting new fire effects

      clearTimeout(window.setCloseModalDialog);
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/modal-dialog/scss/_style.scss
var modal_dialog_scss_style = __webpack_require__(57);

// CONCATENATED MODULE: ./src/components/modal-dialog/js/index.js
function modal_dialog_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function modal_dialog_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { modal_dialog_js_typeof = function _typeof(obj) { return typeof obj; }; } else { modal_dialog_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return modal_dialog_js_typeof(obj); }

/* 
 *************************************
 * <!-- Modal Dialog -->
 *************************************
 */




var MODAL_DIALOG = function (module, $, window, document) {
  if (window.MODAL_DIALOG === null) return false;
  module.MODAL_DIALOG = module.MODAL_DIALOG || {};
  module.MODAL_DIALOG.version = '0.1.6';

  module.MODAL_DIALOG.documentReady = function ($) {
    //Delay Time when Full Screen Effect is fired.
    var modalSpeed = UixCssProperty.getTransitionDuration($('.uix-modal-box:first')[0]); // To display the template tag content.

    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
        return html.replace(/[\r\n]/g, '');
      }).context.innerHTML,
          _id = $(this).attr('id'); //If it is dialog, clone the contents of the <template> into the body


      if (modal_dialog_js_typeof(_id) !== ( true ? "undefined" : undefined) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id); //append content to body

        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });
    /*
      * Unbind that one in a safe way that won't accidentally unbind other click handlers.
      * In order to trigger other custom Modal Dialog events.
    	
    	$( '#element' ).off( 'click.MODAL_DIALOG' );
    	$( '#element' ).off( 'click.MODAL_DIALOG_CLOSE' );
    	
    */
    //Add modal mask to stage

    if ($('.uix-modal-mask').length == 0) {
      $('body').prepend('<div class="uix-modal-mask"></div>');
    }

    $(document).off('click.MODAL_DIALOG').on('click.MODAL_DIALOG', '[data-modal-id]', function () {
      var dataH = $(this).data('modal-height'),
          dataW = $(this).data('modal-width'),
          lightbox = $(this).data('modal-lightbox'),
          closeTime = $(this).data('modal-close-time'),
          closeOnlyBtn = $(this).data('modal-close-onlybtn');

      if (modal_dialog_js_typeof(dataH) === ( true ? "undefined" : undefined)) {
        dataH = false;
      }

      if (modal_dialog_js_typeof(dataW) === ( true ? "undefined" : undefined)) {
        dataW = false;
      }

      if (modal_dialog_js_typeof(lightbox) === ( true ? "undefined" : undefined)) {
        lightbox = true;
      }

      if (modal_dialog_js_typeof(closeTime) === ( true ? "undefined" : undefined)) {
        closeTime = false;
      }

      if (modal_dialog_js_typeof(closeOnlyBtn) === ( true ? "undefined" : undefined)) {
        closeOnlyBtn = false;
      }

      $(document).UixFireModalDialog({
        id: $(this).data('modal-id'),
        height: dataH,
        width: dataW,
        speed: modalSpeed,
        btn: $(this),
        lightbox: lightbox,
        autoClose: closeTime,
        closeOnlyBtn: closeOnlyBtn
      });
      return false;
    });
    $(document).off('click.MODAL_DIALOG_CLOSE').on('click.MODAL_DIALOG_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
      //btn
      if ($(this).hasClass('uix-modal-box__close')) {
        $(this).parent().removeClass('is-active');
      }

      $(document).UixCloseModalDialog();
      return false;
    });
  };

  module.components.documentReady.push(module.MODAL_DIALOG.documentReady);
  return function MODAL_DIALOG() {
    modal_dialog_js_classCallCheck(this, MODAL_DIALOG);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/mousewheel-interaction/js/index.js
function mousewheel_interaction_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Mousewheel Interaction -->
 *************************************
 */

var MOUSEWHEEL_INTERACTION = function (module, $, window, document) {
  if (window.MOUSEWHEEL_INTERACTION === null) return false;
  module.MOUSEWHEEL_INTERACTION = module.MOUSEWHEEL_INTERACTION || {};
  module.MOUSEWHEEL_INTERACTION.version = '0.0.3';

  module.MOUSEWHEEL_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if (!$('body').hasClass('mousewheel-interaction')) return false; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000; //According to page transition animation changes

    var lastAnimation = 0;
    var scrollCount = 0;
    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */

    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        $('#demo-mousewheel-interaction-status').html('Direction: down, Total: ' + scrollCount);
        scrollCount++;
      } else {
        //scroll up
        $('#demo-mousewheel-interaction-status').html('Direction: up, Total: ' + scrollCount);
        scrollCount++;
      }

      lastAnimation = timeNow;
    }
  };

  module.components.documentReady.push(module.MOUSEWHEEL_INTERACTION.documentReady);
  return function MOUSEWHEEL_INTERACTION() {
    mousewheel_interaction_js_classCallCheck(this, MOUSEWHEEL_INTERACTION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/GSAP/ModifiersPlugin.js
function ModifiersPlugin_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ModifiersPlugin_typeof = function _typeof(obj) { return typeof obj; }; } else { ModifiersPlugin_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ModifiersPlugin_typeof(obj); }

/*!
 * VERSION: 0.0.4
 * DATE: 2018-05-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */


var _cssRatioSetter = function _cssRatioSetter(pt, cssp, mod) {
  //Takes an individual CSSPropTween and converts it into a type:2 that has a setRatio that does everything the regular CSSPlugin.setRatio() method does but applying the mod() too. We do this to keep the main CSSPlugin.setRatio() as fast as possible (the vast majority of times, no mod() will be necessary)
  var type = pt.type,
      oldSetRatio = pt.setRatio,
      tween = cssp._tween,
      target = cssp._target;
  pt.type = 2;
  pt.m = mod;

  pt.setRatio = function (v) {
    var min = 0.000001,
        val,
        str,
        i;

    if (v === 1 && (tween._time === tween._duration || tween._time === 0)) {
      if (type !== 2) {
        if (pt.r && type !== -1) {
          val = Math.round(pt.s + pt.c);

          if (!type) {
            pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
          } else if (type === 1) {
            str = pt.xs0 + val + pt.xs1;

            for (i = 1; i < pt.l; i++) {
              str += pt["xn" + i] + pt["xs" + (i + 1)];
            }

            pt.t[pt.p] = mod.call(tween, str, target, tween);
          }
        } else {
          pt.t[pt.p] = mod.call(tween, pt.e, target, tween);
        }
      } else {
        oldSetRatio.call(pt, v);
      }
    } else if (v || !(tween._time === tween._duration || tween._time === 0) || tween._rawPrevTime === -0.000001) {
      val = pt.c * v + pt.s;

      if (pt.r) {
        val = Math.round(val);
      } else if (val < min) if (val > -min) {
        val = 0;
      }

      if (!type) {
        pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
      } else if (type === 1) {
        str = pt.xs0 + val + pt.xs1;

        for (i = 1; i < pt.l; i++) {
          str += pt["xn" + i] + pt["xs" + (i + 1)];
        }

        pt.t[pt.p] = mod.call(tween, str, target, tween);
      } else if (type === -1) {
        //non-tweening value
        pt.t[pt.p] = mod.call(tween, pt.xs0, target, tween);
      } else if (oldSetRatio) {
        oldSetRatio.call(pt, v);
      }
    } else {
      if (type !== 2) {
        pt.t[pt.p] = mod.call(tween, pt.b, target, tween);
      } else {
        oldSetRatio.call(pt, v);
      }
    }
  };
},
    _modCSS = function _modCSS(lookup, cssp) {
  var pt = cssp._firstPT,
      hasBezier = lookup.rotation && cssp._overwriteProps.join("").indexOf("bezier") !== -1; //when a Bezier tween is applying autoRotation, it's a very special case we need to handle differently.

  if (lookup.scale) {
    lookup.scaleX = lookup.scaleY = lookup.scale;
  } else if (lookup.rotationZ) {
    lookup.rotation = lookup.rotationZ;
  }

  while (pt) {
    if (typeof lookup[pt.p] === "function") {
      _cssRatioSetter(pt, cssp, lookup[pt.p]);
    } else if (hasBezier && pt.n === "bezier" && pt.plugin._overwriteProps.join("").indexOf("rotation") !== -1) {
      pt.data.mod = lookup.rotation;
    }

    pt = pt._next;
  }
},
    ModifiersPlugin = GSAP_TweenLite["a" /* _gsScope */]._gsDefine.plugin({
  propName: "modifiers",
  version: "0.0.4",
  API: 2,
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function init(target, value, tween) {
    this._tween = tween;
    this._vars = value;
    return true;
  },
  initAll: function initAll() {
    var tween = this._tween,
        lookup = this._vars,
        mpt = this,
        pt = tween._firstPT,
        val,
        next; //initAll() gets called for each and every ModifiersPlugin instance in a tween, so if there are multiple targets, there will be multiple instances. Since we're ripping through the whole tween (and all the PropTweens), we only need to run this code ONCE. So we're setting a toggle on the first PropTween that just tells us if we've done it already. We don't set it on the tween instance because if it gets invalidated, we don't want to have to track this property and reset it. PropTweens get blown away when a tween is invalidated.

    if (pt._modInitted) {
      return false;
    } else {
      pt._modInitted = 1;
    }

    while (pt) {
      next = pt._next; //record here, because it may get removed

      val = lookup[pt.n];

      if (pt.pg) {
        if (pt.t._propName === "css") {
          //handle CSSPlugin uniquely (for performance, due to the fact that the values almost always are a concatenation of numbers and strings, like suffixes, and we don't want to slow down the regular CSSPlugin setRatio() performance with conditional checks for if the value needs to be modded, so we pull any modding prop out and change it to a type:2 one that simply calls a setRatio() method where we encapsulate the modding and update all together. That way, it says in the main CSSProp linked list and just has some custom logic applied to it inside its setRatio())
          _modCSS(lookup, pt.t);
        } else if (pt.t !== mpt) {
          //don't run modProps on modProps :)
          val = lookup[pt.t._propName];
          pt.t._tween = tween;

          pt.t._mod(ModifiersPlugin_typeof(val) === "object" ? val : lookup);
        }
      } else if (typeof val === "function") {
        if (pt.f === 2 && pt.t) {
          //a blob (text containing multiple numeric values)
          pt.t._applyPT.m = val;
          pt.t._tween = tween;
        } else {
          this._add(pt.t, pt.p, pt.s, pt.c, val); //remove from linked list


          if (next) {
            next._prev = pt._prev;
          }

          if (pt._prev) {
            pt._prev._next = next;
          } else if (tween._firstPT === pt) {
            tween._firstPT = next;
          }

          pt._next = pt._prev = null;
          tween._propLookup[pt.n] = mpt;
        }
      }

      pt = next;
    }

    return false;
  }
}),
    ModifiersPlugin_p = ModifiersPlugin.prototype;

ModifiersPlugin_p._add = function (target, p, s, c, mod) {
  this._addTween(target, p, s, s + c, p, mod);

  this._overwriteProps.push(p);
};

ModifiersPlugin_p = GSAP_TweenLite["a" /* _gsScope */]._gsDefine.globals.TweenLite.version.split(".");

if (Number(ModifiersPlugin_p[0]) <= 1 && Number(ModifiersPlugin_p[1]) < 19 && GSAP_TweenLite["a" /* _gsScope */].console) {
  console.log("ModifiersPlugin requires GSAP 1.19.0 or later.");
}


// EXTERNAL MODULE: ./src/components/multi-items-carousel/scss/_style.scss
var multi_items_carousel_scss_style = __webpack_require__(58);

// CONCATENATED MODULE: ./src/components/multi-items-carousel/js/index.js
function multi_items_carousel_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function multi_items_carousel_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { multi_items_carousel_js_typeof = function _typeof(obj) { return typeof obj; }; } else { multi_items_carousel_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return multi_items_carousel_js_typeof(obj); }

/* 
 *************************************
 * <!-- Multiple Items Carousel -->
 *************************************
 */



var MULTI_ITEMS_CAROUSEL = function (module, $, window, document) {
  if (window.MULTI_ITEMS_CAROUSEL === null) return false;
  module.MULTI_ITEMS_CAROUSEL = module.MULTI_ITEMS_CAROUSEL || {};
  module.MULTI_ITEMS_CAROUSEL.version = '0.0.5';

  module.MULTI_ITEMS_CAROUSEL.documentReady = function ($) {
    $('.uix-multi-carousel').each(function () {
      var $carouselWrapper = $(this),
          $carousel = $carouselWrapper.find('.uix-multi-carousel__items'),
          $carouselItem = $carouselWrapper.find('.uix-multi-carousel__items > div'),
          itemTotal = $carouselItem.length,
          amountVisible = $carouselWrapper.data('show'),
          carouselDir = $carouselWrapper.data('dir'),
          carouselLoop = $carouselWrapper.data('loop'),
          carouselSpeed = $carouselWrapper.data('speed'),
          carouselNext = $carouselWrapper.data('next'),
          carouselPrev = $carouselWrapper.data('prev'),
          carouseDraggable = $carouselWrapper.data('draggable'),
          carouseDraggableCursor = $carouselWrapper.data('draggable-cursor');
      if (multi_items_carousel_js_typeof(carouselDir) === ( true ? "undefined" : undefined)) carouselDir = 'horizontal';
      if (multi_items_carousel_js_typeof(carouselLoop) === ( true ? "undefined" : undefined)) carouselLoop = false;
      if (multi_items_carousel_js_typeof(amountVisible) === ( true ? "undefined" : undefined)) amountVisible = 3;
      if (multi_items_carousel_js_typeof(carouselSpeed) === ( true ? "undefined" : undefined)) carouselSpeed = 250;
      if (multi_items_carousel_js_typeof(carouselNext) === ( true ? "undefined" : undefined)) carouselNext = '.uix-multi-carousel__controls--next';
      if (multi_items_carousel_js_typeof(carouselPrev) === ( true ? "undefined" : undefined)) carouselPrev = '.uix-multi-carousel__controls--prev';
      if (multi_items_carousel_js_typeof(carouseDraggable) === ( true ? "undefined" : undefined)) carouseDraggable = false;
      if (multi_items_carousel_js_typeof(carouseDraggableCursor) === ( true ? "undefined" : undefined)) carouseDraggableCursor = 'move';
      if (window.innerWidth <= 768) amountVisible = 3; // Returns the value of a number rounded to the nearest integer.

      var midIndex = Math.round(amountVisible / 2) - 1;
      /* 
       ---------------------------
       Initialize carousel
       ---------------------------
       */

      var eachItemNewWidth, eachItemNewHeight;
      var eachItemOldWidth = $carousel.width() / amountVisible;
      var eachItemOldHeight = $carousel.height() / amountVisible;

      if (carouselDir == 'horizontal') {
        eachItemNewWidth = $carouselWrapper.width() / amountVisible;
        $carousel.css('width', itemTotal * eachItemOldWidth);
      } else {
        eachItemNewHeight = $carouselWrapper.height() / amountVisible;
        $carousel.css('height', itemTotal * eachItemOldHeight);
      } // Re-order all items


      carouselReOrder(); //default button status

      if (!carouselLoop) {
        $(carouselPrev).addClass('is-disabled').data('disabled', 1);
      }
      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */


      function carouselReOrder() {
        if (carouselDir == 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($carouselItem, {
            width: boxWidth,
            x: function x(i, target) {
              //Active the center item
              if (i === midIndex && carouselLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              } //Add index to each item


              $carouselItem.eq(i).attr('data-index', i);
              return i * boxWidth;
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          TweenMax.set($carouselItem, {
            height: boxHeight,
            y: function y(i, target) {
              //Active the center item
              if (i === midIndex && carouselLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              } //Add index to each item


              $carouselItem.eq(i).attr('data-index', i);
              return i * boxHeight;
            }
          });
        }
      }
      /* 
       ---------------------------
       Move left/up
       ---------------------------
       */


      $(carouselNext).off('click').on('click', $carouselWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(carouselSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        movePositionWithButton($(this), e, 'next');
      });
      /* 
       ---------------------------
       Move right/down
       ---------------------------
       */

      $(carouselPrev).off('click').on('click', $carouselWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(carouselSpeed).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //

        movePositionWithButton($(this), e, 'prev');
      }); //Drag and Drop
      //-------------------------------------	

      var $dragDropTrigger = $carouselWrapper;
      var hammerProps = {}; //Make the cursor a move icon when a user hovers over an item

      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);

      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true; // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type; //Determine whether it is the first or the last    

        var currentIsFirstOrLast = false;

        if (!carouselLoop) {
          var firstItemOffset = carouselDir == 'horizontal' ? $carousel.find('[data-index="0"]')[0]._gsTransform.x : $carousel.find('[data-index="0"]')[0]._gsTransform.y;
          var maxMoveOffset = carouselDir == 'horizontal' ? -eachItemNewWidth * (itemTotal - amountVisible) : -eachItemNewHeight * (itemTotal - amountVisible);

          if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
            //first item
            currentIsFirstOrLast = true;
          }

          if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
            //last item
            currentIsFirstOrLast = true;
          }
        } //Rebound effect of drag offset 


        switch (direction) {
          case 'panleft':
            if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
              elAnim = false;
              itemUpdates($carouselWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'panup':
            if (ev.deltaY > -eachItemNewHeight / 4 && ev.deltaY < 0) {
              elAnim = false;
              itemUpdates($carouselWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'panright':
            if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
              elAnim = false;
              itemUpdates($carouselWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'pandown':
            if (ev.deltaY < eachItemNewHeight / 4 && ev.deltaY > 0) {
              elAnim = false;
              itemUpdates($carouselWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          switch (direction) {
            case 'panleft':
            case 'panup':
              var delta1 = carouselDir == 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
              itemUpdates($carouselWrapper, delta1, null, false);
              break;

            case 'panright':
            case 'pandown':
              var delta2 = carouselDir == 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
              itemUpdates($carouselWrapper, delta2, null, false);
              break;
          }
        } else {
          itemUpdates($carouselWrapper, 0, null, false);
        }
      });
      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper        - Wrapper of carousel.
                * @param  {Number} delta           - The value returned will need to be adjusted according to the offset rate.
                * @param  {?Number} speed          - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging       - Determine if the object is being dragged.
       * @return {Void}
       */

      function itemUpdates(wrapper, delta, speed, dragging) {
        if (speed == null) speed = carouselSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-multi-carousel__items'),
            //Default: $carousel
        $curItems = $curWrapper.find('> div'); //Default: $carouselItem
        //Clone the first element to the last position

        if (carouselDir == 'horizontal') {
          var boxWidth = eachItemNewWidth;
          var wrapWidth = ($curItems.length - 1) * boxWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
              return x + delta;
            },
            modifiers: {
              x: function x(_x, target) {
                if (carouselLoop) {
                  //Active the center item
                  if (_x === midIndex * boxWidth) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }

                  return wrap(_x, -boxWidth, wrapWidth);
                } else {
                  return _x;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth));
              }
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          var wrapHeight = ($curItems.length - 1) * boxHeight;
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var y = Math.round(target._gsTransform.y / boxHeight) * boxHeight;
              return y + delta;
            },
            modifiers: {
              y: function y(_y, target) {
                if (carouselLoop) {
                  //Active the center item
                  if (_y === midIndex * boxHeight) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }

                  return wrap(_y, -boxHeight, wrapHeight);
                } else {
                  return _y;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.y), Math.round(($curItems.length - amountVisible) * boxHeight));
              }
            }
          });
        }
      }
      /*
       * Move function with buttons
       *
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {Object} event               - Bind an event handler to the "click" JavaScript event,
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */


      function movePositionWithButton($btn, event, type) {
        var $curWrapper = $(event.data[0]),
            //Protection button is not triggered multiple times.
        btnDisabled = $btn.data('disabled');
        var delta;

        if (type == 'next') {
          delta = carouselDir == 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
        } else {
          delta = carouselDir == 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
        }

        if (multi_items_carousel_js_typeof(btnDisabled) === ( true ? "undefined" : undefined)) {
          itemUpdates($curWrapper, delta, null, false);
        }
      }
      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */


      function setButtonState(firstOffset, lastOffset) {
        if (carouselLoop) return false;

        if (Math.abs(firstOffset) == lastOffset) {
          $(carouselNext).addClass('is-disabled').data('disabled', 1);
          $(carouselPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(carouselNext).removeClass('is-disabled').removeData('disabled');
          $(carouselPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(carouselNext).removeClass('is-disabled').removeData('disabled');
          $(carouselPrev).removeClass('is-disabled').removeData('disabled');
        }
      }
      /*
       * Tweens each box to a relative x/y position of "+={number}"
       *
       * @param  {Number} value           - Current position of the element, x or y coordinates.
       * @param  {Number} min             - The minimum value, used to mark the width or height of each element.
       * @param  {Number} max             - The maximum value, used to mark the width or height of the entire container.
       * @return {Number}                 - The about-to-be-applied value from the regular tween.
       */


      function wrap(value, min, max) {
        var v = value - min;
        var r = max - min; // force x/y value to be between {min} and {max} using modulus

        return (r + v % r) % r + min;
      }
    });
  };

  module.components.documentReady.push(module.MULTI_ITEMS_CAROUSEL.documentReady);
  return function MULTI_ITEMS_CAROUSEL() {
    multi_items_carousel_js_classCallCheck(this, MULTI_ITEMS_CAROUSEL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/third-party-plugins/esm/Miscellaneous/hashchange.js
var hashchange = __webpack_require__(7);

// CONCATENATED MODULE: ./src/components/one-page/js/index.js
function one_page_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Full Page/One Page Transition -->
 *************************************
 */



var ONEPAGE = function (module, $, window, document) {
  if (window.ONEPAGE === null) return false;
  module.ONEPAGE = module.ONEPAGE || {};
  module.ONEPAGE.version = '0.0.9';

  module.ONEPAGE.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    $sectionsContainer = $('.uix-normal-load__onepage-container'),
        $sections = $sectionsContainer.find('[data-highlight-section]'),
        sectionTotal = $sections.length,

    /* topSpacing         = ( window.innerWidth <= 768 ) ? 0 : $( '.uix-header__container' ).outerHeight( true ), //with margin */
    topSpacing = 0,
        $primaryMenu = $('.uix-menu'),
        $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0; //Prevent this module from loading in other pages

    if ($sectionsContainer.length == 0) return false; // Prepare everything before binding wheel scroll

    $.each($sections, function (i) {
      $(this).attr('data-index', i);

      if (i == 0) {
        $(this).addClass('is-active');
      }
    }); //Init the section location

    sectionStart(); //Detect URL change

    $(window).on('hashchange', function () {
      var hash = window.location.hash,
          locArr,
          loc;

      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });
    /*
     * Init the section location
     *
     * @return {Void}
     */

    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
            locArr,
            loc,
            curTab;

        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */


    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */


    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
          isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
          $next = null;

      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      } //ID of custom hashchange event


      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);

      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0; //Returns the target section

        $next = $sections.eq(nextIndex); //Smooth scroll to content

        if ($next.length > 0) {
          TweenMax.to(window, animationTime / 1000, {
            scrollTo: {
              y: $next.offset().top - topSpacing,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              $sections.removeClass('leave');
              $sections.eq(index).addClass('leave');
              $sections.removeClass('is-active');
              $next.addClass('is-active').removeClass('leave'); //Changing The Site URL

              var curSectionIndex = $sections.filter('.is-active').index() + 1,
                  href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id'); // Save state on history stack
              // - First argument is any object that will let you restore state
              // - Second argument is a title (not the page title, and not currently used)
              // - Third argument is the URL - this will appear in the browser address bar

              history.pushState({}, document.title, href);
              console.log('Section ' + curSectionIndex + ' loaded!');
            }
          });
        }
      }
    }
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */


    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu); //Activate the first item

    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');
    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */

    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }
    /*
     * Get link by section or article id
     *
     * @param  {String|Element} el    - The current selector or selector ID
     * @param  {Element} menuObj       - Returns the menu element within the document.
     * @param  {Boolean} echoIndex    - Whether to return the current index.
     * @return {Object}               - A new selector.
     */


    function getRelatedNavigation(el, menuObj, echoIndex) {
      if (echoIndex) {
        return menuObj.find('li > a[href=#' + $(el).attr('id') + ']').parent('li').index();
      } else {
        return menuObj.find('li > a[href=#' + $(el).attr('id') + ']').parent('li');
      }
    }
    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */


    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }
    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */


    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE').on('click.ONEPAGE', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        moveTo($sectionsContainer, false, $(this).parent('li').index() + 1);
      });
    }

    var navMinTop = $sidefixedMenu.length > 0 ? $sidefixedMenu.offset().top : 0,
        navMaxTop = parseFloat($(document).height() - $('.uix-footer__container').height()) - windowHeight / 3;
    $window.off('scroll.ONEPAGE touchmove.ONEPAGE').on('scroll.ONEPAGE touchmove.ONEPAGE', function () {
      var scrolled = $(this).scrollTop(),
          spyTop = parseFloat(scrolled + topSpacing),
          minTop = $('[data-highlight-section="true"]').first().offset().top,
          maxTop = $('[data-highlight-section="true"]').last().offset().top + $('[data-highlight-section="true"]').last().height();
      $('[data-highlight-section="true"]').each(function () {
        var $block = $(this),
            eleTop = $block.offset().top; // The 1 pixel in order to solve inaccurate value of outerHeight() 
        // in Safari and Firefox browsers.

        if (eleTop < spyTop + 1) {
          // Highlight element when related content
          getAllNavigation($primaryMenu).removeClass('is-active');
          getAllNavigation($sidefixedMenu).removeClass('is-active');
          getRelatedNavigation($block, $primaryMenu, false).addClass('is-active');
          getRelatedNavigation($block, $sidefixedMenu, false).addClass('is-active');
        }
      }); //Cancel the current highlight element
      // The 1 pixel in order to solve inaccurate value of outerHeight() 
      // in Safari and Firefox browsers.

      if (spyTop > maxTop || spyTop < minTop - 1) {
        getAllNavigation($primaryMenu).removeClass('is-active');
        getAllNavigation($sidefixedMenu).removeClass('is-active');
      } //Detecting when user scrolls to bottom of div


      if (spyTop > navMaxTop || spyTop < navMinTop) {
        $sidefixedMenu.removeClass('is-fixed');
      } else {
        $sidefixedMenu.addClass('is-fixed');
      }
    });
    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */

    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, {
      passive: true
    });
    window.addEventListener('touchstart', onTouchStart, {
      passive: true
    });
    window.addEventListener('touchmove', onDeviceWheel, {
      passive: true
    });
  };

  module.components.documentReady.push(module.ONEPAGE.documentReady);
  return function ONEPAGE() {
    one_page_js_classCallCheck(this, ONEPAGE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/one-page2/js/index.js
function one_page2_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Full Page/One Page Transition 2 -->
 *************************************
 */


var ONEPAGE2 = function (module, $, window, document) {
  if (window.ONEPAGE2 === null) return false;
  module.ONEPAGE2 = module.ONEPAGE2 || {};
  module.ONEPAGE2.version = '0.0.7';

  module.ONEPAGE2.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    $sectionsContainer = $('.uix-normal-load__onepage-container2'),
        $sections = $sectionsContainer.find('[data-highlight-section]'),
        sectionTotal = $sections.length,
        $primaryMenu = $('.uix-menu'),
        $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0; //Prevent this module from loading in other pages

    if ($sectionsContainer.length == 0) return false; //Init the sections style

    $sectionsContainer.css({
      'position': 'relative'
    });
    var secIndex = 10;

    for (var i = 0; i < sectionTotal; i++) {
      $sections.eq(i).css({
        'position': 'absolute',
        'width': '100%',
        'z-index': secIndex,
        'top': 0,
        'left': 0
      });
      secIndex--;
    } // Prepare everything before binding wheel scroll


    $.each($sections, function (i) {
      $(this).attr('data-index', i);

      if (i == 0) {
        $(this).addClass('is-active');
      }
    }); //Init the section location

    sectionStart(); //Detect URL change

    $(window).on('hashchange', function () {
      var hash = window.location.hash,
          locArr,
          loc;

      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });
    /*
     * Init the section location
     *
     * @return {Void}
     */

    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
            locArr,
            loc,
            curTab;

        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }
    /*
     * Initialize the depth of all sections
     *
     * @param  {Number} nextIndex        - Index of next section.
     * @param  {Number} currentIndex     - Index of current section.
     * @return {Void}
     */


    function sectionsDepthInit(nextIndex, currentIndex) {
      var secIndex = 10;

      for (var _i = 0; _i < sectionTotal; _i++) {
        if (nextIndex && _i != nextIndex && _i != currentIndex) {
          $sections.eq(_i).css('z-index', secIndex);
        }

        secIndex--;
      }
    }
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */


    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */


    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
          isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
          $next = null;

      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      } //ID of custom hashchange event


      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);

      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0; //Returns the target section

        $next = $sections.eq(nextIndex);

        if ($next.length > 0) {
          TweenMax.set($next, {
            css: {
              'z-index': 12,
              'top': dir == 'down' || dir === false ? windowHeight : -windowHeight
            },
            onComplete: function onComplete() {
              //Reset sections z-index
              $sections.eq(index).css('z-index', 11);
              sectionsDepthInit(nextIndex, index);
              TweenMax.to($sections.eq(index), animationTime / 1000, {
                css: {
                  'top': dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2
                },
                ease: Power2.easeOut
              });
              TweenMax.to(this.target, animationTime / 2000, {
                css: {
                  'top': 0
                },
                ease: Power2.easeOut,
                onComplete: function onComplete() {
                  $sections.removeClass('leave');
                  $sections.eq(index).addClass('leave');
                  $sections.removeClass('is-active');
                  $next.addClass('is-active').removeClass('leave'); //Changing The Site URL

                  var curSectionIndex = $sections.filter('.is-active').index() + 1,
                      href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id'); // Save state on history stack
                  // - First argument is any object that will let you restore state
                  // - Second argument is a title (not the page title, and not currently used)
                  // - Third argument is the URL - this will appear in the browser address bar

                  history.pushState({}, document.title, href);
                  console.log('Section ' + curSectionIndex + ' loaded!'); // Highlight element when related content

                  getAllNavigation($primaryMenu).removeClass('is-active');
                  getAllNavigation($sidefixedMenu).removeClass('is-active');
                  $primaryMenu.find('li').eq(nextIndex).addClass('is-active');
                  $sidefixedMenu.find('li').eq(nextIndex).addClass('is-active');
                }
              });
            }
          });
        }
      }
    }
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */


    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu); //Activate the first item

    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');
    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */

    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }
    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */


    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }
    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */


    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE2').on('click.ONEPAGE2', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        var dir = 'down';

        if ($sections.filter('.is-active').index() > $(this).parent().index()) {
          dir = 'up';
        }

        moveTo($sectionsContainer, dir, $(this).parent('li').index() + 1);
      });
    }
    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */


    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
  };

  module.components.documentReady.push(module.ONEPAGE2.documentReady);
  return function ONEPAGE2() {
    one_page2_js_classCallCheck(this, ONEPAGE2);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/parallax/scss/_style.scss
var parallax_scss_style = __webpack_require__(59);

// CONCATENATED MODULE: ./src/components/parallax/js/index.js
function parallax_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function parallax_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { parallax_js_typeof = function _typeof(obj) { return typeof obj; }; } else { parallax_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return parallax_js_typeof(obj); }

/* 
 *************************************
 * <!-- Parallax -->
 *************************************
 */



var PARALLAX = function (module, $, window, document) {
  if (window.PARALLAX === null) return false;
  module.PARALLAX = module.PARALLAX || {};
  module.PARALLAX.version = '0.0.7';

  module.PARALLAX.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    parallaxInit(windowWidth, windowHeight);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight; // Do stuff here

        parallaxInit(windowWidth, windowHeight);
      }
    });
    /*
     * Initialize parallx settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function parallaxInit(w, h) {
      /* Pure parallax scrolling effect without other embedded HTML elements */
      $('.uix-parallax--el').each(function () {
        var $this = $(this);
        var dataSpeed = $this.data('speed'),
            dataEasing = $this.data('transition');

        if (parallax_js_typeof(dataSpeed) === ( true ? "undefined" : undefined)) {
          dataSpeed = 0;
        }

        if (parallax_js_typeof(dataEasing) === ( true ? "undefined" : undefined)) {
          dataEasing = 'none 0s ease 0s';
        }

        $this.UixParallax({
          'speed': dataSpeed,
          'bg': false,
          transition: dataEasing
        });
      });
      /* Parallax scrolling effect with embedded HTML elements */

      $('.uix-parallax').each(function () {
        var $this = $(this);
        var $curImg = $this.find('.uix-parallax__img'),
            dataImg = $curImg.attr('src');
        var dataSkew = $this.data('skew'),
            dataSpeed = $this.data('speed'),
            dataEasing = $this.data('transition'),
            dataOverlay = $this.data('overlay-bg'),
            dataFullyVisible = $this.data('fully-visible'),
            dataXPos = $this.data('xpos'),
            dataOffsetTop = parseFloat($this.data('offset-top')),
            curImgH = null,
            curImgW = null,
            curSize = 'cover';

        if (parallax_js_typeof(dataOverlay) === ( true ? "undefined" : undefined) || dataOverlay == 'none' || dataOverlay == 0 || dataOverlay == false) {
          dataOverlay = 'rgba(0, 0, 0, 0)';
        }

        if (parallax_js_typeof(dataSpeed) === ( true ? "undefined" : undefined)) {
          // If there is no data-xxx, save current source to it
          dataSpeed = 0;
        }

        if (parallax_js_typeof(dataEasing) === ( true ? "undefined" : undefined)) {
          dataEasing = 'none 0s ease 0s';
        }

        if (parallax_js_typeof(dataXPos) === ( true ? "undefined" : undefined)) {
          dataXPos = '50%';
        }

        if (parallax_js_typeof(dataOffsetTop) === ( true ? "undefined" : undefined)) {
          dataOffsetTop = 0;
        }

        if (parallax_js_typeof(dataFullyVisible) === ( true ? "undefined" : undefined)) {
          dataFullyVisible = false;
        } //Trigger a callback when the selected images are loaded
        //Check if the picture is loaded on the page


        var img = new Image();

        img.onload = function () {
          curImgH = $curImg.height();
          curImgW = $curImg.width(); //Custom height for parallax container

          if ($this.hasClass('uix-height--10') || $this.hasClass('uix-height--20') || $this.hasClass('uix-height--30') || $this.hasClass('uix-height--40') || $this.hasClass('uix-height--50') || $this.hasClass('uix-height--60') || $this.hasClass('uix-height--70') || $this.hasClass('uix-height--80') || $this.hasClass('uix-height--90') || $this.hasClass('uix-height--100')) {
            var newH = $this.height();
            $this.css({
              'height': newH + 'px'
            });
            $curImg.css('max-height', newH + 'px');
          } else {
            $this.css({
              'height': $this.height() + 'px'
            });
          } //If the ".uix-v-align--absolute" has more content


          if (w <= 768) {
            if ($this.find('.uix-v-align--absolute').height() >= curImgH) {
              $this.find('.uix-v-align--absolute').addClass('uix-v-align--relative');
              $curImg.hide();
            }
          } //Resize the background image to cover the entire container and
          //Resize the background image to make sure the image is fully visible


          if (curImgW > w) {
            curSize = 'contain';
          } else {
            curSize = 'cover';
          } //Determine image height and parallax container height
          //If the height is the same, higher or lower than the height of the container height, 
          //be sure to use the cover attribute
          //*** Must be placed before the "dataFullyVisible" condition


          if (curImgH <= $this.height()) {
            curSize = 'cover';
          } //Whether to display all pictures, including the edges


          if (dataFullyVisible) {
            if (curImgW < w) {
              curSize = 'cover';
            } else {
              curSize = 'contain';
            }
          } //console.log( 'Height: ' +curImgH + '===' + $this.height() + ' | Width: ' + curImgW + '===' + w + ' | ' + curSize );
          //Add background image to parallax container


          if (parallax_js_typeof(dataImg) != ( true ? "undefined" : undefined)) {
            if (Modernizr.cssanimations) {
              // supported
              $this.css({
                'background': 'linear-gradient(' + dataOverlay + ', ' + dataOverlay + '), url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            } else {
              // not-supported
              $this.css({
                'background': 'url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            }
          } //Apply tilt effect


          if (parallax_js_typeof(dataSkew) != ( true ? "undefined" : undefined) && dataSkew != 0) {
            //Firefox browser will affect parallax effect due to transform
            $this.css({
              'transform': 'skew(0deg, ' + dataSkew + 'deg)'
            });
          } //Use parallax to background


          $this.UixParallax({
            'speed': dataSpeed,
            'transition': dataEasing,
            'offsetTop': dataOffsetTop,
            'bg': {
              enable: true,
              xPos: dataXPos
            }
          });
        };

        img.src = dataImg;
      });
    }
  };

  module.components.documentReady.push(module.PARALLAX.documentReady);
  return function PARALLAX() {
    parallax_js_classCallCheck(this, PARALLAX);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/periodical-scroll/scss/_style.scss
var periodical_scroll_scss_style = __webpack_require__(60);

// CONCATENATED MODULE: ./src/components/periodical-scroll/js/index.js
function periodical_scroll_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function periodical_scroll_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { periodical_scroll_js_typeof = function _typeof(obj) { return typeof obj; }; } else { periodical_scroll_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return periodical_scroll_js_typeof(obj); }

/* 
 *************************************
 * <!-- Periodical Scroll -->
 *************************************
 */


var PERIODICAL_SCROLL = function (module, $, window, document) {
  if (window.PERIODICAL_SCROLL === null) return false;
  module.PERIODICAL_SCROLL = module.PERIODICAL_SCROLL || {};
  module.PERIODICAL_SCROLL.version = '0.0.3';

  module.PERIODICAL_SCROLL.documentReady = function ($) {
    $('.uix-periodical-scroll').each(function () {
      var $this = $(this);
      var speed = $this.data('speed'),
          timing = $this.data('timing');
      var $list = $this.find('> ul');
      var itemHeight = $list.find('li:first').height();

      if (periodical_scroll_js_typeof(speed) === ( true ? "undefined" : undefined)) {
        speed = 600;
      }

      if (periodical_scroll_js_typeof(timing) === ( true ? "undefined" : undefined)) {
        timing = 2000;
      }

      var $item = $list.find('> li');
      var moveY = itemHeight * 2;
      var tl = new TimelineMax({
        onComplete: function onComplete() {
          TweenMax.set($item.first(), {
            opacity: 0,
            y: moveY
          });
          setTimeout(function () {
            tl.restart();
          }, timing);
        }
      });
      tl.add(TweenMax.staggerFromTo($item, speed / 1000, {
        opacity: 0,
        y: moveY
      }, {
        opacity: 1,
        y: 0
      }, timing / 1000)).add(TweenMax.staggerTo($item, speed / 1000, {
        delay: timing / 1000,
        opacity: 0,
        y: -moveY
      }, timing / 1000), 0);
      $list.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();
      });
    });
  };

  module.components.documentReady.push(module.PERIODICAL_SCROLL.documentReady);
  return function PERIODICAL_SCROLL() {
    periodical_scroll_js_classCallCheck(this, PERIODICAL_SCROLL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/pricing/scss/_style.scss
var pricing_scss_style = __webpack_require__(61);

// CONCATENATED MODULE: ./src/components/pricing/js/index.js
function pricing_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Pricing -->
 *************************************
 */


var PRICING = function (module, $, window, document) {
  if (window.PRICING === null) return false;
  module.PRICING = module.PRICING || {};
  module.PRICING.version = '0.0.2';

  module.PRICING.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Pricing initialize

    pricingInit(windowWidth);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        pricingInit(windowWidth);
      }
    });

    function pricingInit(w) {
      //Initialize the height
      $('.uix-price').each(function () {
        //returns new id
        var $this = $(this);
        var $initHeight = $this.find('.js-uix-init-height');
        var priceBGH = [],
            priceBGH_excerpt = [];
        $initHeight.each(function (index) {
          //Screen protection of height
          $(this).find('.uix-price__outline, .uix-price__excerpt').css('height', 'auto');
          var tempheight = $(this).height();
          var tempheight_excerpt = $(this).find('.uix-price__excerpt').height();
          priceBGH.push(tempheight);
          priceBGH_excerpt.push(tempheight_excerpt);
        });
        var priceBGH_Max = Math.max.apply(Math, priceBGH);

        if (priceBGH_Max > 0) {
          if (w > 768) {
            // Initialize the height of all columns
            $initHeight.find('.uix-price__outline').css('height', priceBGH_Max + 'px'); // Actived columns

            $initHeight.find('.uix-price__outline.is-active').each(function () {
              var ty = Math.abs(parseInt($(this).css('transform').split(',')[5]));

              if (!isNaN(ty)) {
                $(this).css('height', priceBGH_Max + ty * 2 + 'px');
              }
            });
          } else {
            $initHeight.find('.uix-price__outline').css('height', 'auto');
          } // Actived columns


          $initHeight.find('.uix-price__outline.is-active').each(function () {
            var textColor = $(this).closest('.uix-price__outline--hover').data('tcolor'),
                btnColor = $(this).closest('.uix-price__outline--hover').data('bcolor');
            $(this).css('background-color', btnColor);
            $(this).find('.uix-btn').removeClass('uix-btn__bg--primary').addClass('uix-btn__bg--secondary');
          });
        }
      });
    }
  };

  module.components.documentReady.push(module.PRICING.documentReady);
  return function PRICING() {
    pricing_js_classCallCheck(this, PRICING);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/progress-bar/scss/_style.scss
var progress_bar_scss_style = __webpack_require__(62);

// CONCATENATED MODULE: ./src/components/progress-bar/js/index.js
function progress_bar_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function progress_bar_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { progress_bar_js_typeof = function _typeof(obj) { return typeof obj; }; } else { progress_bar_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return progress_bar_js_typeof(obj); }

/* 
 *************************************
 * <!-- Progress Bar -->
 *************************************
 */


var PROGRESS_BAR = function (module, $, window, document) {
  if (window.PROGRESS_BAR === null) return false;
  module.PROGRESS_BAR = module.PROGRESS_BAR || {};
  module.PROGRESS_BAR.version = '0.0.6';

  module.PROGRESS_BAR.documentReady = function ($) {
    var $scrollElements = $('[data-progressbar-percent]');
    $(window).off('scroll.PROGRESS_BAR touchmove.PROGRESS_BAR');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this); //

      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if (progress_bar_js_typeof(actived) === ( true ? "undefined" : undefined)) {
            var percent = $el.data('progressbar-percent'),
                unit = $el.data('progressbar-unit');

            if (progress_bar_js_typeof(percent) === ( true ? "undefined" : undefined)) {
              percent = 0;
            }

            if (progress_bar_js_typeof(unit) === ( true ? "undefined" : undefined)) {
              unit = '%';
            } //Radial Progress Bar


            if ($el.hasClass('uix-progressbar--circle')) {
              $el.find('.uix-progressbar__track').html('<span>' + percent + '<em class="uix-progressbar__unit">' + unit + '</em></span>');
              $el.addClass('uix-progressbar--progress-' + percent);
            } //Rectangle Progress Bar


            if ($el.hasClass('uix-progressbar--rectangle')) {
              $el.find('.uix-progressbar__bar > span').html('' + percent + '<em class="uix-progressbar__unit">' + unit + '</em>');
              $el.addClass('uix-progressbar--progress-' + percent);
            } //Prevents front-end javascripts that are activated in the background to repeat loading.


            $el.data('activated', 1);
          } //endif actived

        }
      };

      scrollUpdate(); // Please do not use scroll's off method in each

      $(window).on('scroll.PROGRESS_BAR touchmove.PROGRESS_BAR', function (event) {
        scrollUpdate();
      });
    }); //end each        
  };

  module.components.documentReady.push(module.PROGRESS_BAR.documentReady);
  return function PROGRESS_BAR() {
    progress_bar_js_classCallCheck(this, PROGRESS_BAR);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/progress-line/scss/_style.scss
var progress_line_scss_style = __webpack_require__(63);

// CONCATENATED MODULE: ./src/components/progress-line/js/index.js
function progress_line_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Progress Line -->
 *************************************
 */


var PROGRESS_LINE = function (module, $, window, document) {
  if (window.PROGRESS_LINE === null) return false;
  module.PROGRESS_LINE = module.PROGRESS_LINE || {};
  module.PROGRESS_LINE.version = '0.0.3';

  module.PROGRESS_LINE.documentReady = function ($) {
    var $obj = $('.uix-progress-line'),
        $progressLineCircle = $obj.find('.uix-progress-line__circle'),
        progressLineRestore = function progressLineRestore() {
      var k = 0;
      var progressLineAnimGo = setInterval(function () {
        $progressLineCircle.eq(k).addClass('is-active');
        $progressLineCircle.eq(k).next('.uix-progress-line__bar').addClass('is-active');
        k++;

        if (k == 10) {
          clearInterval(progressLineAnimGo);
        }
      }, 50);
    }; //


    $progressLineCircle.on('mouseenter', function () {
      var curIndex = $(this).index() / 2;
      $progressLineCircle.removeClass('is-active');
      $progressLineCircle.next('.uix-progress-line__bar').removeClass('is-active');

      for (var i = curIndex; i >= 0; i--) {
        $progressLineCircle.eq(i).addClass('is-active');
        $progressLineCircle.eq(i).next('.uix-progress-line__bar').addClass('is-active');
      }
    });
    $progressLineCircle.parent().on('mouseleave', function () {
      progressLineRestore();
    }); //Adapt line width for different resolution
    //		const plLength     = $progressLineCircle.length,
    //			  newPlW       = $obj.find( '.uix-progress-line__circle' ).first().width(),
    //			  plWrapperW   = $obj.width();
    //
    //		$obj.find( '.uix-progress-line__bar' ).css( 'width', parseFloat( plWrapperW - newPlW*plLength )/(plLength-1) + 'px' );
    //		
  };

  module.components.documentReady.push(module.PROGRESS_LINE.documentReady);
  return function PROGRESS_LINE() {
    progress_line_js_classCallCheck(this, PROGRESS_LINE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/retina/js/index.js
function retina_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Retina Graphics for Website -->
 *************************************
 */

var RETINA = function (module, $, window, document) {
  if (window.RETINA === null) return false;
  module.RETINA = module.RETINA || {};
  module.RETINA.version = '0.0.1';

  module.RETINA.documentReady = function ($) {
    //Determine if you have retinal display
    var hasRetina = false,
        rootRetina = typeof exports === 'undefined' ? window : exports,
        mediaQuery = '(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)';

    if (rootRetina.devicePixelRatio > 1 || rootRetina.matchMedia && rootRetina.matchMedia(mediaQuery).matches) {
      hasRetina = true;
    }

    if (hasRetina) {
      //do something
      $('[data-retina]').each(function () {
        $(this).attr({
          'src': $(this).data('retina')
        });
      });
    }
  };

  module.components.documentReady.push(module.RETINA.documentReady);
  return function RETINA() {
    retina_js_classCallCheck(this, RETINA);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/rotating-elements/js/index.js
function rotating_elements_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rotating_elements_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rotating_elements_js_typeof = function _typeof(obj) { return typeof obj; }; } else { rotating_elements_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rotating_elements_js_typeof(obj); }

/* 
 *************************************
 * <!-- Rotating Elements -->
 *************************************
 */

var ROTATING_EL = function (module, $, window, document) {
  if (window.ROTATING_EL === null) return false;
  module.ROTATING_EL = module.ROTATING_EL || {};
  module.ROTATING_EL.version = '0.0.2';

  module.ROTATING_EL.documentReady = function ($) {
    $('[data-pointer-to-deg]').each(function () {
      var $this = $(this);
      var config = $this.data('pointer-to-deg');

      if (rotating_elements_js_typeof(config) === ( true ? "undefined" : undefined)) {
        config = false;
      }

      if (config) {
        if ($(config.target).length == 0) return false;
        var pointer = $(config.target)[0],
            pointerBox = pointer.getBoundingClientRect(),
            centerPoint = window.getComputedStyle(pointer).transformOrigin,
            centers = centerPoint.split(' ');
        var mouseX, mouseY;

        if (config.mouseSpy) {
          $(document).on('mousemove touchstart touchmove', function (e) {
            var pointerEvent = e;

            if (e.targetTouches && e.targetTouches[0]) {
              e.preventDefault();
              pointerEvent = e.targetTouches[0];
              mouseX = pointerEvent.pageX;
              mouseY = pointerEvent.pageY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }

            var centerY = pointerBox.top + parseInt(centers[1]) - window.pageYOffset,
                centerX = pointerBox.left + parseInt(centers[0]) - window.pageXOffset,
                radians = Math.atan2(mouseX - centerX, mouseY - centerY),
                degrees = radians * (180 / Math.PI) * -1 + 180;
            pointer.style.transform = 'rotate(' + degrees + 'deg)';
          });
        }

        $this.off('click').on('click', function (e) {
          e.preventDefault();
          pointer.style.transform = 'rotate(' + config.deg + 'deg)';
        });
      }
    });
  };

  module.components.documentReady.push(module.ROTATING_EL.documentReady);
  return function ROTATING_EL() {
    rotating_elements_js_classCallCheck(this, ROTATING_EL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/scroll-reveal/js/index.js
function scroll_reveal_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scroll_reveal_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scroll_reveal_js_typeof = function _typeof(obj) { return typeof obj; }; } else { scroll_reveal_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scroll_reveal_js_typeof(obj); }

/* 
 *************************************
 * <!-- Scroll Reveal -->
 *************************************
 */

var SCROLL_REVEAL = function (module, $, window, document) {
  if (window.SCROLL_REVEAL === null) return false;
  module.SCROLL_REVEAL = module.SCROLL_REVEAL || {};
  module.SCROLL_REVEAL.version = '0.1.5';

  module.SCROLL_REVEAL.documentReady = function ($) {
    //From JSON config in data attribute in HTML
    var $scrollElements = $('[data-uix-anim]');
    $(window).off('scroll.SCROLL_REVEAL touchmove.SCROLL_REVEAL');
    $scrollElements.each(function () {
      var viewport;
      var $el = $(this);
      var tl = new TimelineMax({
        paused: true
      }); //

      var config = $el.data('uix-anim');

      if (scroll_reveal_js_typeof(config) === ( true ? "undefined" : undefined) || config == '' || config === false) {
        config = {
          "from": {
            "opacity": 0,
            "x": 70
          },
          "to": {
            "opacity": 1,
            "x": 0
          },
          "ease": "Power2.easeOut",
          "duration": 0.4,
          "delay": 0,
          "infinite": false,
          "viewport": '100%' //A percentage of the viewport's height.

        };
      } //get attributes to tweenMax


      var fromCSS = config.from,
          toCSS = config.to,
          myEase = config.ease,
          myDuration = config.duration,
          myDelay = config.delay,
          infinite = config.infinite; //A percentage of the viewport's height.

      viewport = config.viewport;
      if (scroll_reveal_js_typeof(viewport) === ( true ? "undefined" : undefined)) viewport = '100%';
      if (scroll_reveal_js_typeof(myEase) === ( true ? "undefined" : undefined)) myEase = 'Power2.easeOut';
      if (scroll_reveal_js_typeof(myDelay) === ( true ? "undefined" : undefined)) myDelay = 0;
      if (scroll_reveal_js_typeof(myDuration) === ( true ? "undefined" : undefined)) myDuration = 0.4;
      if (scroll_reveal_js_typeof(infinite) === ( true ? "undefined" : undefined)) infinite = false; //Conversion between percentage and decimal

      viewport = parseFloat(viewport) / 100.0; //Make it go back and forth

      var reverse = infinite ? 1 : 0; //Set the initial state of the element

      TweenMax.set($el, {
        css: fromCSS
      }); //

      var fromIsString = Object.prototype.toString.call(fromCSS) == '[object String]' ? true : false;

      if (fromIsString) {
        toCSS = toCSS.replace(/\./, '');
      } else {
        tl.to($el, myDuration, {
          css: toCSS,
          ease: myEase,
          delay: myDelay
        });
        $el[0].animation = tl;
      } //


      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if (scroll_reveal_js_typeof(actived) === ( true ? "undefined" : undefined)) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.delay(myDelay * 1000).queue('fx', function () {
                $(this).addClass(toCSS).dequeue();
              });
            } else {
              $el[0].animation.play(); //Other animation
              //------------------------
              //Image transition

              spyImageTrans('show');
            } //Prevents front-end javascripts that are activated in the background to repeat loading.


            $el.data('activated', 1);
          } //endif actived

        } else {
          if (scroll_reveal_js_typeof(actived) !== ( true ? "undefined" : undefined) && reverse === 1) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.removeClass(toCSS);
            } else {
              $el[0].animation.reverse(); //Other animation
              //------------------------
              //Image transition

              spyImageTrans('hide');
            }

            $el.removeData('activated');
          } //endif actived

        }
      };

      scrollUpdate(); // Please do not use scroll's off method in each

      $(window).on('scroll.SCROLL_REVEAL touchmove.SCROLL_REVEAL', function (event) {
        scrollUpdate();
      });
      /*
      * The transition effect of each group of images
      *
      * @return {Void}
      * #Usage: 
      <ul data-uix-anim='{"viewport":"90%","from":{"y":0},"to":{"y":0},"ease":"Power2.easeOut","duration":0.8,"delay":0.2,"infinite":true}' data-img-ids='["[data-imgshow]"]'>
      <li data-imgshow="1"><img src="logo-1.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-2.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-3.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-4.jpg" alt=""></li>
      <ul>
             */

      function spyImageTrans(type) {
        var _imgIds = $el.data('img-ids');

        if (scroll_reveal_js_typeof(_imgIds) !== ( true ? "undefined" : undefined)) {
          //add
          if (type == 'show') {
            _imgIds.forEach(function (element) {
              $(element).each(function (index) {
                $(this).delay(50 * index).queue('fx', function () {
                  $(this).addClass('is-active');
                  $(this).dequeue();
                });
              });
            });
          } else {
            //remove 
            _imgIds.forEach(function (element) {
              $(element).removeClass('is-active');
            });
          }
        }
      }
    }); //end each        
  };

  module.components.documentReady.push(module.SCROLL_REVEAL.documentReady);
  return function SCROLL_REVEAL() {
    scroll_reveal_js_classCallCheck(this, SCROLL_REVEAL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/scrollspy-animate/js/index.js
function scrollspy_animate_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Scrollspy Animate -->
 *************************************
 */

var SCROLLSPY_ANIM = function (module, $, window, document) {
  if (window.SCROLLSPY_ANIM === null) return false;
  module.SCROLLSPY_ANIM = module.SCROLLSPY_ANIM || {};
  module.SCROLLSPY_ANIM.version = '0.0.6';

  module.SCROLLSPY_ANIM.documentReady = function ($) {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var $el = $('#scrollspy-animate-demo'),
        panelHeight = 0; //Prevent this module from loading in other pages

    if ($el.length == 0) return false;
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var curSprite;
    var filterSprite; //-------- Text Affect

    if (Modernizr.webgl) {
      var $txtContainer = $el.find('.row canvas'),
          text = $txtContainer.data('txt').split(''),
          tHeight = 45,
          tWidth = 25,
          renderer = new PIXI.Application({
        width: tWidth * (text.length + 2),
        height: tHeight * 2,
        antialias: true,
        transparent: true,
        resolution: 1,
        autoResize: 1,
        view: document.getElementById('scrollspy-animate-demo--txt')
      });
      var stage = new PIXI.Container();
      filterSprite = PIXI.Sprite.from($txtContainer.data('filter-texture'));
      filterSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
      var filter = new PIXI.filters.DisplacementFilter(filterSprite);
      var txtStyle = new PIXI.TextStyle({
        fontSize: tHeight,
        letterSpacing: 0,
        breakWords: true,
        dropShadow: true,
        dropShadowAngle: Math.PI / 6,
        dropShadowAlpha: 0.5,
        dropShadowColor: '#333',
        dropShadowBlur: 1,
        fill: 'white',
        fontFamily: 'Arial Black',
        fontStyle: 'normal',
        fontWeight: 'bold',
        wordWrap: false,
        align: 'left'
      });
      curSprite = new PIXI.Text($txtContainer.data('txt'), txtStyle);
      curSprite.x = 0;
      curSprite.y = 0;
      renderer.stage.addChild(curSprite);
      curSprite.anchor.set(0);
      curSprite.scale.set(1);
      filterSprite.anchor.set(0);
      filterSprite.scale.set(0.3);
      filterSprite.x = -50;
      filterSprite.y = 0;
      renderer.stage.filterArea = renderer.screen;
      renderer.stage.addChild(curSprite, filterSprite);
      renderer.stage.filters = [filter];
      var ticker = new PIXI.Ticker();
      ticker.autoStart = true;
      ticker.add(function (delta) {
        filterSprite.y += 0.2 * delta; // Render updated scene

        renderer.render(stage);
      });
    }

    $window.off('scroll.SCROLLSPY_ANIM touchmove.SCROLLSPY_ANIM').on('scroll.SCROLLSPY_ANIM touchmove.SCROLLSPY_ANIM', function (event) {
      var elHeight = $el.height(),
          elOffsetTop = $el.offset().top - panelHeight;
      var scrolled = $(this).scrollTop(),
          translateTitle = scrolled / 2,
          translateBackground = scrolled / 3,
          scale = scrolled / elHeight,
          backgroundScale = 1,
          // + scale / 10
      titleScale = 1 - scale * 0.1,
          titleOpacity = 1 - scale,
          scrollProgress = (scrolled - elOffsetTop) / (elHeight - windowHeight / 6); //-------- Animation

      var spyTop = $el[0].getBoundingClientRect().top;

      if (spyTop < window.innerHeight) {
        $el.find('.row').css({
          'transition': 'none',
          'transform': 'translateY(' + translateTitle + 'px) scale(' + titleScale + ')',
          'opacity': titleOpacity
        });
        $('body').removeClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      } else {
        $('body').addClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      } //-------- Display progress


      $el.find('.row h3 em').text(scrollProgress.toFixed(2));

      if (Modernizr.webgl) {
        TweenMax.set(filterSprite, {
          x: windowHeight * scrollProgress
        });
      }
    });
  };

  module.components.documentReady.push(module.SCROLLSPY_ANIM.documentReady);
  return function SCROLLSPY_ANIM() {
    scrollspy_animate_js_classCallCheck(this, SCROLLSPY_ANIM);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/show-more-less/scss/_style.scss
var show_more_less_scss_style = __webpack_require__(64);

// CONCATENATED MODULE: ./src/components/show-more-less/js/index.js
function show_more_less_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Show More Less -->
 *************************************
 */


var SHOW_MORELESS = function (module, $, window, document) {
  if (window.SHOW_MORELESS === null) return false;
  module.SHOW_MORELESS = module.SHOW_MORELESS || {};
  module.SHOW_MORELESS.version = '0.0.3';

  module.SHOW_MORELESS.documentReady = function ($) {
    $('.uix-more-btn__link').each(function () {
      var $btn = $(this),
          $con = $btn.parent().prev('.uix-more-btn'),
          $btnTxt = $btn.find('> span'),
          defaultHeight = $con.height();
      $btn.off('click').on('click', function (e) {
        e.preventDefault();
        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

        if (expanded) {
          $con.addClass('is-active').attr('aria-expanded', true);
          $(this).addClass('is-active').attr('aria-expanded', true); //to open
          // - temporarilty set height:auto
          // - tween from height:0

          TweenMax.set($con, {
            height: 'auto'
          });
          TweenMax.from($con, 0.5, {
            height: defaultHeight
          }); //change text

          $btnTxt.eq(0).hide();
          $btnTxt.eq(1).show();
        } else {
          $con.removeClass('is-active').attr('aria-expanded', false);
          $(this).removeClass('is-active').attr('aria-expanded', false); //to close

          TweenMax.to($con, 0.5, {
            height: defaultHeight
          }); //change text

          $btnTxt.eq(0).show();
          $btnTxt.eq(1).hide();
        }
      });
    });
  };

  module.components.documentReady.push(module.SHOW_MORELESS.documentReady);
  return function SHOW_MORELESS() {
    show_more_less_js_classCallCheck(this, SHOW_MORELESS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/skew-on-scroll/js/index.js
function skew_on_scroll_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Skew Based On Velocity of Scroll -->
 *************************************
 */

var SKEW_ON_SCROLL = function (module, $, window, document) {
  if (window.SKEW_ON_SCROLL === null) return false;
  module.SKEW_ON_SCROLL = module.SKEW_ON_SCROLL || {};
  module.SKEW_ON_SCROLL.version = '0.0.1';

  module.SKEW_ON_SCROLL.documentReady = function ($) {
    $('.uix-skewscroll-container').each(function () {
      var $this = $(this),
          $animObj = $this.find('p'),
          ease = 0.15;
      var followY = 0;
      TweenMax.set($animObj, {
        transformOrigin: "center left"
      });
      TweenMax.ticker.addEventListener('tick', function () {
        followY += (window.scrollY - followY) * ease;
        var dy = (window.scrollY - followY) / 20;
        dy = Math.min(Math.max(dy, -15), 15);
        TweenLite.set($animObj, {
          skewY: dy
        });
      });
    });
  };

  module.components.documentReady.push(module.SKEW_ON_SCROLL.documentReady);
  return function SKEW_ON_SCROLL() {
    skew_on_scroll_js_classCallCheck(this, SKEW_ON_SCROLL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/smooth-scrolling-anchor-link/js/index.js
function smooth_scrolling_anchor_link_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Smooth Scrolling When Clicking An Anchor Link -->
 *************************************
 */


var SMOOTH_SCROLLING_ANCHORLINK = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_ANCHORLINK === null) return false;
  module.SMOOTH_SCROLLING_ANCHORLINK = module.SMOOTH_SCROLLING_ANCHORLINK || {};
  module.SMOOTH_SCROLLING_ANCHORLINK.version = '0.0.8';

  module.SMOOTH_SCROLLING_ANCHORLINK.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var browserURL = window.location.href; //Prevent anchor behaviour
    //Do not add off() to this

    $('a').on('click', function (e) {
      if ($(this).data('smooth-scrolling') != false) {
        var linkURL = $(this).attr('href'),
            locIndex,
            locURL;

        if (linkURL.indexOf('#') >= 0 && linkURL != '#') {
          e.preventDefault();
          var locArr = linkURL.split('#');
          locIndex = locArr[1];
          locURL = locArr[0];

          if (browserURL.indexOf(locURL) < 0) {
            window.location.href = locURL + '#!!' + locIndex;
          }
        }
      }
    }); //Page automatically slide to jump to the corresponding position

    if (browserURL.indexOf('#!!') >= 0) {
      var curndex = browserURL.split('#!!'),
          $target = $('#' + curndex[1]); //Smooth scrolling

      if ($target.length) {
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: $target.offset().top,
            autoKill: false
          },
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Fixed an error that offset().top returns wrong value
            var spyTop = $target[0].getBoundingClientRect().top;

            if (spyTop < 0 || spyTop > 30) {
              $('a[href*="#' + curndex[1] + '"]').trigger('click');
            }
          }
        });
      }
    } //Hyperlink click event
    //Do not add off() to this


    $('a[href*="#"]').on('click', function (e) {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname && $(this).attr('href') != '#' & $(this).attr('href').indexOf('#?') < 0) {
        // Figure out element to scroll to
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']'); // Does a scroll target exist?

        if (target.length) {
          // Only prevent default if animation is actually gonna happen
          e.preventDefault();
          TweenMax.to(window, 0.5, {
            scrollTo: {
              y: target.offset().top,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              // Callback after animation
              // Must change focus!
              var $target = $(target);
              $target.focus();

              if ($target.is(':focus')) {
                // Checking if the target was focused
                return false;
              } else {
                $target.attr('tabindex', '-1'); // Adding tabindex for elements not focusable

                $target.focus();
              }
            }
          });
        }
      }
    });
  };

  module.components.documentReady.push(module.SMOOTH_SCROLLING_ANCHORLINK.documentReady);
  return function SMOOTH_SCROLLING_ANCHORLINK() {
    smooth_scrolling_anchor_link_js_classCallCheck(this, SMOOTH_SCROLLING_ANCHORLINK);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/smooth-scrolling-page/js/index.js
function smooth_scrolling_page_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Smooth Scrolling Page -->
 *************************************
 */

var SMOOTH_SCROLLING_PAGE = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_PAGE === null) return false;
  module.SMOOTH_SCROLLING_PAGE = module.SMOOTH_SCROLLING_PAGE || {};
  module.SMOOTH_SCROLLING_PAGE.version = '0.1.3';

  module.SMOOTH_SCROLLING_PAGE.pageLoaded = function () {
    //Prevent this module from loading in other pages
    //--------------
    if (!$('body').hasClass('smooth-scrolling-page')) return false; // Core params
    //--------------

    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var html = document.documentElement,
        body = document.body,
        scroller = {
      target: '#uix-scrollspy-area',
      ease: 0.05,
      // <= scroll speed
      endY: 0,
      y: 0,
      resizeRequest: 1,
      scrollRequest: 0
    };
    var requestId = null;
    var lastScrollTop = 0; // Determine the direction of scrolling

    TweenMax.set(scroller.target, {
      rotation: 0.01,
      force3D: true
    }); //Increase the viewport to display the visual area

    var elTop = $(scroller.target).offset().top; // Scrolling Progress
    //--------------

    var tlTarget1 = '#app-scrolling-progress1';
    var tlTarget2 = '#app-scrolling-progress2';
    var tlTarget3 = '#app-scrolling-progress3';
    TweenMax.set(tlTarget1, {
      toAlpha: 1
    }); // time should be adjusted relative to window width or height
    // Animation progress has nothing to do with time
    //
    //

    var time = 10;
    var time02 = 2;
    var timestop01 = time / 9.9999;
    var timestop02 = time / 8.1;
    var tlAction = new TimelineMax({
      paused: true
    }).to(tlTarget1, time, {
      height: $(scroller.target).height() - windowHeight * 2 - 200
    }).to(tlTarget1, time02, {
      height: $(scroller.target).height() - windowHeight * 2
    }).to(tlTarget1, time, {
      width: 15
    }, 0).to(tlTarget2, 0.3, {
      rotation: -10,
      scale: 0.5,
      transformOrigin: 'center'
    }, timestop01).to(tlTarget3, 0.3, {
      rotation: 1125,
      scale: 0.1,
      transformOrigin: 'center'
    }, timestop02); //
    //

    var scene2_progress = 0;
    var scene2Action = new TimelineMax({
      paused: true
    }).to('#app-scene-2 p', 0.3, {
      x: 100
    }, 0); //
    //

    var scene3_progress = 0;
    var scene3Action = new TimelineMax({
      paused: true
    }).to('#app-scene-3 p', 0.3, {
      x: 200
    }, 0); // Core Actions
    //--------------

    var initSmoothScrollingPageWrapper = 'js-uix-smooth-scrolling-page-wrapper';

    if (!$('body').hasClass(initSmoothScrollingPageWrapper)) {
      $('body').addClass(initSmoothScrollingPageWrapper);
      $(scroller.target).wrap('<div id="uix-scrollspy-area__wrapper" style="overflow:hidden;position:fixed;height:100%;width:100%;top:0;left:0;right:0;bottom:0;"></div>').css('margin-top', elTop + 'px');
    }

    $(window).on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        scroller.resizeRequest++;

        if (!requestId) {
          requestId = requestAnimationFrame(scrollUpdate);
        }
      }
    });
    $(window).off('scroll.SMOOTH_SCROLLING_PAGE touchmove.SMOOTH_SCROLLING_PAGE').on('scroll.SMOOTH_SCROLLING_PAGE touchmove.SMOOTH_SCROLLING_PAGE', function () {
      scroller.scrollRequest++;

      if (!requestId) {
        requestId = requestAnimationFrame(scrollUpdate);
      }
    });
    scrollUpdate();

    function scrollUpdate() {
      var resized = scroller.resizeRequest > 0;

      if (resized) {
        var height = $(scroller.target).height();
        body.style.height = parseFloat(height + elTop) + "px";
        scroller.resizeRequest = 0;
      }

      var scrollY = window.pageYOffset || html.scrollTop || body.scrollTop || 0;
      scroller.endY = scrollY;
      scroller.y += (scrollY - scroller.y) * scroller.ease;

      if (Math.abs(scrollY - scroller.y) < 0.05 || resized) {
        scroller.y = scrollY;
        scroller.scrollRequest = 0;
      }

      TweenMax.set(scroller.target, {
        y: -scroller.y,
        onComplete: function onComplete() {//-----Spy scrollTop and elements of page
          //your code here...
        }
      });
      requestId = scroller.scrollRequest > 0 ? requestAnimationFrame(scrollUpdate) : null; //+++++++++++++++++++++++++++++++++++++++++++++++++
      // Custom Functions
      //+++++++++++++++++++++++++++++++++++++++++++++++++

      var scrolled = scroller.y,
          topSpacing = window.innerWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin 
      //----------------------------------------------------------------------------------
      //--------------------------------- Scrollspy Animate -------------------------------	
      //----------------------------------------------------------------------------------   
      // Parallax 
      //-------------------------------------	

      $('.uix-scrollspy-animate--parallax__wrapper').each(function () {
        var $wrapper = $(this);
        var $target = $wrapper.find('.uix-scrollspy-animate--parallax');
        var rect = $target[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($wrapper.data('scrollspy-speed')); //

        $wrapper.css({
          'overflow': 'hidden',
          'height': rect.height - rect.height * 0.3
        });
        $target.css({
          'margin-top': -rect.height * 0.15
        }); //

        TweenMax.set($wrapper, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * speed) + ')',
            'transition': 'none'
          }
        });
        TweenMax.set($target, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * (speed / 2)) + ')',
            'transition': 'none'
          }
        });
      }); // Transparency
      //-------------------------------------	

      $('.uix-scrollspy-animate--transparency').each(function () {
        var $this = $(this);
        var rect = $this[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($this.data('scrollspy-speed'));
        var scale = (0 - spyTop * speed) / rect.height,
            elOpacity = scale;
        TweenMax.set($this, {
          alpha: $this.data('scrollspy-reverse') ? 1 - elOpacity : elOpacity
        });
      }); //----------------------------------------------------------------------------------
      //--------------------------------- Scrolling Progress -------------------------------	
      //----------------------------------------------------------------------------------   

      var scrollDistance = $(scroller.target).height(),
          visibleAreaDistance = windowHeight,
          scrollPercent = scrolled / (scrollDistance - visibleAreaDistance); //

      console.log('Body progress: ' + scrollPercent);
      var progressBlobs = scrollPercent * 1; // slower (= <) or faster and/or change height of 'scrollDistance'

      var scrollDir = scrolled > lastScrollTop ? 'down' : 'up';
      TweenMax.to(tlAction, 1, {
        progress: progressBlobs,
        ease: Sine.easeOut
      }); //----------------------------------------------------------------------------------
      //---------------------- SCROLLING PROGRESS HELPER ----------------------------------	
      //----------------------------------------------------------------------------------   

      var triggerViewport = 0.5; //Scene 2 progress
      //-----------------

      var scene2_height = $('#app-scene-2').outerHeight(true),
          // do not use .height()
      scene2_spyTop = $('#app-scene-2')[0].getBoundingClientRect().top;
      var scene2_scrollPercent = parseFloat(scene2_spyTop / scene2_height) - triggerViewport;

      if (scene2_scrollPercent <= 0 && scene2_scrollPercent >= -1) {
        console.log('Scene 2 progress: ' + Math.abs(scene2_scrollPercent));
        scene2_progress = Math.abs(scene2_scrollPercent);
      }

      TweenMax.to(scene2Action, 1, {
        progress: scene2_progress
      }); //Scene 3 progress
      //-----------------

      var scene3_height = $('#app-scene-3').outerHeight(true),
          // do not use .height()
      scene3_spyTop = $('#app-scene-3')[0].getBoundingClientRect().top;
      var scene3_scrollPercent = parseFloat(scene3_spyTop / scene3_height) - triggerViewport;

      if (scene3_scrollPercent <= 0 && scene3_scrollPercent >= -1) {
        console.log('Scene 3 progress: ' + Math.abs(scene3_scrollPercent));
        scene3_progress = Math.abs(scene3_scrollPercent);
      }

      TweenMax.to(scene3Action, 1, {
        progress: scene3_progress
      }); //----------------------------------------------------------------------------------
      //---------------------------------------------------------------------------------	
      //----------------------------------------------------------------------------------  
      //

      lastScrollTop = scrolled;
    } //end scrollUpdate()

  };

  module.components.pageLoaded.push(module.SMOOTH_SCROLLING_PAGE.pageLoaded);
  return function SMOOTH_SCROLLING_PAGE() {
    smooth_scrolling_page_js_classCallCheck(this, SMOOTH_SCROLLING_PAGE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/sticky-elements/scss/_style.scss
var sticky_elements_scss_style = __webpack_require__(65);

// CONCATENATED MODULE: ./src/components/sticky-elements/js/index.js
function sticky_elements_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function sticky_elements_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { sticky_elements_js_typeof = function _typeof(obj) { return typeof obj; }; } else { sticky_elements_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return sticky_elements_js_typeof(obj); }

/* 
 *************************************
 *  <!-- Sticky Elements -->
 *************************************
 */


var STICKY_EL = function (module, $, window, document) {
  if (window.STICKY_EL === null) return false;
  module.STICKY_EL = module.STICKY_EL || {};
  module.STICKY_EL.version = '0.0.7';

  module.STICKY_EL.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var topSpacing = windowWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin
    //prepend a placeholder

    $('.js-uix-sticky-el').each(function () {
      var $el = $(this),
          elHeight = $el.outerHeight(true),
          //with margin
      elClass = $el.attr('class').replace('js-uix-sticky-el', ''),
          tempID = 'sticky-' + UixGUID.create();
      $el.attr('data-sticky-id', tempID);

      if (!$el.hasClass('is-placeholder')) {
        $('<div class="' + elClass + ' is-placeholder"></div>').css({
          'height': elHeight + 'px',
          'width': '100%',
          'display': 'none',
          'visibility': 'hidden'
        }).attr('data-sticky-id', tempID).insertBefore($el);
      }
    }); //  Initialize

    stickyInit(windowWidth, windowHeight);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight; // Do stuff here

        stickyInit(windowWidth, windowHeight);
      }
    });
    /*
     * Initialize Sticky Elements settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function stickyInit(w, h) {
      if (w > 768) {
        $(window).off('scroll.STICKY_EL touchmove.STICKY_EL');
        $('.js-uix-sticky-el').each(function () {
          var $el = $(this),
              elTop = $el.offset().top,
              oWidth = $el.width(),
              clsID = $el.data('sticky-id'),
              $ph = $('[data-sticky-id="' + clsID + '"].is-placeholder'); // Please do not use scroll's off method in each

          $window.on('scroll.STICKY_EL touchmove.STICKY_EL', function () {
            var scrolled = $(this).scrollTop(),
                spyTop = parseFloat(scrolled + window.innerHeight); //------

            if (parseFloat(scrolled + topSpacing) > elTop) {
              $el.addClass('is-active').css({
                'width': oWidth + 'px',
                'top': topSpacing + 'px'
              });
              $ph.css('display', 'block');
            } else {
              $el.removeClass('is-active').css({
                'top': 0
              });
              $ph.css('display', 'none');
            } //------


            if (sticky_elements_js_typeof($el.data('stop-trigger')) != ( true ? "undefined" : undefined) && $($el.data('stop-trigger')).length > 0) {
              var diff = sticky_elements_js_typeof($el.data('stop-trigger-diff')) != ( true ? "undefined" : undefined) && $el.data('stop-trigger-diff').length > 0 ? UixMath.evaluate($el.data('stop-trigger-diff').replace(/\s/g, '').replace(/\%\h/g, windowHeight).replace(/\%\w/g, windowWidth)) : 0,
                  targetTop = $($el.data('stop-trigger')).offset().top - diff; //Detecting when user scrolls to bottom of div

              if (spyTop >= targetTop) {
                $el.css({
                  'top': parseFloat(topSpacing - (spyTop - targetTop)) + 'px'
                });
              } else {
                if ($el.length > 0 && $el.position().top < topSpacing) {
                  $el.css({
                    'top': topSpacing + 'px'
                  });
                }
              }
            }
          }); //endif scroll.STICKY_EL touchmove.STICKY_EL
        }); //endif $( '.js-uix-sticky-el' )
      } else {
        $('.js-uix-sticky-el').removeClass('is-active');
        $('[data-sticky-id].is-placeholder').css('display', 'none');
      } // endif w > 768

    }
  };

  module.components.pageLoaded.push(module.STICKY_EL.pageLoaded);
  return function STICKY_EL() {
    sticky_elements_js_classCallCheck(this, STICKY_EL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/svg-map/scss/_style.scss
var svg_map_scss_style = __webpack_require__(8);

// CONCATENATED MODULE: ./src/components/svg-map/js/china.js
function china_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- SVG Map (China) -->
 *************************************
 */


var SVG_MAP_CHINA = function (module, $, window, document) {
  if (window.SVG_MAP_CHINA === null) return false;
  module.SVG_MAP_CHINA = module.SVG_MAP_CHINA || {};
  module.SVG_MAP_CHINA.version = '0.0.2';

  module.SVG_MAP_CHINA.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--china');
    $(document).off('click.SVG_MAP_CHINA').on('click.SVG_MAP_CHINA', '.uix-svgmap--china__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
          goText = $(this).text();
      var svgCurName = '',
          svgNameIndex = 0;
      $('.uix-svgmap--china .uix-svgmap--china__name').each(function () {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          return false;
        }
      });
      svgNameIndex = $('.uix-svgmap--china .uix-svgmap--china__name[data-title="' + svgCurName + '"]').index(); //Hide all elements

      svgMapRestore(1); //Display current element

      svgMapActive(svgNameIndex, goText);
    }); //Restore all elements
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });

    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('circle').css({
        'r': 6,
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--china__name').each(function () {
        $(this).css({
          'transform': 'translate(0,15px)',
          'z-index': 1,
          'opacity': alpha
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--china__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }

    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('circle').eq(index).css({
          'r': 15,
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--china__name').eq(index).css({
          'transform': 'translate(0,25px)',
          'z-index': 2,
          'opacity': 1
        }).text(text);
        $(this).find('.uix-svgmap--china__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };

  module.components.documentReady.push(module.SVG_MAP_CHINA.documentReady);
  return function SVG_MAP_CHINA() {
    china_classCallCheck(this, SVG_MAP_CHINA);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/svg-map/js/world.js
function world_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- SVG Map (World) -->
 *************************************
 */


var SVG_MAP_WORLD = function (module, $, window, document) {
  if (window.SVG_MAP_WORLD === null) return false;
  module.SVG_MAP_WORLD = module.SVG_MAP_WORLD || {};
  module.SVG_MAP_WORLD.version = '0.0.2';

  module.SVG_MAP_WORLD.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--world');
    $(document).off('click.SVG_MAP_WORLD').on('click.SVG_MAP_WORLD', '.uix-svgmap--world__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
          goText = $(this).text();
      var svgCurName = '',
          svgNameIndex = 0;
      $('.uix-svgmap--world .uix-svgmap--world__name').each(function (index) {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          svgNameIndex = index;
          return false;
        }
      }); //Hide all elements

      svgMapRestore(1); //Display current element

      svgMapActive(svgNameIndex, goText);
    }); //Restore all elements
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });

    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('path').css({
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--world__name').each(function () {
        $(this).css({
          'z-index': 1,
          'opacity': alpha,
          'font-size': '3px'
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--world__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }

    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('path').eq(index).css({
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--world__name').eq(index).css({
          'z-index': 2,
          'opacity': 1,
          'font-size': '10px'
        }).text(text);
        $(this).find('.uix-svgmap--world__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };

  module.components.documentReady.push(module.SVG_MAP_WORLD.documentReady);
  return function SVG_MAP_WORLD() {
    world_classCallCheck(this, SVG_MAP_WORLD);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/svg-mask-slider/scss/_style.scss
var svg_mask_slider_scss_style = __webpack_require__(66);

// CONCATENATED MODULE: ./src/components/svg-mask-slider/js/index.js
function svg_mask_slider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function svg_mask_slider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { svg_mask_slider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { svg_mask_slider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return svg_mask_slider_js_typeof(obj); }

/* 
 *************************************
 * <!-- SVG Mask Slider -->
 *************************************
 */


var SVG_MASK_SLIDER = function (module, $, window, document) {
  if (window.SVG_MASK_SLIDER === null) return false;
  module.SVG_MASK_SLIDER = module.SVG_MASK_SLIDER || {};
  module.SVG_MASK_SLIDER.version = '0.0.1';

  module.SVG_MASK_SLIDER.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animDelay = 0;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-svgMask-slider');
    var svgAnimating = false; //

    sliderInit(false);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        sliderInit(true);
      }
    });
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-svgMask-slider__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if (svg_mask_slider_js_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now'),
              dataSpeed = $this.data('speed');
          if (svg_mask_slider_js_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-svgMask-slider__pagination';
          if (svg_mask_slider_js_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-svgMask-slider__arrows';
          if (svg_mask_slider_js_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
          if (svg_mask_slider_js_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if (svg_mask_slider_js_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = 'p.count em.count';
          if (svg_mask_slider_js_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = 'p.count em.current'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if (svg_mask_slider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
          if (svg_mask_slider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
          if (svg_mask_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the animation speed
          //-------------------------------------	

          if (svg_mask_slider_js_typeof(dataSpeed) != ( true ? "undefined" : undefined) && dataSpeed != false) {
            animSpeed = dataSpeed;
          } //Get the duration of the animation
          //-------------------------------------	


          animDelay = animSpeed; //Get timeline elements
          //-------------------------------------	

          var txtTimeline = new TimelineMax({
            delay: 0
          });
          var txtMaskTimeline = new TimelineMax({
            delay: 0
          });
          txtTimeline.to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 0
          }).to($items.find('svg image'), 0.2, {
            scale: 1.1
          }, '-=0.1').to($this.find('.uix-svgMask-slider__inner'), 0.9, {
            ease: Circ.easeOut,
            scale: 0.85
          }, '-=0.2').to($this.find('.uix-svgMask-slider__inner'), 0.75, {
            ease: Elastic.easeOut.config(4, 1.5),
            scale: 1
          }).pause();
          txtMaskTimeline.to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: 0
            }
          }).to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 1
          }, "-=0.1").to($items.find('svg image'), 0.2, {
            scale: 1
          }, '-=0.1').to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: '-100vw'
            }
          }); //Initialize the properties of each Item
          //-------------------------------------	

          $items.each(function (index) {
            var _id = UixGUID.create();

            var _item = $(this);

            _item.find('clipPath').attr('id', _id + '-img');

            _item.find('image').attr('clip-path', 'url(#' + _id + '-img)');

            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          }); //Initialize the first item container
          //-------------------------------------		

          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay); //

          var imgURL = $first.find('img').attr('src');

          if (svg_mask_slider_js_typeof(imgURL) != ( true ? "undefined" : undefined)) {
            var img = new Image();

            img.onload = function () {
              $this.css('height', $this.width() * (this.height / this.width) + 'px');
              nativeItemW = this.width;
              nativeItemH = this.height; //Initialize all the items to the stage

              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, txtTimeline, txtMaskTimeline);
            };

            img.src = imgURL;
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-svgMask-slider__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }
    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {Function} tl1                  - Timeline animation of text field.
     * @param  {Function} tl2                  - Timeline animation of text mask field.
    * @return {Void}
    */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, tl1, tl2) {
      var $this = slider,
          $items = $this.find('.uix-svgMask-slider__item'),
          $first = $items.first(),
          itemTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-svgMask-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-svgMask-slider__arrows--prev"></a><a href="#" class="uix-svgMask-slider__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      } //Pagination dots 
      //-------------------------------------	


      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault();
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Text animation from timeline
          tl1.restart();
          setTimeout(function () {
            tl2.restart();
          }, 1500); //Determine the direction

          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-svgMask-slider__arrows--prev'),
          _next = $(arrowsID).find('.uix-svgMask-slider__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault();
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animDelay).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //Text animation from timeline

        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault();
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(this).attr('aria-disabled', 'true');
        $(this).delay(animDelay).queue(function (next) {
          $(this).attr('aria-disabled', 'false');
          next();
        }); //Text animation from timeline

        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

        clearInterval($this[0].animatedSlides);
      }); //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragDropTrigger = $items; //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragDropTrigger.css('cursor', draggableCursor); //Mouse event

      $dragDropTrigger.on('mousedown.SVG_MASK_SLIDER touchstart.SVG_MASK_SLIDER', function (e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.originalEvent.touches;
        $(this).addClass('is-dragging');

        if (touches && touches.length) {
          $(this).data('origin_mouse_x', parseInt(touches[0].pageX));
          $(this).data('origin_mouse_y', parseInt(touches[0].pageY));
        } else {
          if (draggable) {
            $(this).data('origin_mouse_x', parseInt(e.pageX));
            $(this).data('origin_mouse_y', parseInt(e.pageY));
          }
        }

        $dragDropTrigger.on('mouseup.SVG_MASK_SLIDER touchmove.SVG_MASK_SLIDER', function (e) {
          $(this).removeClass('is-dragging');
          var touches = e.originalEvent.touches,
              origin_mouse_x = $(this).data('origin_mouse_x'),
              origin_mouse_y = $(this).data('origin_mouse_y');

          if (touches && touches.length) {
            var deltaX = origin_mouse_x - touches[0].pageX,
                deltaY = origin_mouse_y - touches[0].pageY; //--- left

            if (deltaX >= 50) {
              if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
            } //--- right


            if (deltaX <= -50) {
              if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
            } //--- up


            if (deltaY >= 50) {} //--- down


            if (deltaY <= -50) {}

            if (Math.abs(deltaX) >= 50 || Math.abs(deltaY) >= 50) {
              $dragDropTrigger.off('touchmove.SVG_MASK_SLIDER');
            }
          } else {
            if (draggable) {
              //right
              if (e.pageX > origin_mouse_x) {
                if ($items.filter('.is-active').index() > 0) _prev.trigger('click');
              } //left


              if (e.pageX < origin_mouse_x) {
                if ($items.filter('.is-active').index() < itemTotal - 1) _next.trigger('click');
              } //down


              if (e.pageY > origin_mouse_y) {} //up


              if (e.pageY < origin_mouse_y) {}

              $dragDropTrigger.off('mouseup.SVG_MASK_SLIDER');
            }
          }
        }); //end: mouseup.SVG_MASK_SLIDER touchmove.SVG_MASK_SLIDER
      }); // end: mousedown.SVG_MASK_SLIDER touchstart.SVG_MASK_SLIDER
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-svgMask-slider__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-svgMask-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //SVG Animation
      //-------------------------------------

      if (!svgAnimating) {
        //don't animate if already animating
        svgAnimating = true;
        var path1 = '1 0.5 1 540.5 1 1080.5 0 1080.5 4 1080.5 4 540.5 4 0.5 0 0.5 1 0.5',
            path2 = '0.5 0.5 0.5 540.5 0.5 1080.5 1519.5 1080.5 1531.5 1080.5 1066.5 525.5 601.5 1.5 589.5 1.5 0.5 0.5',
            path3 = '0.5 0.5 0.5 540.5 0.5 1080.5 960.5 1080.5 1920.5 1080.5 1920.5 540.5 1920.5 0.5 960.5 0.5 0.5 0.5';

        if (dir == 'next') {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(180deg)'
          });
        } else {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(0)'
          });
        } //----
        //@required: MorphSVGPlugin

        /*
        TweenMax.set( $current.find('polygon')[0], {
        	attr: {
        			  points: path1
        		  },
        	onComplete: function() {
        			TweenMax.to( this.target, animSpeed/1000, {
        			morphSVG: path2,
        			delay: 0,
        			ease: Power2.easeOut,
        			onComplete: function() {
        					TweenMax.to( this.target, animSpeed/1000, {
        					morphSVG: path3,
        					delay: 0,
        					ease: Power2.easeInOut,
        					onComplete: function() {
        						svgAnimating = false;
        					}
        				});	
        					}
        		});	
        		}
        });
        */


        TweenMax.set($current.find('polygon')[0], {
          attr: {
            points: path1
          },
          onComplete: function onComplete() {
            anime.timeline({
              loop: false
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path2
              }],
              duration: animSpeed,
              easing: "easeOutExpo"
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path3
              }],
              duration: animSpeed,
              easing: "easeOutExpo",
              complete: function complete() {
                svgAnimating = false;
              }
            });
          }
        });
      } //endif svgAnimating
      //Display counter
      //-------------------------------------


      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); //Reset the default height of item
      //-------------------------------------	

      itemDefaultInit(slider, $current);
    }
    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function itemDefaultInit(slider, currentLlement) {
      //
      var imgURL = currentLlement.find('img').attr('src');

      if (svg_mask_slider_js_typeof(imgURL) != ( true ? "undefined" : undefined)) {
        var img = new Image();

        img.onload = function () {
          slider.css('height', currentLlement.closest('.uix-svgMask-slider__outline').width() * (this.height / this.width) + 'px');
        };

        img.src = imgURL;
      }
    }
  };

  module.components.pageLoaded.push(module.SVG_MASK_SLIDER.pageLoaded);
  return function SVG_MASK_SLIDER() {
    svg_mask_slider_js_classCallCheck(this, SVG_MASK_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/swiper/js/third-party/swiper-bundle.js
var swiper_bundle = __webpack_require__(1);
var swiper_bundle_default = /*#__PURE__*/__webpack_require__.n(swiper_bundle);

// EXTERNAL MODULE: ./src/components/swiper/scss/_style.scss
var swiper_scss_style = __webpack_require__(67);

// CONCATENATED MODULE: ./src/components/swiper/js/index.js
function swiper_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function swiper_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { swiper_js_typeof = function _typeof(obj) { return typeof obj; }; } else { swiper_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return swiper_js_typeof(obj); }

/* 
 *************************************
 * <!-- Swiper -->
 *************************************
 */



var SWIPER = function (module, $, window, document) {
  if (window.SWIPER === null) return false;
  module.SWIPER = module.SWIPER || {};
  module.SWIPER.version = '0.0.5';

  module.SWIPER.documentReady = function ($) {
    $('.uix-swiper').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if (swiper_js_typeof(actived) === ( true ? "undefined" : undefined)) {
        if ($el.find('#app-slider1').length > 0) {
          var swiper2 = new swiper_bundle_default.a('#app-slider2', {
            slidesPerView: 5,
            spaceBetween: 10,
            allowTouchMove: false
          });
          var swiper = new swiper_bundle_default.a('#app-slider1', {
            slidesPerView: 1,
            spaceBetween: 10,
            speed: 1000,
            // init: false,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            breakpoints: {
              640: {
                slidesPerView: 2,
                spaceBetween: 20
              },
              768: {
                slidesPerView: 4,
                spaceBetween: 40
              },
              1024: {
                slidesPerView: 5,
                spaceBetween: 50
              }
            }
          }); //Sync three swiper slider

          swiper.on('slideChange', function () {
            var index = this.activeIndex;
            swiper2.slideTo(index, 1000, false);
          });
        } //Swiper custom slides transform effect (Parallax effect)
        //------------------------------------------


        if ($el.find('#app-slider3').length > 0) {
          var interleaveOffset = 0.5;
          var swiper3 = new swiper_bundle_default.a('#app-slider3', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 1000,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              progress: function progress(e) {
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  var slideProgress = thisSwiper.slides[i].progress;
                  var innerOffset = thisSwiper.width * interleaveOffset;
                  var innerTranslate = slideProgress * innerOffset;
                  thisSwiper.slides[i].querySelector(".slide-inner").style.transform = "translate3d(" + innerTranslate + "px, 0, 0)"; //console.log( e.passedParams );
                }
              },
              touchStart: function touchStart(e) {
                var passedParams = e.passedParams;
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  thisSwiper.slides[i].style.transition = "";
                }
              },
              setTransition: function setTransition(e) {
                var passedParams = e.passedParams;
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  thisSwiper.slides[i].style.transition = passedParams.speed + "ms";
                  thisSwiper.slides[i].querySelector(".slide-inner").style.transition = passedParams.speed + "ms";
                }
              }
            }
          }); //AutoPlay

          swiper3.autoplay.start(); //swiper3.autoplay.stop();			
        } //Swiper custom slides transform effect (Scale Effect without left/right swipe)
        //------------------------------------------


        if ($el.find('#app-slider4').length > 0) {
          var swiper4 = new swiper_bundle_default.a('#app-slider4', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 1000,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            virtualTranslate: true,

            /* Required */
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              progress: function progress(translate) {
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  var slideProgress = thisSwiper.slides[i].progress;
                  console.log(translate.params);
                }
              },
              touchStart: function touchStart(translate) {
                var params = translate.params;
                var thisSwiper = this;
              },
              setTransition: function setTransition(translate) {
                var params = translate.params;
                var thisSwiper = this;
              },
              setTranslate: function setTranslate(translate) {
                var params = translate.params;
                var thisSwiper = this;
                /*
                A weird way to find this out but I've found no other.
                Checks if the progress on the active slide is 1 or -1 which happens when swiper navigates to next/previous slide on click and keybord navigation.
                If not then the slider is being dragged, so we get the right index by finding the startTranslate from touchEvents in array of transitions the swiper snaps to.
                The startTranslate doesn't exist on initial load so we use the initialSlide index instead.
                */

                var getActiveIndexBeforeTransitionStart = function getActiveIndexBeforeTransitionStart(curSwiper, curSlides) {
                  var isDragging = !Math.abs(curSlides[curSwiper.activeIndex].progress === 1);

                  if (isDragging) {
                    return curSwiper.slidesGrid.indexOf(-curSwiper.touchEventsData.startTranslate || curSwiper.params.initialSlide);
                  } else {
                    return curSwiper.activeIndex;
                  }
                };

                var getDirection = function getDirection(animationProgress) {
                  if (animationProgress === 0) {
                    return "NONE";
                  } else if (animationProgress > 0) {
                    return "NEXT";
                  } else {
                    return "BACK";
                  }
                };

                var durationInSeconds = params.speed / 1000; // convert slides object to plain array

                var slides = thisSwiper.slides; // get the index of the slide active before transition start (activeIndex changes halfway when dragging)

                var originIndex = getActiveIndexBeforeTransitionStart(thisSwiper, slides); // get information about animation progress from the active slide - the active slide's value is always -1 to 1.

                /* 
                every slide has a progress attribute equal to the "distance" from the current active index.
                */

                var animationProgress = slides[originIndex].progress; // you can then get the drag direction like so:

                var direction = getDirection(animationProgress); // console.log(direction);
                // do magic with each slide

                slides.map(function (perSlide, index) {
                  // to put the slides behind each other we have to set their CSS translate accordingly since by default they are arranged in line.
                  var offset = perSlide.swiperSlideOffset;
                  var x = -offset;
                  if (!thisSwiper.params.virtualTranslate) x -= thisSwiper.translate;
                  var y = 0;

                  if (!thisSwiper.isHorizontal()) {
                    y = x;
                    x = 0;
                  }

                  TweenMax.set(perSlide, {
                    x: x,
                    y: y
                  }); // do our animation stuff!

                  var clip = function clip(val, min, max) {
                    return Math.max(min, Math.min(val, max));
                  };

                  var ZOOM_FACTOR = 0.05;
                  var opacity = Math.max(1 - Math.abs(perSlide.progress), 0);
                  var clippedProgress = clip(perSlide.progress, -1, 1);
                  var scale = 1 - ZOOM_FACTOR * clippedProgress; // you can do your CSS animation instead of using tweening.

                  TweenMax.to(perSlide, durationInSeconds, {
                    scale: scale,
                    opacity: opacity
                  });
                });
              }
            }
          }); //AutoPlay

          swiper4.autoplay.start(); //swiper4.autoplay.stop();			
        } //Centered Slides
        //------------------------------------------	


        if ($el.find('#app-slider5').length > 0) {
          var swiper5 = new swiper_bundle_default.a('#app-slider5', {
            slidesPerView: 3,
            spaceBetween: 30,
            loop: true,
            speed: 1000,
            centeredSlides: true,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            }
          });
        } //Display half on both sides
        //------------------------------------------		


        if ($el.find('#app-slider6').length > 0) {
          var swiper6 = new swiper_bundle_default.a('#app-slider6', {
            slidesPerView: 'auto',
            //Number of slides per view, and it must be "auto"!
            spaceBetween: 30,
            loop: true,
            speed: 1000,
            centeredSlides: true,
            //If true, then active slide will be centered, not always on the left side.
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            }
          });
        } //Custom Progress Bar
        //------------------------------------------


        if ($el.find('#app-slider7').length > 0) {
          var cusProgressBar = function cusProgressBar(speed, length, curIndex) {
            TweenMax.set('#app-slider7__progress', {
              width: 0,
              onComplete: function onComplete() {
                TweenMax.to('#app-slider7__progress', speed / 1000, {
                  width: '100%'
                });
              }
            });
            TweenMax.set('#app-slider7__progress2', {
              width: 100 / length * curIndex + '%',
              onComplete: function onComplete() {
                TweenMax.to('#app-slider7__progress2', speed / 1000, {
                  width: 100 / length * (curIndex + 1) + '%'
                });
              }
            });
          };

          var swiper7 = new swiper_bundle_default.a('#app-slider7', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 3500,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              init: function init(e) {
                var thisSwiper = this;
                console.log('current index: ' + thisSwiper.activeIndex);
                cusProgressBar(e.passedParams.speed, thisSwiper.slides.length, thisSwiper.activeIndex);
              },
              slideChange: function slideChange(e) {
                var thisSwiper = this;
                console.log('current index: ' + thisSwiper.activeIndex);
                cusProgressBar(e.passedParams.speed, thisSwiper.slides.length, thisSwiper.activeIndex);
              }
            }
          });
        } //------------------------------------------
        //Prevents front-end javascripts that are activated in the background to repeat loading.


        $el.data('activated', 1);
      } //endif actived

    });
  };

  module.components.documentReady.push(module.SWIPER.documentReady);
  return function SWIPER() {
    swiper_js_classCallCheck(this, SWIPER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/extensions/ShaderRuntime.custom.js
var defaultThreeUniforms = ['normalMatrix', 'viewMatrix', 'projectionMatrix', 'position', 'normal', 'modelViewMatrix', 'uv', 'uv2', 'modelMatrix'];

function ShaderRuntime() {}

ShaderRuntime.prototype = {
  mainCamera: null,
  cubeCameras: {},
  reserved: {
    time: null,
    cameraPosition: null
  },
  umap: {
    "float": {
      type: 'f',
      value: 0
    },
    "int": {
      type: 'i',
      value: 0
    },
    vec2: {
      type: 'v2',
      value: function value() {
        return new THREE.Vector2();
      }
    },
    vec3: {
      type: 'v3',
      value: function value() {
        return new THREE.Vector3();
      }
    },
    vec4: {
      type: 'v4',
      value: function value() {
        return new THREE.Vector4();
      }
    },
    samplerCube: {
      type: 't'
    },
    sampler2D: {
      type: 't'
    }
  },
  getUmap: function getUmap(type) {
    var value = this.umap[type].value;
    return typeof value === 'function' ? value() : value;
  },
  load: function load(sourceOrSources, callback) {
    var _this = this;

    var sources = sourceOrSources,
        onlyOneSource = typeof sourceOrSources === 'string';

    if (onlyOneSource) {
      sources = [sourceOrSources];
    }

    var loadedShaders = new Array(sources.length),
        itemsLoaded = 0;

    var loadSource = function loadSource(index, source) {
      var loader = new THREE.FileLoader();
      loader.load(source, function (json) {
        var parsed;

        try {
          parsed = JSON.parse(json);
          delete parsed.id; // Errors if passed to rawshadermaterial :(
        } catch (e) {
          throw new Error('Could not parse shader' + source + '! Please verify the URL is correct.');
        }

        _this.add(parsed.name, parsed);

        loadedShaders[index] = parsed;

        if (++itemsLoaded === sources.length) {
          callback(onlyOneSource ? loadedShaders[0] : loadedShaders);
        }
      });
    };

    for (var x = 0; x < sources.length; x++) {
      loadSource(x, sources[x]);
    }
  },
  //Load json code directly
  loadJSON: function load(sourceOrSources, callback) {
    var _this = this;

    var sources = sourceOrSources,
        onlyOneSource = typeof sourceOrSources === 'string';

    if (onlyOneSource) {
      sources = [sourceOrSources];
    }

    var loadedShaders = new Array(sources.length),
        itemsLoaded = 0;

    var loadJSONCode = function loadJSONCode(index, source) {
      var parsed;
      parsed = source;
      delete parsed.id; // Errors if passed to rawshadermaterial :(

      _this.add(parsed.name, parsed);

      loadedShaders[index] = parsed;

      if (++itemsLoaded === sources.length) {
        callback(onlyOneSource ? loadedShaders[0] : loadedShaders);
      }
    };

    for (var x = 0; x < sources.length; x++) {
      loadJSONCode(x, sources[x]);
    }
  },
  registerCamera: function registerCamera(camera) {
    if (!(camera instanceof THREE.Camera)) {
      throw new Error('Cannot register a non-camera as a camera!');
    }

    this.mainCamera = camera;
  },
  registerCubeCamera: function registerCubeCamera(name, camera) {
    if (!camera.renderTarget) {
      throw new Error('Cannot register a non-camera as a camera!');
    }

    this.cubeCameras[name] = camera;
  },
  unregisterCamera: function unregisterCamera(name) {
    if (name in this.cubeCameras) {
      delete this.cubeCameras[name];
    } else if (name === this.mainCamera) {
      delete this.mainCamera;
    } else {
      throw new Error('You never registered camera ' + name);
    }
  },
  updateSource: function updateSource(identifier, config, findBy) {
    findBy = findBy || 'name';

    if (!this.shaderTypes[identifier]) {
      throw new Error('Runtime Error: Cannot update shader ' + identifier + ' because it has not been added.');
    }

    var newShaderData = this.add(identifier, config),
        shader,
        x;

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader[findBy] === identifier) {
        extend(shader.material, omit(newShaderData, 'id'));
        shader.material.needsUpdate = true;
      }
    }
  },
  renameShader: function renameShader(oldName, newName) {
    var x, shader;

    if (!(oldName in this.shaderTypes)) {
      throw new Error('Could not rename shader ' + oldName + ' to ' + newName + '. It does not exist.');
    }

    this.shaderTypes[newName] = this.shaderTypes[oldName];
    delete this.shaderTypes[oldName];

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader.name === oldName) {
        shader.name = newName;
      }
    }
  },
  get: function get(identifier) {
    var shaderType = this.shaderTypes[identifier];

    if (!shaderType.initted) {
      this.create(identifier);
    }

    return shaderType.material;
  },
  add: function add(shaderName, config) {
    var newData = clone(config),
        uniform;
    newData.fragmentShader = config.fragment;
    newData.vertexShader = config.vertex;
    delete newData.fragment;
    delete newData.vertex;

    for (var uniformName in newData.uniforms) {
      uniform = newData.uniforms[uniformName];

      if (uniform.value === null) {
        newData.uniforms[uniformName].value = this.getUmap(uniform.glslType);
      }
    }

    if (shaderName in this.shaderTypes) {
      // maybe not needed? too sleepy, need document
      extend(this.shaderTypes[shaderName], newData);
    } else {
      this.shaderTypes[shaderName] = newData;
    }

    return newData;
  },
  create: function create(identifier) {
    var shaderType = this.shaderTypes[identifier];
    var keys = Object.keys(shaderType); // Three's shadermaterial id is not assignable, so filter it out

    var withoutId = {};

    for (var i = 0; i < keys.length; i++) {
      if (keys[i] !== 'id') {
        withoutId[keys[i]] = shaderType[keys[i]];
      }
    }

    shaderType.material = new THREE.RawShaderMaterial(withoutId);
    this.runningShaders.push(shaderType);
    shaderType.init && shaderType.init(shaderType.material);
    shaderType.material.needsUpdate = true;
    shaderType.initted = true;
    return shaderType.material;
  },
  updateRuntime: function updateRuntime(identifier, data, findBy) {
    findBy = findBy || 'name';
    var shader, x, uniformName, uniform; // This loop does not appear to be a slowdown culprit

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader[findBy] === identifier) {
        for (uniformName in data.uniforms) {
          if (uniformName in this.reserved) {
            continue;
          }

          if (uniformName in shader.material.uniforms) {
            uniform = data.uniforms[uniformName]; // this is nasty, since the shader serializes
            // CubeCamera model to string. Maybe not update it at
            // all?

            if (uniform.type === 't' && typeof uniform.value === 'string') {
              uniform.value = this.cubeCameras[uniform.value].renderTarget;
            }

            shader.material.uniforms[uniformName].value = data.uniforms[uniformName].value;
          }
        }
      }
    }
  },
  // Update global shader uniform values
  updateShaders: function updateShaders(time, obj) {
    var shader, x;
    obj = obj || {};

    for (x = 0; shader = this.runningShaders[x++];) {
      for (var uniform in obj.uniforms) {
        if (uniform in shader.material.uniforms) {
          shader.material.uniforms[uniform].value = obj.uniforms[uniform];
        }
      }

      if ('cameraPosition' in shader.material.uniforms && this.mainCamera) {
        shader.material.uniforms.cameraPosition.value = this.mainCamera.position.clone();
      }

      if ('viewMatrix' in shader.material.uniforms && this.mainCamera) {
        shader.material.uniforms.viewMatrix.value = this.mainCamera.matrixWorldInverse;
      }

      if ('time' in shader.material.uniforms) {
        shader.material.uniforms.time.value = time;
      }
    }
  },
  shaderTypes: {},
  runningShaders: []
}; // Convenience methods so we don't have to include underscore

function extend() {
  var length = arguments.length,
      obj = arguments[0];

  if (length < 2) {
    return obj;
  }

  for (var index = 1; index < length; index++) {
    var source = arguments[index],
        keys = Object.keys(source || {}),
        l = keys.length;

    for (var i = 0; i < l; i++) {
      var key = keys[i];
      obj[key] = source[key];
    }
  }

  return obj;
}

function clone(obj) {
  return extend({}, obj);
}

function omit(obj) {
  var cloned = clone(obj),
      x,
      key;

  for (x = 0; key = (_ref = x++ + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);) {
    var _ref;

    delete cloned[key];
  }

  return cloned;
}

/* harmony default export */ var ShaderRuntime_custom = (ShaderRuntime);
// CONCATENATED MODULE: ./src/components/simple-3D-background-three/js/index.js
function simple_3D_background_three_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Background 1 with three.js -->
 *************************************
 */


var THREE_BACKGROUND_THREE = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE === null) return false;
  module.THREE_BACKGROUND_THREE = module.THREE_BACKGROUND_THREE || {};
  module.THREE_BACKGROUND_THREE.version = '0.0.5';

  module.THREE_BACKGROUND_THREE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          light,
          renderer,
          displacementSprite,
          shaderSprite,
          clock = new THREE.Clock(); // controls

      var spriteAnim = false;
      var mouseX = 0,
          mouseY = 0,
          windowHalfX = windowWidth / 2,
          windowHalfY = windowHeight / 2;
      var targetX = 0.0,
          targetY = 0.0,
          angle = 0.0,
          height = 0.0,
          target = new THREE.Vector3(); // Load multiple ShaderFrog shaders

      var runtime = new ShaderRuntime_custom();
      runtime.load([$('#' + rendererCanvasID).data('shader-url')], function (shaders) {
        // Get the Three.js material you can assign to your objects
        var material = runtime.get(shaders[0].name);
        shaderSprite.material = material;
      });

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 100, 2000000);
        camera.position.set(0, 100, 2000);
        runtime.registerCamera(camera); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //Add shader background

        var geometry = new THREE.SphereGeometry(5, 32, 32, 0, Math.PI * 2, 0, Math.PI * 2);
        shaderSprite = new THREE.Mesh(geometry);
        shaderSprite.scale.setScalar(10000);
        shaderSprite.renderDepth = 0;
        scene.add(shaderSprite); // Immediately use the texture for material creation

        var defaultMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          flatShading: true,
          vertexColors: THREE.VertexColors
        });
        displacementSprite = new THREE.Mesh(generateGeometry('sphere', 200), defaultMaterial);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render);
        var objVector = new THREE.Vector3(0, 0.2, 0.1),
            delta = clock.getDelta();

        if (!spriteAnim) {
          displacementSprite.rotation.x += delta * objVector.x;
          displacementSprite.rotation.y += delta * objVector.y;
          displacementSprite.rotation.z += delta * objVector.z;
        } //To set a background color.


        renderer.setClearColor(0x000000); //update shaders

        runtime.updateShaders(clock.getElapsedTime()); // update camera

        targetX = mouseX * .002;
        targetY = mouseY * .002;
        angle += 0.01 * (targetX - angle);
        height += 0.01 * (targetY - height);
        var x = -Math.sin(angle * 1.5) * 35;
        var z = Math.cos(angle * 1.5) * 35;
        var y = 130 * height + 0;
        camera.position.set(x, y, z);
        camera.lookAt(target); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        spriteAnim = true;
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        spriteAnim = false;
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {String} objectType     - String of geometry type identifier.
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(objectType, numObjects) {
        var geometry = new THREE.Geometry();

        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var position = new THREE.Vector3();
          position.x = Math.random() * 10000 - 5000;
          position.y = Math.random() * 6000 - 3000;
          position.z = Math.random() * 8000 - 4000;
          var rotation = new THREE.Euler();
          rotation.x = Math.random() * 2 * Math.PI;
          rotation.y = Math.random() * 2 * Math.PI;
          rotation.z = Math.random() * 2 * Math.PI;
          var scale = new THREE.Vector3();
          scale.x = Math.random() * 200 + 100;
          var geom = void 0;
          var color = new THREE.Color();

          if (objectType == "cube") {
            geom = new THREE.BoxGeometry(1, 1, 1);
            scale.y = Math.random() * 200 + 100;
            scale.z = Math.random() * 200 + 100;
            color.setRGB(0, 0, Math.random() + 0.1);
          } else if (objectType == "sphere") {
            geom = new THREE.IcosahedronGeometry(1, 1);
            scale.y = scale.z = scale.x;
            color.setRGB(0.35, getRandomFloat(0.12, 0.3), 0.2);
          } else if (objectType == "poly") {
            geom = new THREE.CylinderGeometry(3, 6, 3, 5, 1);
            scale.y = Math.random() * 30;
            scale.z = Math.random() * 30;
            color.setRGB(Math.random() + 0.1, 0, 0);
          } // give the geom's vertices a random color, to be displayed


          applyVertexColors(geom, color);
          var object = new THREE.Mesh(geom);
          object.position.copy(position);
          object.rotation.copy(rotation);
          object.scale.copy(scale);
          object.updateMatrix();
          geometry.merge(object.geometry, object.matrix);
        }

        return geometry;
      } //Generate random number between two numbers


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE.documentReady);
  return function THREE_BACKGROUND_THREE() {
    simple_3D_background_three_js_classCallCheck(this, THREE_BACKGROUND_THREE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/shader/fragment-custom.glsl
/* harmony default export */ var fragment_custom = ("#define GLSLIFY 1\nuniform float time;\n\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n    vec2 position = - 1.0 + 2.0 * vUv;\n\n    float a = atan( position.y, position.x );\n    float r = sqrt( dot( position, position ) );\n\n    vec2 uv;\n    uv.x = cos( a ) / r;\n    uv.y = sin( a ) / r;\n    uv /= 10.0;\n    uv += time * 0.05;\n\n    vec3 color = texture2D( texture, uv ).rgb;\n\n    gl_FragColor = vec4( color * r * 1.5, 1.0 );\n\n}");
// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/shader/vertex-custom.glsl
/* harmony default export */ var vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}");
// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/index.js
function simple_3D_background_three2_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Background 2 with three.js -->
 *************************************
 */



var THREE_BACKGROUND_THREE2 = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE2 === null) return false;
  module.THREE_BACKGROUND_THREE2 = module.THREE_BACKGROUND_THREE2 || {};
  module.THREE_BACKGROUND_THREE2.version = '0.0.4';

  module.THREE_BACKGROUND_THREE2.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas2').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas2'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          renderer,
          material,
          displacementSprite,
          clock = new THREE.Clock();
      var mouseVector = new THREE.Vector2();
      var mouseX = 0;
      var mouseY = 0;

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(50, windowWidth / windowHeight, .01, 1000);
        camera.position.set(0, 0, 1.8); //Scene

        scene = new THREE.Scene(); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        material = new THREE.ShaderMaterial({
          uniforms: {
            "time": {
              value: 1.0
            },
            "texture": {
              value: new THREE.TextureLoader().load($('#' + rendererCanvasID).data('filter-texture'))
            }
          },
          fragmentShader: fragment_custom,
          vertexShader: vertex_custom
        }); //if use texture

        material.uniforms.texture.value.wrapS = THREE.RepeatWrapping;
        material.uniforms.texture.value.wrapT = THREE.RepeatWrapping;
        var geometry = new THREE.SphereGeometry(5, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
        displacementSprite = new THREE.Mesh(geometry, material);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(); //To set a background color.

        renderer.setClearColor(0x000000);
        material.uniforms.time.value += delta * 5; //displacementSprite.rotation.y += delta * 0.5 * 1;
        //displacementSprite.rotation.x += delta * 0.5 * -1;
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        var rect = renderer.domElement.getBoundingClientRect();
        displacementSprite.position.z = (event.clientX - rect.left) / rect.width * 4 - 1;
      }

      function avgArr(arr) {
        var total = arr.reduce(function (sum, b) {
          return sum + b;
        });
        return total / arr.length;
      }

      function maxArr(arr) {
        return arr.reduce(function (a, b) {
          return Math.max(a, b);
        });
      }

      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      }

      function round(n, digits) {
        return Number(n.toFixed(digits));
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE2.documentReady);
  return function THREE_BACKGROUND_THREE2() {
    simple_3D_background_three2_js_classCallCheck(this, THREE_BACKGROUND_THREE2);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-background-three3/js/index.js
function simple_3D_background_three3_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Background 3 with three.js -->
 *************************************
 */

var THREE_BACKGROUND_THREE3 = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE3 === null) return false;
  module.THREE_BACKGROUND_THREE3 = module.THREE_BACKGROUND_THREE3 || {};
  module.THREE_BACKGROUND_THREE3.version = '0.0.2';

  module.THREE_BACKGROUND_THREE3.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas3').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas3'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          renderer,
          displacementSprite,
          theta = 0;
      var mouseVector = new THREE.Vector2(),
          sphereTarget = new THREE.Euler(),
          xrad = THREE.Math.degToRad(30),
          yrad = THREE.Math.degToRad(10);

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(50, windowWidth / windowHeight, .01, 1000);
        camera.position.set(0, 0, 1.8); //Scene

        scene = new THREE.Scene(); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        var sphereGeo = new THREE.SphereBufferGeometry(2, 12, 12);
        var sphereMat = new THREE.MeshBasicMaterial({
          color: 0x494949,
          wireframe: true
        });
        displacementSprite = new THREE.Mesh(sphereGeo, sphereMat);
        displacementSprite.position.y = -0.2;
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000);
        lerp(displacementSprite.rotation, 'x', sphereTarget.x);
        lerp(displacementSprite.rotation, 'y', sphereTarget.y); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        // NDC -1 to 1
        var rect = renderer.domElement.getBoundingClientRect();
        mouseVector.x = (event.clientX - rect.left) / rect.width * 2 - 1;
        mouseVector.y = (event.clientY - rect.top) / rect.height * -2 + 1;
        sphereTarget.y = mouseVector.x * xrad;
        sphereTarget.x = -mouseVector.y * yrad;
      } //Calculate the interpolation of two vectors


      function lerp(object, prop, destination) {
        if (object && object[prop] !== destination) {
          object[prop] += (destination - object[prop]) * 0.1;

          if (Math.abs(destination - object[prop]) < 0.001) {
            object[prop] = destination;
          }
        }
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE3.documentReady);
  return function THREE_BACKGROUND_THREE3() {
    simple_3D_background_three3_js_classCallCheck(this, THREE_BACKGROUND_THREE3);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/simple-3D-background/scss/_style.scss
var simple_3D_background_scss_style = __webpack_require__(68);

// CONCATENATED MODULE: ./src/components/simple-3D-background/js/index.js
function simple_3D_background_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_background_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_background_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_background_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_background_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Background -->
 *************************************
 */


var THREE_BACKGROUND = function (module, $, window, document) {
  if (window.THREE_BACKGROUND === null) return false;
  module.THREE_BACKGROUND = module.THREE_BACKGROUND || {};
  module.THREE_BACKGROUND.version = '0.0.3';

  module.THREE_BACKGROUND.documentReady = function ($) {
    //grab each 3dAnimate element and pass it into the animate function along with the config data
    $('[data-3d-animate]').each(function (index, element) {
      var config = $(element).data('3d-animate');

      if (simple_3D_background_js_typeof(config) === ( true ? "undefined" : undefined)) {
        config = false;
      }

      if (config) {
        if (Object.prototype.toString.call(config.offset) == '[object Array]') {
          animate3dMultiElement(config.offset[0], config.offset[1], element, config.reset);
        } else {
          animate3dElement(config.offset, element, config.reset);
        }
      }
    });
    /*
     * Sets an animation for each element
     *
     * @param  {Number} base           - Base offset value.
     * @param  {String} obj            - An HTML element.
     * @param  {Boolean} reset         - Reset block on mouse leave
     * @return {Void}
     */

    function animate3dElement(base, obj, reset) {
      var $el = $(obj),
          w = $el.innerWidth(),
          h = $el.innerHeight(); //			TweenMax.set( $el, {
      //				perspective    : 500,
      //				transformStyle : "preserve-3d"
      //			});
      // mouse move on block

      $(obj).on('mousemove touchmove', function (e) {
        var mX, mY, rmX, rmY;
        var touches = e.originalEvent.touches;

        if (touches && touches.length) {
          mX = touches[0].pageX;
          mY = touches[0].pageY;
        } else {
          mX = e.pageX;
          mY = e.pageY;
        } //Find mouse position relative to element


        rmX = mX - $(this).offset().left;
        rmY = mY - $(this).offset().top; //console.log('X: ' + rmX + ' Y: ' + rmY );
        // function to run matrix3D effect on block

        var tX = mousePosition(rmX, w),
            tY = mousePosition(rmY, h);
        TweenMax.to($(this), 0.2, {
          rotationY: tX,
          rotationX: tY,
          backgroundPosition: tX + 120 + "% 50%"
        });
      });

      if (reset) {
        $(obj).on('mouseleave touchcancel', function () {
          TweenMax.to($(this), 0.5, {
            rotationY: 0,
            rotationX: 0,
            backgroundPosition: "120% 50%"
          });
        });
      } // make some calculations for mouse position


      function mousePosition(mousePos, dimension) {
        return Math.floor(mousePos / dimension * (base * 2)) - base;
      }
    }
    /*
     * Sets an animation with parallax for each element
     *
     * @param  {Number} base           - Base offset value.
     * @param  {Number} multiple       - The power of target number.
     * @param  {String} obj            - An HTML element.
     * @param  {Boolean} reset         - Reset block on mouse leave
     * @return {Void}
     */


    function animate3dMultiElement(base, multiple, obj, reset) {
      //get the specs of the element
      var divOffset = $(obj).offset(),
          divTop = divOffset.top,
          divLeft = divOffset.left,
          divWidth = $(obj).innerWidth(),
          divHeight = $(obj).innerHeight(); //set an onmousemove event on the element

      $(obj).on('mousemove touchmove', function (e) {
        var pctX, pctY;
        var touches = e.originalEvent.touches;

        if (touches && touches.length) {
          pctX = (touches[0].pageX - divLeft) / divWidth;
          pctY = (touches[0].pageY - divTop) / divHeight;
        } else {
          pctX = (e.pageX - divLeft) / divWidth;
          pctY = (e.pageY - divTop) / divHeight;
        }

        $(this).children().each(function (index, elementSub) {
          var x = pctX * (base * Math.pow(multiple, index)),
              y = pctY * (base * Math.pow(multiple, index)),
              z = 0,
              deg = pctY * (180 / Math.PI),
              rotateDeg = parseFloat(deg - 35);
          TweenMax.to($(elementSub), 0.2, {
            css: {
              'transform': 'translate(' + x + 'px ,' + y + 'px) rotate3d( -1, 1, 0, ' + rotateDeg + 'deg )'
            }
          });
        });
      });

      if (reset) {
        $(obj).on('mouseleave touchcancel', function () {
          $(this).children().each(function (index, elementSub) {
            TweenMax.to($(elementSub), 0.5, {
              css: {
                'transform': 'translate(0,0) rotate3d( -1, 1, 0, 0deg )'
              }
            });
          });
        });
      }
    }
  };

  module.components.documentReady.push(module.THREE_BACKGROUND.documentReady);
  return function THREE_BACKGROUND() {
    simple_3D_background_js_classCallCheck(this, THREE_BACKGROUND);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/simple-3D-carousel/scss/_style.scss
var simple_3D_carousel_scss_style = __webpack_require__(69);

// CONCATENATED MODULE: ./src/components/simple-3D-carousel/js/index.js
function simple_3D_carousel_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_carousel_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_carousel_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_carousel_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_carousel_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Carousel -->
 *************************************
 */


var THREE_CAROUSEL = function (module, $, window, document) {
  if (window.THREE_CAROUSEL === null) return false;
  module.THREE_CAROUSEL = module.THREE_CAROUSEL || {};
  module.THREE_CAROUSEL.version = '0.0.2';

  module.THREE_CAROUSEL.documentReady = function ($) {
    $('.uix-3d-carousel').each(function () {
      var $this = $(this);
      var $wrapper = $this.find('> ul'),
          $items = $wrapper.find('> li'),
          itemCount = $items.length;
      var dataTiming = $this.data('timing'),
          dataPrevBtn = $this.data('prev-btn'),
          dataNextBtn = $this.data('next-btn'),
          dataDraggable = $this.data('draggable'),
          autoSwap = null,
          items = [],
          startItem = 1,
          position = 0,
          leftpos = itemCount,
          resetCount = itemCount;
      if (simple_3D_carousel_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 5000;
      if (simple_3D_carousel_js_typeof(dataPrevBtn) === ( true ? "undefined" : undefined)) dataPrevBtn = ".my-carousel-3d-prev";
      if (simple_3D_carousel_js_typeof(dataNextBtn) === ( true ? "undefined" : undefined)) dataNextBtn = ".my-carousel-3d-next";
      if (simple_3D_carousel_js_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false; //Avoid problems caused by insufficient quantity
      //-------------------------------------		

      if (itemCount == 3) {
        var $clone3 = $items.eq(1).clone();
        $items.last().after($clone3);
      }

      if (itemCount == 2) {
        var $clone2_1 = $items.eq(0).clone(),
            $clone2_2 = $items.eq(1).clone();
        $items.last().after([$clone2_1, $clone2_2]);
      }

      if (itemCount == 1) {
        var $clone1_1 = $items.eq(0).clone(),
            $clone1_2 = $items.eq(0).clone(),
            $clone1_3 = $items.eq(0).clone();
        $items.last().after([$clone1_1, $clone1_2, $clone1_3]);
      } //New objects of items and wrapper


      $wrapper = $this.find('> ul');
      $items = $wrapper.find('> li');
      itemCount = $items.length;
      leftpos = itemCount;
      resetCount = itemCount; //Adding an index to an element makes it easy to query
      //-------------------------------------	

      $items.each(function (index) {
        items[index] = $(this).text();
        $(this).attr('id', index + 1);
      }); //Pause slideshow and reinstantiate on mouseout
      //-------------------------------------	

      $wrapper.on('mouseenter', function () {
        clearInterval(autoSwap);
      }).on('mouseleave', function () {
        autoSwap = setInterval(itemUpdates, dataTiming);
      }); //Initialize the default effect
      //-------------------------------------	

      itemUpdates('clockwise'); //The matched click events for the element.
      //-------------------------------------	

      $(dataPrevBtn).on('click', function (e) {
        e.preventDefault();
        itemUpdates('clockwise');
        return false;
      });
      $(dataNextBtn).on('click', function (e) {
        e.preventDefault();
        itemUpdates('counter-clockwise');
        return false;
      });
      $items.on('click', function (e) {
        e.preventDefault();

        if ($(this).attr('class') == 'uix-3d-carousel__item uix-3d-carousel__item--left-pos') {
          itemUpdates('counter-clockwise');
        } else {
          itemUpdates('clockwise');
        }
      }); //Drag and Drop
      //-------------------------------------	

      var $dragDropTrigger = $wrapper;
      var hammerProps = {};

      if (!dataDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps); // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft', function (ev) {
        //Set the direction in here
        direction = ev.type;
      });
      dragDropMC.on('panend', function (ev) {
        //Use the direction in here
        //You know the pan has ended
        //and you know which action they were taking
        if (direction == 'panleft') {
          itemUpdates('clockwise');
        }

        if (direction == 'panright') {
          itemUpdates('counter-clockwise');
        }
      });
      /*
       * Swap Between Images
       *
       * @param  {String} action           - Direction of movement, optional: clockwise, counter-clockwise
       * @return {Void}
       */

      function itemUpdates(action) {
        var direction = action; //moving carousel backwards

        if (direction == 'counter-clockwise') {
          var leftitem = parseFloat($wrapper.find('> li.uix-3d-carousel__item--left-pos').attr('id') - 1);

          if (leftitem == 0) {
            leftitem = itemCount;
          }

          $wrapper.find('> li.uix-3d-carousel__item--right-pos').removeClass('uix-3d-carousel__item--right-pos').addClass('uix-3d-carousel__item--back-pos');
          $wrapper.find('> li.uix-3d-carousel__item--main-pos').removeClass('uix-3d-carousel__item--main-pos').addClass('uix-3d-carousel__item--right-pos');
          $wrapper.find('> li.uix-3d-carousel__item--left-pos').removeClass('uix-3d-carousel__item--left-pos').addClass('uix-3d-carousel__item--main-pos');
          $wrapper.find('> li#' + leftitem + '').removeClass('uix-3d-carousel__item--back-pos').addClass('uix-3d-carousel__item--left-pos');
          startItem--;

          if (startItem < 1) {
            startItem = itemCount;
          }
        } //moving carousel forward


        if (direction == 'clockwise' || direction == '' || direction == null) {
          var carousel3DPos = function carousel3DPos(dir) {
            if (dir != 'leftposition') {
              //increment image list id
              position++; //if final result is greater than image count, reset position.

              if (startItem + position > resetCount) {
                position = 1 - startItem;
              }
            } //setting the left positioned item


            if (dir == 'leftposition') {
              //left positioned image should always be one left than main positioned image.
              position = startItem - 1; //reset last image in list to left position if first image is in main position

              if (position < 1) {
                position = itemCount;
              }
            }

            return position;
          };

          $wrapper.find('> li#' + startItem + '').removeClass('uix-3d-carousel__item--main-pos').addClass('uix-3d-carousel__item--left-pos');
          $wrapper.find('> li#' + (startItem + carousel3DPos()) + '').removeClass('uix-3d-carousel__item--right-pos').addClass('uix-3d-carousel__item--main-pos');
          $wrapper.find('> li#' + (startItem + carousel3DPos()) + '').removeClass('uix-3d-carousel__item--back-pos').addClass('uix-3d-carousel__item--right-pos');
          $wrapper.find('> li#' + carousel3DPos('leftposition') + '').removeClass('uix-3d-carousel__item--left-pos').addClass('uix-3d-carousel__item--back-pos');
          startItem++;
          position = 0;

          if (startItem > itemCount) {
            startItem = 1;
          }
        }
      }
    });
  };

  module.components.documentReady.push(module.THREE_CAROUSEL.documentReady);
  return function THREE_CAROUSEL() {
    simple_3D_carousel_js_classCallCheck(this, THREE_CAROUSEL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/controls/OrbitControls.js
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or arrow keys / touch: two-finger move
THREE.OrbitControls = function (object, domElement) {
  this.object = object;
  this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control

  this.enabled = true; // "target" sets the location of focus, where the object orbits around

  this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

  this.minDistance = 0;
  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

  this.minZoom = 0;
  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.

  this.minPolarAngle = 0; // radians

  this.maxPolarAngle = Math.PI; // radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

  this.minAzimuthAngle = -Infinity; // radians

  this.maxAzimuthAngle = Infinity; // radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop

  this.enableDamping = false;
  this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming

  this.enableZoom = true;
  this.zoomSpeed = 1.0; // Set to false to disable rotating

  this.enableRotate = true;
  this.rotateSpeed = 1.0; // Set to false to disable panning

  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = false; // if true, pan in screen-space

  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop

  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
  // Set to false to disable use of the keys

  this.enableKeys = true; // The four arrow keys

  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }; // Mouse buttons

  this.mouseButtons = {
    ORBIT: THREE.MOUSE.LEFT,
    ZOOM: THREE.MOUSE.MIDDLE,
    PAN: THREE.MOUSE.RIGHT
  }; // for reset

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom; //
  // public methods
  //

  this.getPolarAngle = function () {
    return spherical.phi;
  };

  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };

  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };

  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  }; // this method is exposed, but perhaps it would be better if we can make it private...


  this.update = function () {
    var offset = new THREE.Vector3(); // so camera.up is the orbit axis

    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();
    var lastPosition = new THREE.Vector3();
    var lastQuaternion = new THREE.Quaternion();
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

      offset.applyQuaternion(quat); // angle from z-axis around y-axis

      spherical.setFromVector3(offset);

      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      spherical.theta += sphericalDelta.theta;
      spherical.phi += sphericalDelta.phi; // restrict theta to be between desired limits

      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits

      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale; // restrict radius to be between desired limits

      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

      scope.target.add(panOffset);
      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }

      scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }

      return false;
    };
  }();

  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  }; //
  // internals
  //


  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_DOLLY_PAN: 4
  };
  var state = STATE.NONE;
  var EPS = 0.000001; // current position in spherical coordinates

  var spherical = new THREE.Spherical();
  var sphericalDelta = new THREE.Spherical();
  var scale = 1;
  var panOffset = new THREE.Vector3();
  var zoomChanged = false;
  var rotateStart = new THREE.Vector2();
  var rotateEnd = new THREE.Vector2();
  var rotateDelta = new THREE.Vector2();
  var panStart = new THREE.Vector2();
  var panEnd = new THREE.Vector2();
  var panDelta = new THREE.Vector2();
  var dollyStart = new THREE.Vector2();
  var dollyEnd = new THREE.Vector2();
  var dollyDelta = new THREE.Vector2();

  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }

  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }

  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }

  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }

  var panLeft = function () {
    var v = new THREE.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();

  var panUp = function () {
    var v = new THREE.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }

      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }(); // deltaX and deltaY are in pixels; right and down are positive


  var pan = function () {
    var offset = new THREE.Vector3();
    return function pan(deltaX, deltaY) {
      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length(); // half of the fov is center to top of screen

        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();

  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  } //
  // event callbacks - update the object state
  //


  function handleMouseDownRotate(event) {
    //console.log( 'handleMouseDownRotate' );
    rotateStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownDolly(event) {
    //console.log( 'handleMouseDownDolly' );
    dollyStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownPan(event) {
    //console.log( 'handleMouseDownPan' );
    panStart.set(event.clientX, event.clientY);
  }

  function handleMouseMoveRotate(event) {
    //console.log( 'handleMouseMoveRotate' );
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement; // rotating across whole screen goes 360 degrees around

    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth); // rotating up and down along whole screen attempts to go 360, but limited to 180

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleMouseMoveDolly(event) {
    //console.log( 'handleMouseMoveDolly' );
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {
      dollyIn(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyOut(getZoomScale());
    }

    dollyStart.copy(dollyEnd);
    scope.update();
  }

  function handleMouseMovePan(event) {
    //console.log( 'handleMouseMovePan' );
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }

  function handleMouseUp(event) {// console.log( 'handleMouseUp' );
  }

  function handleMouseWheel(event) {
    // console.log( 'handleMouseWheel' );
    if (event.deltaY < 0) {
      dollyOut(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyIn(getZoomScale());
    }

    scope.update();
  }

  function handleKeyDown(event) {
    //console.log( 'handleKeyDown' );
    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        scope.update();
        break;

      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        scope.update();
        break;
    }
  }

  function handleTouchStartRotate(event) {
    //console.log( 'handleTouchStartRotate' );
    rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
  }

  function handleTouchStartDollyPan(event) {
    //console.log( 'handleTouchStartDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }

    if (scope.enablePan) {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }

  function handleTouchMoveRotate(event) {
    //console.log( 'handleTouchMoveRotate' );
    rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement; // rotating across whole screen goes 360 degrees around

    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth); // rotating up and down along whole screen attempts to go 360, but limited to 180

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleTouchMoveDollyPan(event) {
    //console.log( 'handleTouchMoveDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyIn(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }

    if (scope.enablePan) {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }

    scope.update();
  }

  function handleTouchEnd(event) {//console.log( 'handleTouchEnd' );
  } //
  // event handlers - FSM: listen for events and reset state
  //


  function onMouseDown(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.button) {
      case scope.mouseButtons.ORBIT:
        if (scope.enableRotate === false) return;
        handleMouseDownRotate(event);
        state = STATE.ROTATE;
        break;

      case scope.mouseButtons.ZOOM:
        if (scope.enableZoom === false) return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;

      case scope.mouseButtons.PAN:
        if (scope.enablePan === false) return;
        handleMouseDownPan(event);
        state = STATE.PAN;
        break;
    }

    if (state !== STATE.NONE) {
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);
      scope.dispatchEvent(startEvent);
    }
  }

  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;

      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;

      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }

  function onMouseUp(event) {
    if (scope.enabled === false) return;
    handleMouseUp(event);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }

  function onKeyDown(event) {
    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }

  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (scope.enableRotate === false) return;
        handleTouchStartRotate(event);
        state = STATE.TOUCH_ROTATE;
        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableZoom === false && scope.enablePan === false) return;
        handleTouchStartDollyPan(event);
        state = STATE.TOUCH_DOLLY_PAN;
        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }

  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (scope.enableRotate === false) return;
        if (state !== STATE.TOUCH_ROTATE) return; // is this needed?

        handleTouchMoveRotate(event);
        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableZoom === false && scope.enablePan === false) return;
        if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?

        handleTouchMoveDollyPan(event);
        break;

      default:
        state = STATE.NONE;
    }
  }

  function onTouchEnd(event) {
    if (scope.enabled === false) return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  } //


  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
  scope.domElement.addEventListener('mousedown', onMouseDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);
  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);
  window.addEventListener('keydown', onKeyDown, false); // force an update at start

  this.update();
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
Object.defineProperties(THREE.OrbitControls.prototype, {
  center: {
    get: function get() {
      console.warn('THREE.OrbitControls: .center has been renamed to .target');
      return this.target;
    }
  },
  // backward compatibility
  noZoom: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;
    }
  },
  noRotate: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;
    }
  },
  noPan: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;
    }
  },
  noKeys: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;
    }
  },
  staticMoving: {
    get: function get() {
      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;
    }
  },
  dynamicDampingFactor: {
    get: function get() {
      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;
    }
  }
});
/* harmony default export */ var OrbitControls = (THREE.OrbitControls);
// CONCATENATED MODULE: ./src/components/simple-3D-gallery/js/index.js
function simple_3D_gallery_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_gallery_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_gallery_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_gallery_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_gallery_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Gallery with three.js -->
 *************************************
 */


var THREE_GALLERY = function (module, $, window, document) {
  if (window.THREE_GALLERY === null) return false;
  module.THREE_GALLERY = module.THREE_GALLERY || {};
  module.THREE_GALLERY.version = '0.0.4';

  module.THREE_GALLERY.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-gallery-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-gallery-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0;
      var offsetWidth = 1400,
          offsetHeight = 933,
          allImages = [],
          imgTotal,
          imagesLoaded = false; // we will keep track of the scroll

      var scrollValue = 0;
      var lastScrollValue = 0;

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var imgs = ['https://placekitten.com/2100/2100', 'https://placekitten.com/2200/2200', 'https://placekitten.com/2300/2300', 'https://placekitten.com/2400/2400', 'https://placekitten.com/2500/2500', 'https://placekitten.com/2000/2000', 'https://placekitten.com/1600/1600', 'https://placekitten.com/1650/1650', 'https://placekitten.com/1670/1670', 'https://placekitten.com/1680/1680', 'https://placekitten.com/1700/1700']; //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        imgTotal = imgs.length;
        var gap = 100,
            circumference = (offsetWidth + gap) * imgTotal,
            //get circumference from all images width
        galleryRadius = circumference / (Math.PI * 2),
            // C = 2πr = Math.PI * 2 * radius
        eachItemAngleToRad = Math.PI * 2 / imgTotal; // 360° = 2π = Math.PI * 2

        if (camera.position.length() > galleryRadius) {
          camera.position.set(0, 0, 0);
        } //Load images


        imgs.forEach(function (element, index) {
          loadImage(loader, element, index, offsetWidth, offsetHeight, imgTotal, eachItemAngleToRad, galleryRadius, $('#3D-gallery-three-canvas__loader'));
        }); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000); // listen to scroll to update

        var delta = scrollValue - lastScrollValue; // threshold

        if (delta > 60) {
          delta = 60;
        } else if (delta < -60) {
          delta = -60;
        }

        camera.position.x = camera.position.x + delta; //check all images loaded

        if (simple_3D_gallery_js_typeof(allImages) != ( true ? "undefined" : undefined)) {
          if (!imagesLoaded && allImages.length === imgTotal) {
            allImages.forEach(function (element) {
              scene.add(element);
            });
            imagesLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // listen to scroll


      window.addEventListener('scroll', function (e) {
        lastScrollValue = scrollValue;
        scrollValue = window.pageYOffset;
        console.log('lastScrollValue: ' + lastScrollValue + ', scrollValue: ' + scrollValue);
      });
      /*
       * Load Image
       *
       * @param  {Element} imgLoader       - A loader for loading all images from array.
       * @param  {String} src             - URL of image.
       * @param  {Number} index           - Index of image.
       * @param  {Number} w               - The width of an image, in pixels. 
       * @param  {Number} h               - The height of an image, in pixels. 
       * @param  {Number} total           - Total number of preload images.
       * @param  {Number} itemRadAngle    - An equal radian angle of a sphere for each element.
       * @param  {Number} radius          - Radius length of the sphere (circumference).
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */

      function loadImage(imgLoader, src, index, w, h, total, itemRadAngle, radius, loading) {
        // load a resource
        imgLoader.load( // resource URL
        src, // onLoad callback
        function (texture) {
          // in this example we create the material when the texture is loaded
          var material = new THREE.MeshBasicMaterial({
            map: texture
          });
          var geometry = new THREE.PlaneGeometry(w, h);
          var mesh = new THREE.Mesh(geometry, material); //LinearFilter, which takes the four closest texels and bilinearly interpolates among them. 

          mesh.minFilter = THREE.LinearFilter;
          mesh.overdraw = true; //Calculate the position of the image 
          //X axis: a = sinA * c = Math.sin( rad ) * radius
          //Z axis: b = cosA * c = Math.cos( rad ) * radius

          mesh.rotation.y = -index * itemRadAngle;
          mesh.position.set(radius * Math.sin(index * itemRadAngle), 0, -radius * Math.cos(index * itemRadAngle));
          allImages.push(mesh); //loading

          TweenMax.to(loading, 0.5, {
            width: Math.round(100 * allImages.length / total) + '%',
            onComplete: function onComplete() {
              if ($(this.target).width() >= windowWidth - 50) {
                TweenMax.to(this.target, 0.5, {
                  alpha: 0
                });
              }
            }
          });
        }, // onProgress callback currently not supported
        undefined, // onError callback
        function (err) {
          console.error('An error happened.');
        });
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_GALLERY.documentReady);
  return function THREE_GALLERY() {
    simple_3D_gallery_js_classCallCheck(this, THREE_GALLERY);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/shader/fragment-custom.glsl
/* harmony default export */ var shader_fragment_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform sampler2D disp;\n\n// uniform float time;\n// uniform float _rot;\nuniform float dispFactor;\nuniform float effectFactor;\n\n// vec2 rotate(vec2 v, float a) {\n//  float s = sin(a);\n//  float c = cos(a);\n//  mat2 m = mat2(c, -s, s, c);\n//  return m * v;\n// }\n\nvoid main() {\n\n    vec2 uv = vUv;\n\n    // uv -= 0.5;\n    // vec2 rotUV = rotate(uv, _rot);\n    // uv += 0.5;\n\n    vec4 disp = texture2D(disp, uv);\n\n    vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r*effectFactor), uv.y);\n    vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r*effectFactor), uv.y);\n\n    vec4 _texture = texture2D(texture, distortedPosition);\n    vec4 _texture2 = texture2D(texture2, distortedPosition2);\n\n    vec4 finalTexture = mix(_texture, _texture2, dispFactor);\n\n    gl_FragColor = finalTexture;\n    // gl_FragColor = disp;\n}");
// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/shader/vertex-custom.glsl
/* harmony default export */ var shader_vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}");
// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/index.js
function simple_3D_image_transition_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Image Transition with three.js -->
 *************************************
 */




var THREE_IMAGE_TRANSITION = function (module, $, window, document) {
  if (window.THREE_IMAGE_TRANSITION === null) return false;
  module.THREE_IMAGE_TRANSITION = module.THREE_IMAGE_TRANSITION || {};
  module.THREE_IMAGE_TRANSITION.version = '0.0.3';

  module.THREE_IMAGE_TRANSITION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-imagetransition-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-imagetransition-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0;
      var filterMaterial,
          offsetWidth = $('#' + rendererCanvasID).parent().width(),
          offsetHeight = $('#' + rendererCanvasID).parent().width() * (550 / 1400);

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(offsetWidth, offsetHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var imgs = ['https://placekitten.com/1400/550', 'https://placekitten.com/1410/550'];
        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        var texture1 = loader.load(imgs[0]),
            texture2 = loader.load(imgs[1]),
            intensity = 1,
            dispImage = $('#' + rendererCanvasID).data('filter-texture'),
            //Load displacement image
        disp = loader.load(dispImage);
        disp.wrapS = disp.wrapT = THREE.RepeatWrapping;
        texture1.magFilter = texture2.magFilter = THREE.LinearFilter;
        texture1.minFilter = texture2.minFilter = THREE.LinearFilter;
        texture1.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture2.anisotropy = renderer.capabilities.getMaxAnisotropy();
        var geometry = new THREE.PlaneBufferGeometry(offsetWidth, offsetHeight, 1);
        filterMaterial = new THREE.ShaderMaterial({
          uniforms: {
            effectFactor: {
              type: "f",
              value: intensity
            },
            dispFactor: {
              type: "f",
              value: 0.0
            },
            texture: {
              type: "t",
              value: texture1
            },
            texture2: {
              type: "t",
              value: texture2
            },
            disp: {
              type: "t",
              value: disp
            }
          },
          vertexShader: shader_vertex_custom,
          fragmentShader: shader_fragment_custom,
          transparent: true,
          opacity: 1.0
        });
        displacementSprite = new THREE.Mesh(geometry, filterMaterial);
        displacementSprite.position.set(0, 0, 0);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        document.getElementById(rendererCanvasID).addEventListener('mouseenter', onDocumentMouseEnter, false);
        document.getElementById(rendererCanvasID).addEventListener('mouseleave', onDocumentMouseLeave, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseEnter(event) {
        TweenMax.to(filterMaterial.uniforms.dispFactor, 1.5, {
          value: 1,
          ease: Expo.easeOut
        });
      }

      function onDocumentMouseLeave(event) {
        TweenMax.to(filterMaterial.uniforms.dispFactor, 1, {
          value: 0,
          ease: Expo.easeOut
        });
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_IMAGE_TRANSITION.documentReady);
  return function THREE_IMAGE_TRANSITION() {
    simple_3D_image_transition_js_classCallCheck(this, THREE_IMAGE_TRANSITION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/loaders/OBJLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.OBJLoader = function () {
  // o object_name | g group_name
  var object_pattern = /^[og]\s*(.+)?/; // mtllib file_reference

  var material_library_pattern = /^mtllib /; // usemtl material_name

  var material_use_pattern = /^usemtl /;

  function ParserState() {
    var state = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      colors: [],
      uvs: [],
      materialLibraries: [],
      startObject: function startObject(name, fromDeclaration) {
        // If the current object (initial from reset) is not from a g/o declaration in the parsed
        // file. We need to use it for the first parsed g/o to keep things in sync.
        if (this.object && this.object.fromDeclaration === false) {
          this.object.name = name;
          this.object.fromDeclaration = fromDeclaration !== false;
          return;
        }

        var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

        if (this.object && typeof this.object._finalize === 'function') {
          this.object._finalize(true);
        }

        this.object = {
          name: name || '',
          fromDeclaration: fromDeclaration !== false,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: []
          },
          materials: [],
          smooth: true,
          startMaterial: function startMaterial(name, libraries) {
            var previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared
            // after the material, then it must be preserved for proper MultiMaterial continuation.


            if (previous && (previous.inherited || previous.groupCount <= 0)) {
              this.materials.splice(previous.index, 1);
            }

            var material = {
              index: this.materials.length,
              name: name || '',
              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
              smooth: previous !== undefined ? previous.smooth : this.smooth,
              groupStart: previous !== undefined ? previous.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: false,
              clone: function clone(index) {
                var cloned = {
                  index: typeof index === 'number' ? index : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: false
                };
                cloned.clone = this.clone.bind(cloned);
                return cloned;
              }
            };
            this.materials.push(material);
            return material;
          },
          currentMaterial: function currentMaterial() {
            if (this.materials.length > 0) {
              return this.materials[this.materials.length - 1];
            }

            return undefined;
          },
          _finalize: function _finalize(end) {
            var lastMultiMaterial = this.currentMaterial();

            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
              lastMultiMaterial.inherited = false;
            } // Ignore objects tail materials if no face declarations followed them before a new o/g started.


            if (end && this.materials.length > 1) {
              for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                if (this.materials[mi].groupCount <= 0) {
                  this.materials.splice(mi, 1);
                }
              }
            } // Guarantee at least one empty material, this makes the creation later more straight forward.


            if (end && this.materials.length === 0) {
              this.materials.push({
                name: '',
                smooth: this.smooth
              });
            }

            return lastMultiMaterial;
          }
        }; // Inherit previous objects material.
        // Spec tells us that a declared material must be set to all objects until a new material is declared.
        // If a usemtl declaration is encountered while this new object is being parsed, it will
        // overwrite the inherited material. Exception being that there was already face declarations
        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
          var declared = previousMaterial.clone(0);
          declared.inherited = true;
          this.object.materials.push(declared);
        }

        this.objects.push(this.object);
      },
      finalize: function finalize() {
        if (this.object && typeof this.object._finalize === 'function') {
          this.object._finalize(true);
        }
      },
      parseVertexIndex: function parseVertexIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      parseNormalIndex: function parseNormalIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      parseUVIndex: function parseUVIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 2) * 2;
      },
      addVertex: function addVertex(a, b, c) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addVertexPoint: function addVertexPoint(a) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      },
      addVertexLine: function addVertexLine(a) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      },
      addNormal: function addNormal(a, b, c) {
        var src = this.normals;
        var dst = this.object.geometry.normals;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addColor: function addColor(a, b, c) {
        var src = this.colors;
        var dst = this.object.geometry.colors;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addUV: function addUV(a, b, c) {
        var src = this.uvs;
        var dst = this.object.geometry.uvs;
        dst.push(src[a + 0], src[a + 1]);
        dst.push(src[b + 0], src[b + 1]);
        dst.push(src[c + 0], src[c + 1]);
      },
      addUVLine: function addUVLine(a) {
        var src = this.uvs;
        var dst = this.object.geometry.uvs;
        dst.push(src[a + 0], src[a + 1]);
      },
      addFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {
        var vLen = this.vertices.length;
        var ia = this.parseVertexIndex(a, vLen);
        var ib = this.parseVertexIndex(b, vLen);
        var ic = this.parseVertexIndex(c, vLen);
        this.addVertex(ia, ib, ic);

        if (ua !== undefined && ua !== '') {
          var uvLen = this.uvs.length;
          ia = this.parseUVIndex(ua, uvLen);
          ib = this.parseUVIndex(ub, uvLen);
          ic = this.parseUVIndex(uc, uvLen);
          this.addUV(ia, ib, ic);
        }

        if (na !== undefined && na !== '') {
          // Normals are many times the same. If so, skip function call and parseInt.
          var nLen = this.normals.length;
          ia = this.parseNormalIndex(na, nLen);
          ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
          ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
          this.addNormal(ia, ib, ic);
        }

        if (this.colors.length > 0) {
          this.addColor(ia, ib, ic);
        }
      },
      addPointGeometry: function addPointGeometry(vertices) {
        this.object.geometry.type = 'Points';
        var vLen = this.vertices.length;

        for (var vi = 0, l = vertices.length; vi < l; vi++) {
          this.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));
        }
      },
      addLineGeometry: function addLineGeometry(vertices, uvs) {
        this.object.geometry.type = 'Line';
        var vLen = this.vertices.length;
        var uvLen = this.uvs.length;

        for (var vi = 0, l = vertices.length; vi < l; vi++) {
          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
        }

        for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
        }
      }
    };
    state.startObject('', false);
    return state;
  } //


  function OBJLoader(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
    this.materials = null;
  }

  OBJLoader.prototype = {
    constructor: OBJLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new THREE.FileLoader(scope.manager);
      loader.setPath(this.path);
      loader.load(url, function (text) {
        onLoad(scope.parse(text));
      }, onProgress, onError);
    },
    setPath: function setPath(value) {
      this.path = value;
      return this;
    },
    setMaterials: function setMaterials(materials) {
      this.materials = materials;
      return this;
    },
    parse: function parse(text) {
      console.time('OBJLoader');
      var state = new ParserState();

      if (text.indexOf('\r\n') !== -1) {
        // This is faster than String.split with regex that splits on both
        text = text.replace(/\r\n/g, '\n');
      }

      if (text.indexOf('\\\n') !== -1) {
        // join lines separated by a line continuation character (\)
        text = text.replace(/\\\n/g, '');
      }

      var lines = text.split('\n');
      var line = '',
          lineFirstChar = '';
      var lineLength = 0;
      var result = []; // Faster to just trim left side of the line. Use if available.

      var trimLeft = typeof ''.trimLeft === 'function';

      for (var i = 0, l = lines.length; i < l; i++) {
        line = lines[i];
        line = trimLeft ? line.trimLeft() : line.trim();
        lineLength = line.length;
        if (lineLength === 0) continue;
        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any

        if (lineFirstChar === '#') continue;

        if (lineFirstChar === 'v') {
          var data = line.split(/\s+/);

          switch (data[0]) {
            case 'v':
              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));

              if (data.length === 8) {
                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
              }

              break;

            case 'vn':
              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
              break;

            case 'vt':
              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
              break;
          }
        } else if (lineFirstChar === 'f') {
          var lineData = line.substr(1).trim();
          var vertexData = lineData.split(/\s+/);
          var faceVertices = []; // Parse the face vertex data into an easy to work with format

          for (var j = 0, jl = vertexData.length; j < jl; j++) {
            var vertex = vertexData[j];

            if (vertex.length > 0) {
              var vertexParts = vertex.split('/');
              faceVertices.push(vertexParts);
            }
          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon


          var v1 = faceVertices[0];

          for (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {
            var v2 = faceVertices[j];
            var v3 = faceVertices[j + 1];
            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
          }
        } else if (lineFirstChar === 'l') {
          var lineParts = line.substring(1).trim().split(" ");
          var lineVertices = [],
              lineUVs = [];

          if (line.indexOf("/") === -1) {
            lineVertices = lineParts;
          } else {
            for (var li = 0, llen = lineParts.length; li < llen; li++) {
              var parts = lineParts[li].split("/");
              if (parts[0] !== "") lineVertices.push(parts[0]);
              if (parts[1] !== "") lineUVs.push(parts[1]);
            }
          }

          state.addLineGeometry(lineVertices, lineUVs);
        } else if (lineFirstChar === 'p') {
          var lineData = line.substr(1).trim();
          var pointData = lineData.split(" ");
          state.addPointGeometry(pointData);
        } else if ((result = object_pattern.exec(line)) !== null) {
          // o object_name
          // or
          // g group_name
          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
          // var name = result[ 0 ].substr( 1 ).trim();
          var name = (" " + result[0].substr(1).trim()).substr(1);
          state.startObject(name);
        } else if (material_use_pattern.test(line)) {
          // material
          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
        } else if (material_library_pattern.test(line)) {
          // mtl file
          state.materialLibraries.push(line.substring(7).trim());
        } else if (lineFirstChar === 's') {
          result = line.split(' '); // smooth shading
          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
          // but does not define a usemtl for each face set.
          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
          // This requires some care to not create extra material on each smooth value for "normal" obj files.
          // where explicit usemtl defines geometry groups.
          // Example asset: examples/models/obj/cerberus/Cerberus.obj

          /*
           * http://paulbourke.net/dataformats/obj/
           * or
           * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
           *
           * From chapter "Grouping" Syntax explanation "s group_number":
           * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
           * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
           * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
           * than 0."
           */

          if (result.length > 1) {
            var value = result[1].trim().toLowerCase();
            state.object.smooth = value !== '0' && value !== 'off';
          } else {
            // ZBrush can produce "s" lines #11707
            state.object.smooth = true;
          }

          var material = state.object.currentMaterial();
          if (material) material.smooth = state.object.smooth;
        } else {
          // Handle null terminated files without exception
          if (line === '\0') continue;
          throw new Error('THREE.OBJLoader: Unexpected line: "' + line + '"');
        }
      }

      state.finalize();
      var container = new THREE.Group();
      container.materialLibraries = [].concat(state.materialLibraries);

      for (var i = 0, l = state.objects.length; i < l; i++) {
        var object = state.objects[i];
        var geometry = object.geometry;
        var materials = object.materials;
        var isLine = geometry.type === 'Line';
        var isPoints = geometry.type === 'Points';
        var hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces

        if (geometry.vertices.length === 0) continue;
        var buffergeometry = new THREE.BufferGeometry();
        buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));

        if (geometry.normals.length > 0) {
          buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
        } else {
          buffergeometry.computeVertexNormals();
        }

        if (geometry.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));
        }

        if (geometry.uvs.length > 0) {
          buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
        } // Create materials


        var createdMaterials = [];

        for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
          var sourceMaterial = materials[mi];
          var material = undefined;

          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.

            if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
              var materialLine = new THREE.LineBasicMaterial();
              materialLine.copy(material);
              materialLine.lights = false; // TOFIX

              material = materialLine;
            } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {
              var materialPoints = new THREE.PointsMaterial({
                size: 10,
                sizeAttenuation: false
              });
              materialLine.copy(material);
              material = materialPoints;
            }
          }

          if (!material) {
            if (isLine) {
              material = new THREE.LineBasicMaterial();
            } else if (isPoints) {
              material = new THREE.PointsMaterial({
                size: 1,
                sizeAttenuation: false
              });
            } else {
              material = new THREE.MeshPhongMaterial();
            }

            material.name = sourceMaterial.name;
          }

          material.flatShading = sourceMaterial.smooth ? false : true;
          material.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;
          createdMaterials.push(material);
        } // Create mesh


        var mesh;

        if (createdMaterials.length > 1) {
          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
            var sourceMaterial = materials[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }

          if (isLine) {
            mesh = new THREE.LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new THREE.Points(buffergeometry, createdMaterials);
          } else {
            mesh = new THREE.Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new THREE.Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);
          }
        }

        mesh.name = object.name;
        container.add(mesh);
      }

      console.timeEnd('OBJLoader');
      return container;
    }
  };
  return OBJLoader;
}();

/* harmony default export */ var OBJLoader = (THREE.OBJLoader);
// CONCATENATED MODULE: ./src/components/simple-3D-model/js/index.js
function simple_3D_model_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_model_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_model_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_model_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_model_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Model -->
 *************************************
 */



var THREE_MODEL = function (module, $, window, document) {
  if (window.THREE_MODEL === null) return false;
  module.THREE_MODEL = module.THREE_MODEL || {};
  module.THREE_MODEL.version = '0.0.3';

  module.THREE_MODEL.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-model-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-model-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          radius = 100,
          theta = 0,
          clickEnable = false;
      var mouseVector = new THREE.Vector2();
      var INTERSECTED, INTERSECTED_CLICK, raycaster;

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(45, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, -1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = true;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0xcccccc, 0.4));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        var manager = new THREE.LoadingManager();

        manager.onProgress = function (item, loaded, total) {
          console.log(item, loaded, total);
        };

        var textureURL = simple_3D_model_js_typeof($('#' + rendererCanvasID).data('texture-src')) != ( true ? "undefined" : undefined) ? $('#' + rendererCanvasID).data('texture-src') : templateUrl + '/assets/models/obj/project.png';
        var objURL = simple_3D_model_js_typeof($('#' + rendererCanvasID).data('model-src')) != ( true ? "undefined" : undefined) ? $('#' + rendererCanvasID).data('model-src') : templateUrl + '/assets/models/obj/project.obj';

        var textureLoader = new THREE.TextureLoader(manager),
            texture = textureLoader.load(textureURL),
            onProgress = function onProgress(xhr) {
          if (xhr.lengthComputable) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log(Math.round(percentComplete, 2) + '% downloaded');
          }
        },
            onError = function onError(xhr) {};

        var loader = new THREE.OBJLoader(manager);
        loader.load(objURL, function (object) {
          object.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              child.material = new THREE.MeshPhongMaterial({
                color: 0x2194CE,
                wireframe: false,
                map: texture,
                side: THREE.DoubleSide
              });
            }
          });
          object.scale.set(165, 165, 165);
          object.position.y = 100;
          scene.add(object);
        }, onProgress, onError); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        raycaster = new THREE.Raycaster();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        var intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xffcc00);
          }
        } else {
          if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
          INTERSECTED = null;
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        clickEnable = true; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        var intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          if (INTERSECTED_CLICK != intersects[0].object) {
            INTERSECTED_CLICK = intersects[0].object;
            TweenMax.to(INTERSECTED_CLICK.scale, 1, {
              x: '+=' + (200 - INTERSECTED_CLICK.scale.x) * 0.05,
              y: '+=' + (200 - INTERSECTED_CLICK.scale.y) * 0.05,
              z: '+=' + (200 - INTERSECTED_CLICK.scale.z) * 0.05
            });
            INTERSECTED_CLICK.updateMatrix();
          }
        } else {
          INTERSECTED_CLICK = null;
        }
        /*
        // Parse all the faces
        for ( let i in intersects ) {
        		intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );
        	}
        */

      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        theta = 0;
        clickEnable = false;
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MODEL.documentReady);
  return function THREE_MODEL() {
    simple_3D_model_js_classCallCheck(this, THREE_MODEL);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/renderers/CSS3DRenderer.js
/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * @author mrdoob / http://mrdoob.com/
 * @author yomotsu / https://yomotsu.net/
 */
THREE.CSS3DObject = function (element) {
  THREE.Object3D.call(this);
  this.element = element;
  this.element.style.position = 'absolute';
  this.addEventListener('removed', function () {
    if (this.element.parentNode !== null) {
      this.element.parentNode.removeChild(this.element);
    }
  });
};

THREE.CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;

THREE.CSS3DSprite = function (element) {
  THREE.CSS3DObject.call(this, element);
};

THREE.CSS3DSprite.prototype = Object.create(THREE.CSS3DObject.prototype);
THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite; //

THREE.CSS3DRenderer = function () {
  console.log('THREE.CSS3DRenderer', THREE.REVISION);

  var _width, _height;

  var _widthHalf, _heightHalf;

  var matrix = new THREE.Matrix4();
  var cache = {
    camera: {
      fov: 0,
      style: ''
    },
    objects: new WeakMap()
  };
  var domElement = document.createElement('div');
  domElement.style.overflow = 'hidden';
  this.domElement = domElement;
  var cameraElement = document.createElement('div');
  cameraElement.style.WebkitTransformStyle = 'preserve-3d';
  cameraElement.style.transformStyle = 'preserve-3d';
  domElement.appendChild(cameraElement);
  var isIE = /Trident/i.test(navigator.userAgent);

  this.getSize = function () {
    return {
      width: _width,
      height: _height
    };
  };

  this.setSize = function (width, height) {
    _width = width;
    _height = height;
    _widthHalf = _width / 2;
    _heightHalf = _height / 2;
    domElement.style.width = width + 'px';
    domElement.style.height = height + 'px';
    cameraElement.style.width = width + 'px';
    cameraElement.style.height = height + 'px';
  };

  function epsilon(value) {
    return Math.abs(value) < 1e-10 ? 0 : value;
  }

  function getCameraCSSMatrix(matrix) {
    var elements = matrix.elements;
    return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';
  }

  function getObjectCSSMatrix(matrix, cameraCSSMatrix) {
    var elements = matrix.elements;
    var matrix3d = 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(-elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(-elements[6]) + ',' + epsilon(-elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';

    if (isIE) {
      return 'translate(-50%,-50%)' + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' + cameraCSSMatrix + matrix3d;
    }

    return 'translate(-50%,-50%)' + matrix3d;
  }

  function renderObject(object, camera, cameraCSSMatrix) {
    if (object instanceof THREE.CSS3DObject) {
      var style;

      if (object instanceof THREE.CSS3DSprite) {
        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
        matrix.copy(camera.matrixWorldInverse);
        matrix.transpose();
        matrix.copyPosition(object.matrixWorld);
        matrix.scale(object.scale);
        matrix.elements[3] = 0;
        matrix.elements[7] = 0;
        matrix.elements[11] = 0;
        matrix.elements[15] = 1;
        style = getObjectCSSMatrix(matrix, cameraCSSMatrix);
      } else {
        style = getObjectCSSMatrix(object.matrixWorld, cameraCSSMatrix);
      }

      var element = object.element;
      var cachedStyle = cache.objects.get(object);

      if (cachedStyle === undefined || cachedStyle !== style) {
        element.style.WebkitTransform = style;
        element.style.transform = style;
        var objectData = {
          style: style
        };

        if (isIE) {
          objectData.distanceToCameraSquared = getDistanceToSquared(camera, object);
        }

        cache.objects.set(object, objectData);
      }

      if (element.parentNode !== cameraElement) {
        cameraElement.appendChild(element);
      }
    }

    for (var i = 0, l = object.children.length; i < l; i++) {
      renderObject(object.children[i], camera, cameraCSSMatrix);
    }
  }

  var getDistanceToSquared = function () {
    var a = new THREE.Vector3();
    var b = new THREE.Vector3();
    return function (object1, object2) {
      a.setFromMatrixPosition(object1.matrixWorld);
      b.setFromMatrixPosition(object2.matrixWorld);
      return a.distanceToSquared(b);
    };
  }();

  function filterAndFlatten(scene) {
    var result = [];
    scene.traverse(function (object) {
      if (object instanceof THREE.CSS3DObject) result.push(object);
    });
    return result;
  }

  function zOrder(scene) {
    var sorted = filterAndFlatten(scene).sort(function (a, b) {
      var distanceA = cache.objects.get(a).distanceToCameraSquared;
      var distanceB = cache.objects.get(b).distanceToCameraSquared;
      return distanceA - distanceB;
    });
    var zMax = sorted.length;

    for (var i = 0, l = sorted.length; i < l; i++) {
      sorted[i].element.style.zIndex = zMax - i;
    }
  }

  this.render = function (scene, camera) {
    var fov = camera.projectionMatrix.elements[5] * _heightHalf;

    if (cache.camera.fov !== fov) {
      if (camera.isPerspectiveCamera) {
        domElement.style.WebkitPerspective = fov + 'px';
        domElement.style.perspective = fov + 'px';
      }

      cache.camera.fov = fov;
    }

    scene.updateMatrixWorld();
    if (camera.parent === null) camera.updateMatrixWorld();
    var cameraCSSMatrix = camera.isOrthographicCamera ? 'scale(' + fov + ')' + getCameraCSSMatrix(camera.matrixWorldInverse) : 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);
    var style = cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

    if (cache.camera.style !== style && !isIE) {
      cameraElement.style.WebkitTransform = style;
      cameraElement.style.transform = style;
      cache.camera.style = style;
    }

    renderObject(scene, camera, cameraCSSMatrix);

    if (isIE) {
      // IE10 and 11 does not support 'preserve-3d'.
      // Thus, z-order in 3D will not work.
      // We have to calc z-order manually and set CSS z-index for IE.
      // FYI: z-index can't handle object intersection
      zOrder(scene);
    }
  };
};

/* harmony default export */ var CSS3DRenderer = (THREE.CSS3DObject);
// CONCATENATED MODULE: ./src/components/simple-3D-pages/js/index.js
function simple_3D_pages_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Pages -->
 *************************************
 */

/**
 * module.THREE_PAGES
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */



var THREE_PAGES = function (module, $, window, document) {
  if (window.THREE_PAGES === null) return false;
  module.THREE_PAGES = module.THREE_PAGES || {};
  module.THREE_PAGES.version = '0.0.2';

  module.THREE_PAGES.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-renderer').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var viewRenderer = '3D-renderer'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          clock = new THREE.Clock();

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(45, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, -1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = true;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 1000;
        controls.maxDistance = 1500;
        controls.maxPolarAngle = Math.PI / 2; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        light = new THREE.HemisphereLight(0xffbf67, 0x15c6ff);
        scene.add(light); //WebGL Renderer

        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true
        });
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(windowWidth - 50, windowHeight - 50);
        renderer.domElement.style.zIndex = 5;
        document.getElementById(viewRenderer).appendChild(renderer.domElement); //Add HTML elements to scene

        var target = $('#html3D-view').clone(),
            pages = target.find('.html3D-view-content');
        pages.each(function () {
          var el = new THREE.CSS3DObject($.parseHTML($(this)[0].outerHTML)[0]);
          el.position.x = $(this).data('position-x') || 0;
          el.position.y = $(this).data('position-y') || 0;
          el.position.z = $(this).data('position-z') || 0;
          el.rotation.x = $(this).data('rotation-x') || 0;
          el.rotation.y = $(this).data('rotation-y') || 3.14159265358979;
          el.rotation.z = $(this).data('rotation-z') || 0;
          scene.add(el);
        }); //CSS3D Renderer

        renderer = new THREE.CSS3DRenderer();
        renderer.setSize(windowWidth, windowHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        document.getElementById(viewRenderer).appendChild(renderer.domElement); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(); //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_PAGES.documentReady);
  return function THREE_PAGES() {
    simple_3D_pages_js_classCallCheck(this, THREE_PAGES);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-particle-effect/js/index.js
function simple_3D_particle_effect_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_particle_effect_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_particle_effect_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_particle_effect_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_particle_effect_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Particle Effect -->
 *************************************
 */

/**
 * module.THREE_PARTICLE
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */

var THREE_PARTICLE = function (module, $, window, document) {
  if (window.THREE_PARTICLE === null) return false;
  module.THREE_PARTICLE = module.THREE_PARTICLE || {};
  module.THREE_PARTICLE.version = '0.0.6';

  module.THREE_PARTICLE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-particle-effect-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-particle-effect-canvas';
      var renderer,
          texture,
          scene,
          camera,
          particles,
          imagedata,
          clock = new THREE.Clock(),
          mouseX = 0,
          mouseY = 0,
          isMouseDown = true,
          lastMousePos = {
        x: 0,
        y: 0
      },
          windowHalfX = windowWidth / 2,
          windowHalfY = windowHeight / 2; //background

      var backgroundBg = 0xCE3A3E;
      var backgroundPlane = 0xDE510E; // Light from scene ready

      var sceneForLightPlane, sceneForSpotLight, sceneForAmbientLight; // camera data

      var fieldOfView, aspectRatio, nearPlane, farPlane;
      var dist, vFOV, visibleHeight, visibleWidth;
      var xLimit, yLimit;
      var maxTargetZ = 200; //particle rotation

      var particleRotation;
      var centerVector = new THREE.Vector3(0, 0, 0);
      var previousTime = 0;

      function init() {
        //==================================
        //==================================
        //camera
        fieldOfView = 60;
        aspectRatio = windowWidth / windowHeight;
        nearPlane = 1; // the camera won't "see" any object placed in front of this plane

        farPlane = 10000; // the camera wont't see any object placed further than this plane 

        camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        camera.position.set(0, 65, -500);
        camera.lookAt(centerVector); // convert the field of view to radians

        var ang = fieldOfView / 2 * Math.PI / 180; // calculate the max y position seen by the camera related to the maxTargetZ position, I start by calculating the y limit because fielOfView is a vertical field of view. I then calculate the x Limit

        yLimit = (camera.position.z + maxTargetZ) * Math.tan(ang); // this is a formula I found, don't ask me why it works, it just does :) 
        // Calculate the max x position seen by the camera related to the y Limit position

        xLimit = yLimit * camera.aspect; // Fit plane to screen

        dist = 1000;
        vFOV = THREE.Math.degToRad(camera.fov); // convert vertical fov to radians

        visibleHeight = 2 * Math.tan(vFOV / 2) * dist; // visible height

        visibleWidth = visibleHeight * camera.aspect; // visible width   
        //console.log( 'visibleWidth:' + visibleWidth + ', visibleHeight: ' + visibleHeight + ', xLimit: ' + xLimit + ', yLimit: ' + yLimit );
        //==================================
        //==================================
        //Scene

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(backgroundBg, 0.0025, 650); // Used to cover the light plane
        //==================================
        //==================================
        //Light from scene ready
        // Light plane  

        sceneForLightPlane = new THREE.Mesh(new THREE.CircleGeometry(1000, 32), new THREE.MeshPhongMaterial({
          emissive: backgroundPlane,
          side: THREE.DoubleSide
        }));
        sceneForLightPlane.receiveShadow = true;
        sceneForLightPlane.position.set(0, -101, 5);
        sceneForLightPlane.rotation.x = getRadian(-95);
        scene.add(sceneForLightPlane); // Spot Light

        var spotLightColor = 0xffffff,
            spotLightIntensity = 2,
            spotLightDistance = 1200,
            spotLightAngle = getRadian(50),
            spotLightPenumbra = 1,
            spotLightDecay = 1;
        sceneForSpotLight = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, spotLightDecay);
        sceneForSpotLight.position.set(5, 320, 5); // Setting the y-axis bond angle is critical

        sceneForSpotLight.castShadow = true;
        sceneForSpotLight.shadow.mapSize.width = 1024;
        sceneForSpotLight.shadow.mapSize.height = 1024;
        sceneForSpotLight.shadow.camera.near = 0.5;
        sceneForSpotLight.shadow.camera.far = 31;
        scene.add(sceneForSpotLight); //console.log( sceneForSpotLight );

        /*
        const spotLightHelper = new THREE.SpotLightHelper( sceneForSpotLight );
        scene.add( spotLightHelper );   
        */
        // Ambient Light

        sceneForAmbientLight = new THREE.AmbientLight(0xffffff, 0.08);
        scene.add(sceneForAmbientLight); //==================================
        //==================================
        //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // instantiate a loader

        var loader = new THREE.TextureLoader(); // load a resource

        loader.load( // resource URL
        $('#' + rendererCanvasID).data('img-src'), // onLoad callback
        function (texture) {
          // in this example we create the material when the texture is loaded
          // Get data from an image
          imagedata = getImageData(texture.image); // Immediately use the texture for material creation

          var geometry = new THREE.Geometry();
          var material = new THREE.PointsMaterial({
            size: 3,
            color: 0xffffff,
            sizeAttenuation: false,
            fog: false //Excluding objects from fog

          });

          for (var y = 0, y2 = imagedata.height; y < y2; y += 2) {
            for (var x = 0, x2 = imagedata.width; x < x2; x += 2) {
              if (imagedata.data[x * 4 + y * 4 * imagedata.width + 3] > 128) {
                // The array of vertices holds the position of every vertex in the model.
                var vertex = new THREE.Vector3();
                vertex.x = Math.random() * 1000 - 500;
                vertex.y = Math.random() * 1000 - 500;
                vertex.z = -Math.random() * 500;
                vertex.destination = {
                  x: x - imagedata.width / 2,
                  y: -y + imagedata.height / 2,
                  z: 0
                };
                vertex.speed = Math.random() / 200 + 0.015;
                geometry.vertices.push(vertex);
              }
            }
          }

          particles = new THREE.Points(geometry, material);
          scene.add(particles);
          particles.scale.setScalar(0.7);
          particles.position.y = 50;
          particles.position.z = 70;
          particles.rotation.y = getRadian(180); // set castShadow to object

          particles.castShadow = true;
        }, // onProgress callback currently not supported
        undefined, // onError callback
        function (err) {
          console.error('An error happened.');
        }); // add particle rotation

        particleRotation = new THREE.Object3D();
        scene.add(particleRotation);
        var geometryPR = new THREE.TetrahedronGeometry(2, 0),
            materialPR = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          emissive: 0xffffff,
          shininess: 80,
          flatShading: true
        });

        for (var i = 0; i < 750; i++) {
          var mesh = new THREE.Mesh(geometryPR, materialPR);
          mesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
          mesh.position.multiplyScalar(90 + Math.random() * 700);
          mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
          particleRotation.add(mesh); // set castShadow to object

          mesh.castShadow = true;
        } //----


        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('touchstart', onDocumentTouchStart, browser.supportsPassive ? {
          passive: true
        } : false);
        document.addEventListener('touchmove', onDocumentTouchMove, browser.supportsPassive ? {
          passive: true
        } : false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(),
            thickness = 40; //---
        // 
        // To set a background color.

        renderer.setClearColor(backgroundBg); //---
        // 
        //Need to add judgment to avoid Cannot read property 'geometry' of undefined

        if (simple_3D_particle_effect_js_typeof(particles) != ( true ? "undefined" : undefined)) {
          var particle;

          for (var i = 0, j = particles.geometry.vertices.length; i < j; i++) {
            particle = particles.geometry.vertices[i];
            particle.x += (particle.destination.x - particle.x) * particle.speed;
            particle.y += (particle.destination.y - particle.y) * particle.speed;
            particle.z += (particle.destination.z - particle.z) * particle.speed;
          }

          if (delta - previousTime > thickness) {
            var index = Math.floor(Math.random() * particles.geometry.vertices.length);
            var particle1 = particles.geometry.vertices[index];
            var particle2 = particles.geometry.vertices[particles.geometry.vertices.length - index];
            TweenMax.to(particle, Math.random() * 2 + 1, {
              x: particle2.x,
              y: particle2.y,
              ease: Power2.easeInOut
            });
            TweenMax.to(particle2, Math.random() * 2 + 1, {
              x: particle1.x,
              y: particle1.y,
              ease: Power2.easeInOut
            });
            previousTime = delta;
          }

          particles.geometry.verticesNeedUpdate = true;
        }

        if (!isMouseDown) {
          camera.position.x += (0 - camera.position.x) * 0.06;
          camera.position.y += (0 - camera.position.y) * 0.06;
        }

        camera.position.x += (mouseX - camera.position.x) * 0.09;
        camera.position.y += (-mouseY - camera.position.y) * 0.09;
        if (camera.position.y < -60) camera.position.y = -60;
        camera.lookAt(centerVector); //particle rotation

        particleRotation.rotation.x += 0.0000;
        particleRotation.rotation.y -= 0.0040; //---
        // 
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var _i = 0; _i < sceneSubjects.length; _i++) {
          sceneSubjects[_i].update(clock.getElapsedTime() * 1);
        } //---
        // 
        //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;

        if (isMouseDown) {
          camera.position.x += (event.clientX - lastMousePos.x) / 100;
          camera.position.y -= (event.clientY - lastMousePos.y) / 100;
          camera.lookAt(centerVector);
          lastMousePos = {
            x: event.clientX,
            y: event.clientY
          };
        }
      }

      function onDocumentTouchStart(event) {
        if (event.touches.length == 1) {
          event.preventDefault();
          mouseX = event.touches[0].pageX - windowHalfX;
          mouseY = event.touches[0].pageY - windowHalfY;
        }
      }

      function onDocumentTouchMove(event) {
        if (event.touches.length == 1) {
          event.preventDefault();
          mouseX = event.touches[0].pageX - windowHalfX;
          mouseY = event.touches[0].pageY - windowHalfY;
        }
      }

      function onDocumentMouseUp() {
        isMouseDown = false;
      }

      function onDocumentMouseDown(event) {
        isMouseDown = true;
        lastMousePos = {
          x: event.clientX,
          y: event.clientY
        };
      }
      /*
       * Get Image Data when Draw Image To Canvas
       *
       * @param  {!Element} image         - Overridden with a record type holding data, width and height.
       * @return {Object}                 - The image data via JSON.
       */


      function getImageData(image) {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);
        return ctx.getImageData(0, 0, image.width, image.height);
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_PARTICLE.documentReady);
  return function THREE_PARTICLE() {
    simple_3D_particle_effect_js_classCallCheck(this, THREE_PARTICLE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-sphere-three/js/index.js
function simple_3D_sphere_three_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Sphere Rotation -->
 *************************************
 */

/**
 * module.THREE_SPHERE_THREE
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */


var THREE_SPHERE_THREE = function (module, $, window, document) {
  if (window.THREE_SPHERE_THREE === null) return false;
  module.THREE_SPHERE_THREE = module.THREE_SPHERE_THREE || {};
  module.THREE_SPHERE_THREE.version = '0.0.2';

  module.THREE_SPHERE_THREE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-sphere-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-sphere-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera, controls, scene, light, renderer, displacementSprite;

      function init() {
        // camera
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 100);
        camera.position.set(0, -46, 18); // controls

        controls = new THREE.OrbitControls(camera);
        controls.minDistance = 10;
        controls.maxDistance = 50; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // axes
        //scene.add( new THREE.AxisHelper( 20 ) );
        // geometry

        var geometry = new THREE.SphereGeometry(3, 32, 32); // material, we create the material when the texture is loaded

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        var texture = loader.load('https://placekitten.com/1650/1650'),
            material = new THREE.MeshBasicMaterial({
          map: texture
        }); // parent

        displacementSprite = new THREE.Object3D();
        scene.add(displacementSprite); // pivots

        var pivot1 = new THREE.Object3D(),
            pivot2 = new THREE.Object3D(),
            pivot3 = new THREE.Object3D();
        pivot1.rotation.z = 0;
        pivot2.rotation.z = 2 * Math.PI / 3;
        pivot3.rotation.z = 4 * Math.PI / 3;
        displacementSprite.add(pivot1);
        displacementSprite.add(pivot2);
        displacementSprite.add(pivot3); // mesh

        var mesh1 = new THREE.Mesh(geometry, material),
            mesh2 = new THREE.Mesh(geometry, material),
            mesh3 = new THREE.Mesh(geometry, material);
        mesh1.position.y = 5;
        mesh2.position.y = 15;
        mesh3.position.y = 25;
        pivot1.add(mesh1);
        pivot2.add(mesh2);
        pivot3.add(mesh3); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        displacementSprite.rotation.z += 0.01; //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_SPHERE_THREE.documentReady);
  return function THREE_SPHERE_THREE() {
    simple_3D_sphere_three_js_classCallCheck(this, THREE_SPHERE_THREE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-obj-anim-interaction/js/index.js
function simple_3D_obj_anim_interaction_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Object Anim When Click -->
 *************************************
 */


var THREE_OBJ_ANIM_INTERACTION = function (module, $, window, document) {
  if (window.THREE_OBJ_ANIM_INTERACTION === null) return false;
  module.THREE_OBJ_ANIM_INTERACTION = module.THREE_OBJ_ANIM_INTERACTION || {};
  module.THREE_OBJ_ANIM_INTERACTION.version = '0.0.3';

  module.THREE_OBJ_ANIM_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-object-buttonevent-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-object-buttonevent-canvas';
      var renderer, scene, controls, camera, targetObj, parent, material, segLength;
      var radius = 3,
          height = 6,
          segments = 200; //segments must be even

      function init() {
        // Create a camera, which defines where we're looking at.		
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //Scene

        scene = new THREE.Scene(); //camera

        camera = new THREE.PerspectiveCamera(70, windowWidth / windowHeight, 1, 100);
        camera.position.set(1, 1, 22); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', function () {
          renderer.render(scene, camera);
        }, false);
        controls.enableZoom = false;
        controls.enablePan = false; // Immediately use the texture for material creation

        material = new THREE.MeshPhongMaterial({
          color: 0xEB6D35,
          specular: 0xEB6D35,
          shininess: 15,
          flatShading: THREE.FlatShading,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: .8
        }); //HemisphereLight

        var light1 = new THREE.DirectionalLight(0xffffff);
        light1.position.set(-5, 10, 10);
        var light2 = new THREE.PointLight(0xffffff, .7, 0);
        light2.position.set(5, 5, -5);
        scene.add(light1, light2); //put the target object inside a parent object so the manipulation is easier

        parent = new THREE.Object3D();
        addObject();
        parent.position.set(-radius, height / 2, 0);
        parent.rotation.y = Math.PI;
        scene.add(parent);
        renderer.render(scene, camera);
      }

      function addObject() {
        var geo = new THREE.Geometry();
        segLength = Math.PI * 2 * radius / segments;
        geo.vertices.push(new THREE.Vector3(0, height / 2, 0));
        geo.vertices.push(new THREE.Vector3(0, -height / 2, 0));

        for (var i = 0; i < Math.floor(segments / 2); i++) {
          geo.vertices.push(new THREE.Vector3(0, height / 2, segLength * i));
          geo.vertices.push(new THREE.Vector3(0, -height / 2, segLength * i));
          geo.vertices.push(new THREE.Vector3(0, height / 2, -segLength * i));
          geo.vertices.push(new THREE.Vector3(0, -height / 2, -segLength * i));
        }

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(1, 2, 3));
        geo.faces.push(new THREE.Face3(0, 1, 4));
        geo.faces.push(new THREE.Face3(1, 4, 5));

        for (var _i = 1; _i < Math.floor(segments / 2); _i++) {
          geo.faces.push(new THREE.Face3(2 + (_i - 1) * 4, 3 + (_i - 1) * 4, 6 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(3 + (_i - 1) * 4, 6 + (_i - 1) * 4, 7 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(4 + (_i - 1) * 4, 5 + (_i - 1) * 4, 8 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(5 + (_i - 1) * 4, 8 + (_i - 1) * 4, 9 + (_i - 1) * 4));
        }

        targetObj = new THREE.Mesh(geo, material);
        parent.add(targetObj);
      }

      function render() {
        requestAnimationFrame(render); //upodate object

        targetObj.geometry.verticesNeedUpdate = true; //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      $('#3D-object-button1').on('click', function (e) {
        e.preventDefault();
        var theta = 55,
            x = camera.position.x,
            z = camera.position.z,
            moveX = x * Math.cos(theta) - z * Math.sin(theta),
            moveZ = z * Math.cos(theta) + x * Math.sin(theta);
        TweenMax.to(camera.position, 1.5, {
          x: moveX,
          z: moveZ,
          ease: Power0.easeNone,
          onUpdate: function onUpdate() {}
        });
      });
      $('#3D-object-button2').on('click', function (e) {
        e.preventDefault(); //1. tween the first segment of each side

        var w = targetObj.geometry.vertices;
        w[2].x = w[3].x = w[4].x = w[5].x = -Math.sin(0) * segLength;
        w[2].z = w[3].z = Math.cos(0) * segLength;
        w[4].z = w[5].z = -Math.cos(0) * segLength; //2. rest of the vertex can now refer to the fourth previous vertex, their reference in the algorithm

        for (var i = 6; i < w.length; i++) {
          //which segment from the origin the vertex belongs to
          var vIndex = i,
              segIndex = Math.floor((vIndex + 2) / 4),
              negate = vIndex / 4 === Math.floor(vIndex / 4) || (vIndex - 1) / 4 === Math.floor((vIndex - 1) / 4) ? -1 : 1;
          var tx = w[vIndex - 4].x - Math.sin(vIndex * (negate * (2 * segIndex - 1))) * segLength * negate;
          var tz = w[vIndex - 4].z + Math.cos(vIndex * (negate * (2 * segIndex - 1))) * segLength * negate;
          TweenMax.to(w[vIndex], 1.5, {
            x: tx,
            z: tz,
            ease: Power0.easeNone,
            onUpdate: function onUpdate() {}
          });
        }
      });
      $('#3D-object-button3').on('click', function (e) {
        e.preventDefault();
        var scaleTo = Math.floor(Math.random() * Math.floor(3));
        TweenMax.to(targetObj.scale, 1.5, {
          x: scaleTo,
          y: scaleTo,
          z: scaleTo,
          ease: Power0.easeNone,
          onUpdate: function onUpdate() {}
        });
      }); // 
      //-------------------------------------	

      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_OBJ_ANIM_INTERACTION.documentReady);
  return function THREE_OBJ_ANIM_INTERACTION() {
    simple_3D_obj_anim_interaction_js_classCallCheck(this, THREE_OBJ_ANIM_INTERACTION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-mouse-interaction/js/index.js
function simple_3D_mouse_interaction_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Mouse Interaction with three.js -->
 *************************************
 */


var THREE_MOUSE_INTERACTION = function (module, $, window, document) {
  if (window.THREE_MOUSE_INTERACTION === null) return false;
  module.THREE_MOUSE_INTERACTION = module.THREE_MOUSE_INTERACTION || {};
  module.THREE_MOUSE_INTERACTION.version = '0.0.3';

  module.THREE_MOUSE_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-mouseinteraction-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-mouseinteraction-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          radius = 100,
          theta = 0,
          clickEnable = false;
      var mouseVector = new THREE.Vector2();
      var raycaster,
          intersects,
          INTERSECTED,
          nucleus,
          atoms = [];

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1300); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = true;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        generateGeometry('poly', 15); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        raycaster = new THREE.Raycaster();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.getElementById(rendererCanvasID).addEventListener('click', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000); //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xff0000);
          }
        } else {
          // restore previous intersection object (if it exists) to its original color
          if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex); //by setting current intersection object to "nothing"

          INTERSECTED = null;
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        clickEnable = true; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0 && intersects[0].object.name.indexOf('nucleus') >= 0) {
          var _obj = intersects[0].object;
          console.log(_obj.name); //---Change object size
          //				if ( typeof intersects[ 0 ] != typeof undefined ) {
          //					const obj = intersects[ 0 ].object;
          //
          //
          //					TweenMax.to( obj.scale, 1, {
          //						x: '+=' + ( 200 - obj.scale.x ) * 0.05,
          //						y: '+=' + ( 200 - obj.scale.y ) * 0.05,
          //						z: '+=' + ( 200 - obj.scale.z ) * 0.05
          //					});	
          //
          //
          //					obj.updateMatrix();	
          //	
          //				}
          //---Change object position

          var targetAtomPos = _obj.position;
          console.log(targetAtomPos); // targetAtomPos.tween.pause();

          var destinationPos = targetAtomPos.clone();
          TweenMax.to(controls.target, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z
          });
          TweenMax.to(camera.position, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z + 100,
            onUpdate: function onUpdate() {
              camera.up.set(0, 1, 0);
              camera.updateProjectionMatrix();
            },
            onComplete: function onComplete() {
              // get object new coordinates
              var screenData = nestedObjectToScreenXYZAndWH(_obj, camera, renderer.domElement.width, renderer.domElement.height);
              console.log("Current object coordinates: {x: ".concat(screenData.position.x, ", y: ").concat(screenData.position.y, ", z: ").concat(screenData.position.z, " }"));
            }
          });
        } else {
          //Change object position
          TweenMax.to(controls.target, 2, {
            x: 0,
            y: 0,
            z: 0,
            onComplete: function onComplete() {
              TweenMax.resumeAll();
            }
          });
        }
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        theta = 0;
        clickEnable = false;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {String} objectType     - String of geometry type identifier.
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(objectType, numObjects) {
        //set color
        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var geometry = void 0;

          if (objectType == "cube") {
            geometry = new THREE.BoxGeometry(1, 1, 1);
          } else if (objectType == "sphere") {
            geometry = new THREE.IcosahedronGeometry(1, 1);
          } else if (objectType == "poly") {
            geometry = new THREE.CylinderGeometry(3, 6, 3, 5, 1);
          }

          var position = new THREE.Vector3();
          position.x = Math.random() * 500;
          position.y = Math.random() * 400;
          position.z = Math.random() * 300;
          var rotation = new THREE.Euler();
          rotation.x = Math.random() * 2 * Math.PI;
          rotation.y = Math.random() * 2 * Math.PI;
          rotation.z = Math.random() * 2 * Math.PI;
          var scale = new THREE.Vector3(); // give the geom's vertices a random color, to be displayed

          var color = new THREE.Color();
          color.setRGB(Math.random(), Math.random(), Math.random());
          applyVertexColors(geometry, color); // Immediately use the texture for material creation

          var defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            flatShading: true,
            vertexColors: THREE.VertexColors
          });
          displacementSprite = new THREE.Mesh(geometry, defaultMaterial);
          displacementSprite.name = 'nucleus-' + i;
          displacementSprite.position.x = Math.random() * 800 - 400;
          displacementSprite.position.y = Math.random() * 800 - 400;
          displacementSprite.position.z = Math.random() * 800 - 400;
          displacementSprite.rotation.x = Math.random() * 2 * Math.PI;
          displacementSprite.rotation.y = Math.random() * 2 * Math.PI;
          displacementSprite.rotation.z = Math.random() * 2 * Math.PI;
          displacementSprite.scale.x = Math.random() + 5;
          displacementSprite.scale.y = Math.random() + 5;
          displacementSprite.scale.z = Math.random() + 5;
          scene.add(displacementSprite);
          atoms.push(displacementSprite);
        }
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MOUSE_INTERACTION.documentReady);
  return function THREE_MOUSE_INTERACTION() {
    simple_3D_mouse_interaction_js_classCallCheck(this, THREE_MOUSE_INTERACTION);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-mouse-interaction2/js/index.js
function simple_3D_mouse_interaction2_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Mouse Interaction with three.js -->
 *************************************
 */

var THREE_MOUSE_INTERACTION2 = function (module, $, window, document) {
  if (window.THREE_MOUSE_INTERACTION2 === null) return false;
  module.THREE_MOUSE_INTERACTION2 = module.THREE_MOUSE_INTERACTION2 || {};
  module.THREE_MOUSE_INTERACTION2.version = '0.0.5';

  module.THREE_MOUSE_INTERACTION2.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-mouseinteraction2-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-mouseinteraction2-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0,
          clickEnable = false; // controls

      var scroller = new CameraScroller({
        direction: "y"
      }); // mouse

      var mouseVector = new THREE.Vector2();
      var raycaster,
          intersects,
          INTERSECTED,
          nucleus,
          atoms = [];

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(70, windowWidth / windowHeight, 1, 50000);
        camera.position.set(0, 0, 20000); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        scroller.init(renderer.domElement); // Immediately use the texture for material creation

        generateGeometry(500); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        raycaster = new THREE.Raycaster();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.getElementById(rendererCanvasID).addEventListener('click', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render); //To set a background color.

        renderer.setClearColor(0x000000); //update controls

        camera.position.y = scroller.getScrollPosY() * 10000; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xff0000);
          }
        } else {
          // restore previous intersection object (if it exists) to its original color
          if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex); //by setting current intersection object to "nothing"

          INTERSECTED = null;
        } //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */


        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        clickEnable = true; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0 && intersects[0].object.name.indexOf('nucleus') >= 0) {
          var _obj = intersects[0].object;
          var targetAtomPos = _obj.position;
          console.log(targetAtomPos); // targetAtomPos.tween.pause();

          var destinationPos = targetAtomPos.clone(); // jump to new position
          // y movement via scroller object
          // x and z movement via TWEEN

          scroller.targetPosition = _obj.position.y / 10000;
          var targetPos = {
            x: _obj.position.x,
            y: _obj.position.y,
            z: _obj.position.z + 1100
          };
          TweenMax.to(targetPos, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z
          });
          TweenMax.to(camera.position, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z + 1000,
            onUpdate: function onUpdate() {
              camera.up.set(0, 1, 0);
              camera.updateProjectionMatrix();
            },
            onComplete: function onComplete() {
              // get object new coordinates
              var screenData = nestedObjectToScreenXYZAndWH(_obj, camera, renderer.domElement.width, renderer.domElement.height);
              console.log("Current object coordinates: {x: ".concat(screenData.position.x, ", y: ").concat(screenData.position.y, ", z: ").concat(screenData.position.z, " }"));
            }
          });
        } else {
          //restore scroller position
          scroller.targetPosition = 0; //restore camera position

          TweenMax.to(camera.position, 2, {
            x: 0,
            y: 0,
            z: 20000,
            onComplete: function onComplete() {
              TweenMax.resumeAll();
            }
          });
        }
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        theta = 0;
        clickEnable = false;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(numObjects) {
        var geometry = new THREE.Geometry();

        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var geom = void 0;
          var color = new THREE.Color();
          var position = new THREE.Vector3();
          position.x = -9000 + i % 10 * 2000;
          position.y = -9000 + Math.floor(i % 100 / 10) * 2000;
          position.z = -1000 + Math.floor(i / 100) * 2000;
          var rotation = new THREE.Euler();
          rotation.x = 0;
          rotation.y = 0;
          rotation.z = 0;
          var scale = new THREE.Vector3();
          scale.x = 1200;
          scale.y = 600;
          scale.z = 200;
          geom = new THREE.BoxGeometry(1, 1, 1);
          color.setRGB(0, 0, Math.random() + 0.1); // give the geom's vertices a random color, to be displayed

          applyVertexColors(geom, color); // Immediately use the texture for material creation

          var defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            flatShading: true,
            vertexColors: THREE.VertexColors
          });
          displacementSprite = new THREE.Mesh(geom, defaultMaterial);
          scene.add(displacementSprite);
          var object = new THREE.Mesh(geom);
          displacementSprite.name = 'nucleus-' + i;
          displacementSprite.position.copy(position);
          displacementSprite.rotation.copy(rotation);
          displacementSprite.scale.copy(scale);
          displacementSprite.updateMatrix();
          scene.add(displacementSprite);
          atoms.push(displacementSprite);
        }
      }
      /*
       * CameraSroller
       * Scrolls the camera vertically (up/down) by mouse, scrollwhell and touch
       * including a velocity based animation
       */


      function CameraScroller(options) {
        this.targetPosition = 0;
        this.targetPositionOnMouseDown = 0;
        this.mouseY = 0;
        this.mouseYOnMouseDown = 0;
        this.scrollPosY = 0;
        this.domElem = undefined;

        this.init = function (domEl) {
          this.domElem = domEl;
          this.domElem.addEventListener('mousedown', this.onDocumentMouseDown, false);
          this.domElem.addEventListener('touchstart', this.onDocumentTouchStart, browser.supportsPassive ? {
            passive: true
          } : false);
          this.domElem.addEventListener('touchmove', this.onDocumentTouchMove, browser.supportsPassive ? {
            passive: true
          } : false);
          this.domElem.addEventListener('wheel', this.onDocumentMousewheel, browser.supportsPassive ? {
            passive: true
          } : false);
        };

        this.onDocumentMouseDown = function (event) {
          event.preventDefault();
          this.domElem.addEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.addEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.addEventListener('mouseout', this.onDocumentMouseOut, false);
          this.mouseYOnMouseDown = event.clientY;
          this.targetPositionOnMouseDown = this.targetPosition;
        }.bind(this);

        this.onDocumentMouseMove = function (event) {
          this.mouseY = event.clientY;
          this.targetPosition = this.targetPositionOnMouseDown + (this.mouseY - this.mouseYOnMouseDown) * 0.02;
        }.bind(this);

        this.onDocumentMouseUp = function (event) {
          this.domElem.removeEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.removeEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.removeEventListener('mouseout', this.onDocumentMouseOut, false);
        }.bind(this);

        this.onDocumentMouseOut = function (event) {
          this.domElem.removeEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.removeEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.removeEventListener('mouseout', this.onDocumentMouseOut, false);
        }.bind(this);

        this.onDocumentTouchStart = function (event) {
          if (event.touches.length == 1) {
            event.preventDefault();
            this.mouseYOnMouseDown = event.touches[0].pageY;
            this.targetPositionOnMouseDown = this.targetPosition;
          }
        }.bind(this);

        this.onDocumentTouchMove = function (event) {
          if (event.touches.length == 1) {
            event.preventDefault();
            this.mouseY = event.touches[0].pageY;
            this.targetPosition = this.targetPositionOnMouseDown + (this.mouseY - this.mouseYOnMouseDown) * 0.02;
          }
        }.bind(this);

        this.onDocumentMousewheel = function (event) {
          this.targetPosition = this.targetPosition + event.wheelDeltaY * 0.005;
        }.bind(this);

        this.getScrollPosY = function () {
          this.scrollPosY = this.scrollPosY + (this.targetPosition - this.scrollPosY) * 0.05; // 0.05=long scroll delay, 0.15=short delay

          return this.scrollPosY;
        }.bind(this);
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MOUSE_INTERACTION2.documentReady);
  return function THREE_MOUSE_INTERACTION2() {
    simple_3D_mouse_interaction2_js_classCallCheck(this, THREE_MOUSE_INTERACTION2);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/modifiers/ExplodeModifier.js
/**
 * Make all faces use unique vertices
 * so that each face can be separated from others
 *
 * @author alteredq / http://alteredqualia.com/
 */
THREE.ExplodeModifier = function () {};

THREE.ExplodeModifier.prototype.modify = function (geometry) {
  var vertices = [];

  for (var i = 0, il = geometry.faces.length; i < il; i++) {
    var n = vertices.length;
    var face = geometry.faces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var va = geometry.vertices[a];
    var vb = geometry.vertices[b];
    var vc = geometry.vertices[c];
    vertices.push(va.clone());
    vertices.push(vb.clone());
    vertices.push(vc.clone());
    face.a = n;
    face.b = n + 1;
    face.c = n + 2;
  }

  geometry.vertices = vertices;
};

/* harmony default export */ var ExplodeModifier = (THREE.ExplodeModifier);
// EXTERNAL MODULE: ./src/components/simple-3D-shatter-slider/scss/_style.scss
var simple_3D_shatter_slider_scss_style = __webpack_require__(70);

// CONCATENATED MODULE: ./src/components/simple-3D-shatter-slider/js/index.js
function simple_3D_shatter_slider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_shatter_slider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_shatter_slider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_shatter_slider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_shatter_slider_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Shatter Slider -->
 *************************************
 */

/**
 * module.THREE_SHATTER_SLIDER
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */




var THREE_SHATTER_SLIDER = function (module, $, window, document) {
  if (window.THREE_SHATTER_SLIDER === null) return false;
  module.THREE_SHATTER_SLIDER = module.THREE_SHATTER_SLIDER || {};
  module.THREE_SHATTER_SLIDER.version = '0.0.9';

  module.THREE_SHATTER_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--shatter').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--shatter'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--shatter__loader',
          rendererOuterID = 'uix-3d-slider--shatter__canvas-container',
          rendererCanvasID = 'uix-3d-slider--shatter__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          theta = 0;
      var offsetWidth = 475,
          //Set the display width of the objects in the Stage
      offsetHeight = 375,
          //Set the display height of the objects in the Stage
      allSources = [],
          objTotal,
          objLoaded = false;
      var sources = [];
      var isAnimating = false; // constants

      var activeSlider = 0;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--shatter__item'),
              $first = $items.first(),
              itemTotal = $items.length,
              activated = $this.data('activated');

          if (simple_3D_shatter_slider_js_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now');
            if (simple_3D_shatter_slider_js_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-3d-slider--shatter__pagination';
            if (simple_3D_shatter_slider_js_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--shatter__arrows';
            if (simple_3D_shatter_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false;
            if (simple_3D_shatter_slider_js_typeof(dataFilterTexture) === ( true ? "undefined" : undefined) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if (simple_3D_shatter_slider_js_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
            if (simple_3D_shatter_slider_js_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined)) dataDraggableCursor = 'move'; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if (simple_3D_shatter_slider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
            if (simple_3D_shatter_slider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
            if (simple_3D_shatter_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--shatter__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--shatter__arrows--prev"></a><a href="#" class="uix-3d-slider--shatter__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowHeight + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--shatter__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if (simple_3D_shatter_slider_js_typeof(dataSpeed) != ( true ? "undefined" : undefined) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if (simple_3D_shatter_slider_js_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = _item.attr('src');

                if (simple_3D_shatter_slider_js_typeof(videoURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if (simple_3D_shatter_slider_js_typeof(imgURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--shatter__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--shatter__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function init() {
        //Core 3D stage begin
        //-------------------------------------		
        //camera
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 10, 2500); // FlyCamera // FlyControls

        camera.movementSpeed = 100.0;
        camera.rollSpeed = 0.5;
        camera.position.y = 60;
        camera.position.z = 500; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.target.set(0, 0, 0);
        controls.update(); //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        objTotal = sources.length;
        sources.forEach(function (element, index) {
          if (element.type == 'img') {
            loader.load( // resource URL
            element.url, // onLoad callback
            function (texture) {
              loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
            }, // onProgress callback currently not supported
            undefined, // onError callback
            function (err) {
              console.error('An error happened.');
            });
          } else {
            var texture = new THREE.VideoTexture(document.getElementById(element.id));
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat; // pause the video

            texture.image.autoplay = true;
            texture.image.loop = true;
            texture.image.currentTime = 0;
            texture.image.muted = false;
            texture.image.pause();
            loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
          }
        }); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //Animating Three.js vertices

        allSources.forEach(function (element, index) {
          element.geometry.verticesNeedUpdate = true;
        }); //check all images loaded

        if (simple_3D_shatter_slider_js_typeof(allSources) != ( true ? "undefined" : undefined)) {
          if (!objLoaded && allSources.length === objTotal) {
            allSources.forEach(function (element, index) {
              scene.add(element); //if the first object is video and play it

              if (index == 0) {
                var videoObCur = element.material.map.image;

                if (videoObCur.localName == 'video') {
                  videoObCur.autoplay = true;
                  videoObCur.currentTime = 0;
                  videoObCur.muted = true;
                  videoObCur.play();
                }
              } //initialize all objects


              if (index > 0) {
                var fragment = element.geometry.vertices;

                for (var i = 0; i < fragment.length; i++) {
                  var pos = new THREE.Vector3();

                  var _final = Math.random();

                  pos.x = Math.random();
                  pos.y = Math.random() * (50 * i);
                  pos.z = Math.random() * -300;
                  fragment[i].x = pos.x;
                  fragment[i].y = pos.y;
                  fragment[i].z = pos.z;
                }
              }

              console.log(element);
            });
            objLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      /*
       * Load Source
       *
       * @param  {Three.MeshBasicMaterial.map} texture         - Returns a new texture object which can directly be used for material creation.
       * @param  {Number} index           - Index of image or video.
       * @param  {Number} w               - The width of an image or video, in pixels. 
       * @param  {Number} h               - The height of an image or video, in pixels. 
       * @param  {Number} total           - Total number of preload images or video.
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */


      function loadSource(texture, index, w, h, total, loading) {
        var imgW = w,
            imgH = h; // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        var geometryExplode = new THREE.BoxGeometry(imgW, imgH, 13),
            displacementSprite = new THREE.Mesh(geometryExplode, material);
        displacementSprite.minFilter = THREE.LinearFilter;
        displacementSprite.overdraw = true;
        displacementSprite.position.set(0, 0, 0);
        geometryExplode.center(); // Shattering Images

        var explodeModifier = new THREE.ExplodeModifier();
        explodeModifier.modify(geometryExplode); // add some additional vars to the
        // fragments to ensure we can do physics
        // and so on

        for (var i = 0; i < geometryExplode.vertices.length; i++) {
          var fragment = geometryExplode.vertices[i];
          fragment.origPos = {
            x: fragment.x,
            y: fragment.y,
            z: fragment.z
          };
        }

        allSources.push(displacementSprite); //loading

        TweenMax.to(loading, 0.5, {
          width: Math.round(100 * allSources.length / total) + '%',
          onComplete: function onComplete() {
            if ($(this.target).width() >= windowWidth - 50) {
              TweenMax.to(this.target, 0.5, {
                alpha: 0
              });
            }
          }
        });
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--shatter__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--shatter__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--shatter__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--shatter__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--shatter__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--shatter__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Pause all videos
          //-------------------------------------
          // pause all videos

          allSources.forEach(function (element, index) {
            var videoOb = element.material.map.image;

            if (videoOb.localName == 'video') {
              videoOb.autoplay = false;
              videoOb.currentTime = 0;
              videoOb.muted = true;
              videoOb.pause();
            }
          }); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId;

          if (simple_3D_shatter_slider_js_typeof(allSources[slideNextId]) != ( true ? "undefined" : undefined)) {
            var fragment = allSources[slideNextId].geometry.vertices;

            for (var i = 0; i < fragment.length; i++) {
              TweenMax.to(fragment[i], 2, {
                x: fragment[i].origPos.x,
                y: fragment[i].origPos.y,
                z: fragment[i].origPos.z,
                ease: "Expo.easeInOut"
              });
            }
          } // play the video


          var videoObCur = allSources[slideNextId].material.map.image;

          if (videoObCur.localName == 'video') {
            videoObCur.autoplay = true;
            videoObCur.currentTime = 0;
            videoObCur.muted = false;
            videoObCur.play();
          } //Fire the current object
          //-------------------------------------


          if (simple_3D_shatter_slider_js_typeof(allSources[slideCurId]) != ( true ? "undefined" : undefined)) {
            var _fragment = allSources[slideCurId].geometry.vertices;

            for (var _i = 0; _i < _fragment.length; _i++) {
              var pos = new THREE.Vector3();

              var _final2 = Math.random();

              pos.x = Math.random();
              pos.y = Math.random() * (50 * _i);
              pos.z = Math.random() * -300;
              TweenMax.to(_fragment[_i], 2, {
                x: pos.x,
                y: pos.y,
                z: pos.z,
                ease: "Expo.easeInOut",
                onComplete: function onComplete() {
                  //reset the trigger
                  isAnimating = false;
                }
              });
            }
          }
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        wrapperInit: wrapperInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit();
    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_SHATTER_SLIDER.documentReady);
  return function THREE_SHATTER_SLIDER() {
    simple_3D_shatter_slider_js_classCallCheck(this, THREE_SHATTER_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/simple-3D-explosive-particle-slider/scss/_style.scss
var simple_3D_explosive_particle_slider_scss_style = __webpack_require__(71);

// CONCATENATED MODULE: ./src/components/simple-3D-explosive-particle-slider/js/index.js
function simple_3D_explosive_particle_slider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_explosive_particle_slider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_explosive_particle_slider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_explosive_particle_slider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_explosive_particle_slider_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Explosive Particle Slider -->
 *************************************
 */



var THREE_EXP_PARTICLE_SLIDER = function (module, $, window, document) {
  if (window.THREE_EXP_PARTICLE_SLIDER === null) return false;
  module.THREE_EXP_PARTICLE_SLIDER = module.THREE_EXP_PARTICLE_SLIDER || {};
  module.THREE_EXP_PARTICLE_SLIDER.version = '0.0.9';

  module.THREE_EXP_PARTICLE_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--expParticle').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--expParticle'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--expParticle__loader',
          rendererOuterID = 'uix-3d-slider--expParticle__canvas-container',
          rendererCanvasID = 'uix-3d-slider--expParticle__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          clock = new THREE.Clock();
      var offsetWidth = 475,
          //Set the display width of the objects in the Stage
      offsetHeight = 375,
          //Set the display height of the objects in the Stage
      allSources = [],
          objTotal,
          objLoaded = false;
      var sources = [];
      var isAnimating = false; // constants

      var activeSlider = 0;
      var cube_count,
          meshes = [],
          materials = [],
          xgrid = 25,
          ygrid = 15;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--expParticle__item'),
              $first = $items.first(),
              itemTotal = $items.length,
              activated = $this.data('activated');

          if (simple_3D_explosive_particle_slider_js_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now');
            if (simple_3D_explosive_particle_slider_js_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-3d-slider--expParticle__pagination';
            if (simple_3D_explosive_particle_slider_js_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--expParticle__arrows';
            if (simple_3D_explosive_particle_slider_js_typeof(dataFilterTexture) === ( true ? "undefined" : undefined) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if (simple_3D_explosive_particle_slider_js_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
            if (simple_3D_explosive_particle_slider_js_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined)) dataDraggableCursor = 'move';
            if (simple_3D_explosive_particle_slider_js_typeof(dataCountTotal) === ( true ? "undefined" : undefined)) dataCountTotal = 'p.count em.count';
            if (simple_3D_explosive_particle_slider_js_typeof(dataCountCur) === ( true ? "undefined" : undefined)) dataCountCur = 'p.count em.current'; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if (simple_3D_explosive_particle_slider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
            if (simple_3D_explosive_particle_slider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
            if (simple_3D_explosive_particle_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--expParticle__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--expParticle__arrows--prev"></a><a href="#" class="uix-3d-slider--expParticle__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowHeight + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--expParticle__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if (simple_3D_explosive_particle_slider_js_typeof(dataSpeed) != ( true ? "undefined" : undefined) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if (simple_3D_explosive_particle_slider_js_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = _item.attr('src');

                if (simple_3D_explosive_particle_slider_js_typeof(videoURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if (simple_3D_explosive_particle_slider_js_typeof(imgURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--expParticle__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--expParticle__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function init() {
        //Core 3D stage begin
        //-------------------------------------		
        //camera
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 10, 2500); // FlyCamera // FlyControls

        camera.movementSpeed = 100.0;
        camera.rollSpeed = 0.5;
        camera.position.y = 60;
        camera.position.z = 500; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.target.set(0, 0, 0);
        controls.update(); //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        objTotal = sources.length;
        sources.forEach(function (element, index) {
          if (element.type == 'img') {
            loader.load( // resource URL
            element.url, // onLoad callback
            function (texture) {
              loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
            }, // onProgress callback currently not supported
            undefined, // onError callback
            function (err) {
              console.error('An error happened.');
            });
          } else {
            var texture = new THREE.VideoTexture(document.getElementById(element.id));
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat; // pause the video

            texture.image.autoplay = true;
            texture.image.loop = true;
            texture.image.currentTime = 0;
            texture.image.muted = true;
            texture.image.play();
            loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
          }
        }); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var elapsed = clock.getElapsedTime(); //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //Display the destination object

        if (simple_3D_explosive_particle_slider_js_typeof(allSources[activeSlider]) != ( true ? "undefined" : undefined)) {
          var objects = allSources[activeSlider].children;
          var speed = Math.random() * .0002;

          for (var i = 0; i < objects.length; i++) {
            for (var j = 0; j < objects[i].parent.children.length; j++) {
              var obj = objects[i].parent.children[j];
              obj.position.x += (obj.origPos.x - obj.position.x) * speed;
              obj.position.y += (obj.origPos.y - obj.position.y) * speed;
              obj.position.z += (obj.origPos.z - obj.position.z) * speed;
            }
          }
        } //Hide inactive objects


        allSources.forEach(function (element, index) {
          if (index != activeSlider) {
            var _objects = element.children;

            var _speed = Math.random() * .00005;

            for (var _i = 0; _i < _objects.length; _i++) {
              for (var _j = 0; _j < _objects[_i].parent.children.length; _j++) {
                var _obj = _objects[_i].parent.children[_j];
                _obj.position.x += (_obj.targetPos.x - _obj.position.x) * _speed;
                _obj.position.y += (_obj.targetPos.y - _obj.position.y) * _speed;
                _obj.position.z += (_obj.targetPos.z - _obj.position.z) * _speed;
              }
            }
          }
        }); //check all images loaded

        if (simple_3D_explosive_particle_slider_js_typeof(allSources) != ( true ? "undefined" : undefined)) {
          if (!objLoaded && allSources.length === objTotal) {
            allSources.forEach(function (element, index) {
              scene.add(element);
              console.log(element);
            });
            objLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var _i2 = 0; _i2 < sceneSubjects.length; _i2++) {
          sceneSubjects[_i2].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      /*
       * Load Source
       *
       * @param  {Three.MeshBasicMaterial.map} texture         - Returns a new texture object which can directly be used for material creation.
       * @param  {Number} index           - Index of image or video.
       * @param  {Number} w               - The width of an image or video, in pixels. 
       * @param  {Number} h               - The height of an image or video, in pixels. 
       * @param  {Number} total           - Total number of preload images or video.
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */


      function loadSource(texture, index, w, h, total, loading) {
        var imgW = w,
            imgH = h; //

        var group = new THREE.Object3D();
        var i, j, ux, uy, ox, oy, geometry, xsize, ysize;
        ux = 1 / xgrid;
        uy = 1 / ygrid;
        xsize = imgW / xgrid;
        ysize = imgH / ygrid;
        cube_count = 0;

        for (i = 0; i < xgrid; i++) {
          for (j = 0; j < ygrid; j++) {
            ox = i;
            oy = j;
            geometry = new THREE.BoxBufferGeometry(xsize, ysize, xsize);
            changeUVS(geometry, ux, uy, ox, oy);
            materials[cube_count] = new THREE.MeshBasicMaterial({
              map: texture
            });
            material = materials[cube_count];
            displacementSprite = new THREE.Mesh(geometry, material);
            displacementSprite.position.x = (i - xgrid / 2) * xsize;
            displacementSprite.position.y = (j - ygrid / 2) * ysize;
            displacementSprite.position.z = 0;
            displacementSprite.scale.x = displacementSprite.scale.y = displacementSprite.scale.z = 1;
            displacementSprite.origPos = {
              x: displacementSprite.position.x,
              y: displacementSprite.position.y,
              z: displacementSprite.position.z
            }; //hide all

            var newPosX = 4000 * Math.random() * (Math.random() > 0.5 ? 1 : -1);
            var newPosY = 2000 * Math.random();
            var newPosZ = 3000 * Math.random();
            displacementSprite.position.x = newPosX;
            displacementSprite.position.y = newPosY;
            displacementSprite.position.z = newPosZ;
            displacementSprite.targetPos = {
              x: newPosX,
              y: newPosY,
              z: newPosZ
            }; //

            group.add(displacementSprite); //

            meshes[cube_count] = displacementSprite;
            cube_count += 1;
          }
        }

        allSources.push(group); //loading

        TweenMax.to(loading, 0.5, {
          width: Math.round(100 * allSources.length / total) + '%',
          onComplete: function onComplete() {
            if ($(this.target).width() >= windowWidth - 50) {
              TweenMax.to(this.target, 0.5, {
                alpha: 0
              });
            }
          }
        });
      }

      function changeUVS(geometry, unitx, unity, offsetx, offsety) {
        var uvs = geometry.attributes.uv.array;

        for (var i = 0; i < uvs.length; i += 2) {
          uvs[i] = (uvs[i] + offsetx) * unitx;
          uvs[i + 1] = (uvs[i + 1] + offsety) * unity;
        }
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--expParticle__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--expParticle__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--expParticle__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--expParticle__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--expParticle__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--expParticle__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId; //Fire the current object
          //-------------------------------------
          //Reset the trigger
          //-------------------------------------

          isAnimating = false;
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        wrapperInit: wrapperInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit();
    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_EXP_PARTICLE_SLIDER.documentReady);
  return function THREE_EXP_PARTICLE_SLIDER() {
    simple_3D_explosive_particle_slider_js_classCallCheck(this, THREE_EXP_PARTICLE_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/shader/fragment-custom.glsl
/* harmony default export */ var js_shader_fragment_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform sampler2D disp;\n\n// uniform float time;\n// uniform float _rot;\nuniform float dispFactor;\nuniform float effectFactor;\n\n// vec2 rotate(vec2 v, float a) {\n//  float s = sin(a);\n//  float c = cos(a);\n//  mat2 m = mat2(c, -s, s, c);\n//  return m * v;\n// }\n\nvoid main() {\n\n    vec2 uv = vUv;\n\n    // uv -= 0.5;\n    // vec2 rotUV = rotate(uv, _rot);\n    // uv += 0.5;\n\n    vec4 disp = texture2D(disp, uv);\n\n    vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r*effectFactor), uv.y);\n    vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r*effectFactor), uv.y);\n\n    vec4 _texture = texture2D(texture, distortedPosition);\n    vec4 _texture2 = texture2D(texture2, distortedPosition2);\n\n    vec4 finalTexture = mix(_texture, _texture2, dispFactor);\n\n    gl_FragColor = finalTexture;\n    // gl_FragColor = disp;\n}");
// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/shader/vertex-custom.glsl
/* harmony default export */ var js_shader_vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}");
// EXTERNAL MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/scss/_style.scss
var simple_3D_liquid_scrollspy_slider_scss_style = __webpack_require__(72);

// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/index.js
function simple_3D_liquid_scrollspy_slider_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple_3D_liquid_scrollspy_slider_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { simple_3D_liquid_scrollspy_slider_js_typeof = function _typeof(obj) { return typeof obj; }; } else { simple_3D_liquid_scrollspy_slider_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return simple_3D_liquid_scrollspy_slider_js_typeof(obj); }

/* 
 *************************************
 * <!-- 3D Liquid Scrollspy Slider -->
 *************************************
 */




var THREE_LIQUID_SCROLLSPY_SLIDER = function (module, $, window, document) {
  if (window.THREE_LIQUID_SCROLLSPY_SLIDER === null) return false;
  module.THREE_LIQUID_SCROLLSPY_SLIDER = module.THREE_LIQUID_SCROLLSPY_SLIDER || {};
  module.THREE_LIQUID_SCROLLSPY_SLIDER.version = '0.1.3';

  module.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--liquid-scrollspy').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--liquid-scrollspy'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--liquid-scrollspy__loader',
          rendererOuterID = 'uix-3d-slider--liquid-scrollspy__canvas-container',
          rendererCanvasID = 'uix-3d-slider--liquid-scrollspy__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          theta = 0;
      var offsetWidth = 1920,
          //Set the display width of the objects
      offsetHeight = 1080,
          //Set the display height of the objects
      imgAspect = offsetHeight / offsetWidth;
      var dispImage;
      var loader = new THREE.TextureLoader();
      loader.crossOrigin = 'anonymous';
      var textures;
      var sources = [];
      var isAnimating = false; //scroll spy

      var scrollspyEnable, scrollspyConfigAutoAnim, scrollspyConfigItems, scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop; // constants

      var activeSlider = 0;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--liquid-scrollspy__item'),
              $first = $items.first(),
              itemTotal = $items.length,
              activated = $this.data('activated');

          if (simple_3D_liquid_scrollspy_slider_js_typeof(activated) === ( true ? "undefined" : undefined) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now'),
                dataScrollspy = $this.data('scrollspy');
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataControlsPagination) === ( true ? "undefined" : undefined)) dataControlsPagination = '.uix-3d-slider--liquid-scrollspy__pagination';
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataControlsArrows) === ( true ? "undefined" : undefined) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--liquid-scrollspy__arrows';
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false;
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataFilterTexture) === ( true ? "undefined" : undefined) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataDraggable) === ( true ? "undefined" : undefined)) dataDraggable = false;
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataDraggableCursor) === ( true ? "undefined" : undefined)) dataDraggableCursor = 'move';
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataScrollspy) === ( true ? "undefined" : undefined)) dataScrollspy = false; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataAuto) === ( true ? "undefined" : undefined)) dataAuto = false;
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataTiming) === ( true ? "undefined" : undefined)) dataTiming = 10000;
            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataLoop) === ( true ? "undefined" : undefined)) dataLoop = false; //Load displacement image

            dispImage = dataFilterTexture; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //scroll spy config

            scrollspyEnable = dataScrollspy;
            scrollspyConfigAutoAnim = $this[0].animatedSlides;
            scrollspyConfigItems = $items;
            scrollspyConfigCountTotal = dataCountTotal;
            scrollspyConfigCountCur = dataCountCur;
            scrollspyConfigControlsPagination = dataControlsPagination;
            scrollspyConfigControlsArrows = dataControlsArrows;
            scrollspyConfigLoop = dataLoop; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--liquid-scrollspy__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--liquid-scrollspy__arrows--prev"></a><a href="#" class="uix-3d-slider--liquid-scrollspy__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowWidth * imgAspect + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--liquid-scrollspy__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if (simple_3D_liquid_scrollspy_slider_js_typeof(dataSpeed) != ( true ? "undefined" : undefined) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if (simple_3D_liquid_scrollspy_slider_js_typeof(videoURL) === ( true ? "undefined" : undefined)) videoURL = _item.attr('src');

                if (simple_3D_liquid_scrollspy_slider_js_typeof(videoURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if (simple_3D_liquid_scrollspy_slider_js_typeof(imgURL) != ( true ? "undefined" : undefined)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--liquid-scrollspy__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--liquid-scrollspy__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              $this.on({
                mouseenter: function mouseenter() {
                  clearInterval($this[0].animatedSlides);
                },
                mouseleave: function mouseleave() {
                  sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
                }
              });
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function loadImages() {
        var promises = [];

        var _loop = function _loop(i) {
          if (sources[i].type == 'img') {
            ///////////
            // IMAGE //
            ///////////   
            promises.push(new Promise(function (resolve, reject) {
              var img = document.createElement("img");
              img.crossOrigin = "anonymous";
              img.src = sources[i].url;

              img.onload = function (image) {
                //loading
                TweenMax.to("#" + renderLoaderID, 0.5, {
                  width: Math.round(100 * (i / sources.length)) + '%'
                }); //Compatible with safari and firefox

                if (simple_3D_liquid_scrollspy_slider_js_typeof(image.path) === ( true ? "undefined" : undefined)) {
                  return resolve(image.target.currentSrc);
                } else {
                  return resolve(image.path[0].currentSrc);
                }
              };
            }).then(makeThreeTexture));
          } else {
            ///////////
            // VIDEO //
            ///////////    
            promises.push(new Promise(function (resolve, reject) {
              //loading
              TweenMax.to("#" + renderLoaderID, 0.5, {
                width: Math.round(100 * (i / sources.length)) + '%'
              });
              $('#' + sources[i].id).one('loadedmetadata', resolve);
              return resolve(sources[i].url);
            }).then(makeThreeTexture));
          }
        };

        for (var i = 0; i < sources.length; i++) {
          _loop(i);
        }

        return Promise.all(promises);
      }

      function makeThreeTexture(url) {
        var texture;

        if (/[\/.](gif|jpg|jpeg|png)$/i.test(url)) {
          ///////////
          // IMAGE //
          ///////////   
          texture = loader.load(url);
        } else {
          ///////////
          // VIDEO //
          ///////////   
          var video = document.createElement('video');
          video.src = url;
          texture = new THREE.VideoTexture(video);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.format = THREE.RGBFormat; // pause the video

          texture.image.autoplay = true;
          texture.image.loop = true;
          texture.image.currentTime = 0;
          texture.image.muted = true;
          texture.image.play();
        }

        return texture;
      }

      function texturesInit() {
        //Must be placed behind the loadImages()
        loadImages().then(function (images) {
          //remove loading
          TweenMax.to($("#" + renderLoaderID), 0.5, {
            alpha: 0
          });
          init(images);
          render();
        });
      }

      function init(allTextures) {
        textures = allTextures; //Core 3D stage begin
        //-------------------------------------		
        //camera

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000); // FlyCamera // FlyControls

        camera.position.z = 1000; //Object 1 unit, equal to 1 pixel

        camera.lookAt = new THREE.Vector3(0, 0, 0); // Fit plane to screen

        var dist = 1000,
            vFOV = THREE.Math.degToRad(camera.fov),
            // convert vertical fov to radians
        objHeight = 2 * Math.tan(vFOV / 2) * dist,
            // visible height
        objWidth = objHeight * camera.aspect; // visible width   
        //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var texture1 = textures[0],
            texture2 = textures[1],
            intensity = 1,
            disp = loader.load(dispImage);
        disp.wrapS = disp.wrapT = THREE.RepeatWrapping;
        texture1.magFilter = texture2.magFilter = THREE.LinearFilter;
        texture1.minFilter = texture2.minFilter = THREE.LinearFilter;
        texture1.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture2.anisotropy = renderer.capabilities.getMaxAnisotropy();
        var geometry = new THREE.PlaneBufferGeometry(objWidth, objHeight, 1);
        $('#' + rendererCanvasID).css('height', windowWidth * imgAspect + 'px');
        geometry.center();
        material = new THREE.ShaderMaterial({
          uniforms: {
            effectFactor: {
              type: "f",
              value: intensity
            },
            dispFactor: {
              type: "f",
              value: 0.0
            },
            texture: {
              type: "t",
              value: texture1
            },
            texture2: {
              type: "t",
              value: texture2
            },
            disp: {
              type: "t",
              value: disp
            }
          },
          vertexShader: js_shader_vertex_custom,
          fragmentShader: js_shader_fragment_custom,
          transparent: true,
          opacity: 1.0
        });
        displacementSprite = new THREE.Mesh(geometry, material);
        displacementSprite.position.set(0, 0, 0);
        scene.add(displacementSprite); //				TweenMax.to( material.uniforms.dispFactor, 1.5, {
        //					value: 1,
        //					ease: Expo.easeOut
        //				});	
        //                
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // Scrolling interaction with 3D scenes

        window.addEventListener('wheel', onMouseWheel, browser.supportsPassive ? {
          passive: true
        } : false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onMouseWheel(e) {
        var scrollPos; //Gets a value that indicates the amount that the mouse wheel has changed.

        var dir,
            delta,
            mobileDeltaY = null;
        var touches = e.touches;

        if (touches && touches.length) {
          mobileDeltaY = startY - touches[0].pageY;
          scrollPos = touches[0].pageY;
        } else {
          delta = Math.max(-1, Math.min(1, -e.deltaY));
          scrollPos = e.deltaY;
        }

        if (mobileDeltaY != null) {
          if (mobileDeltaY >= 50) {
            //--- swipe up
            dir = 'up';
          }

          if (mobileDeltaY <= -50) {
            //--- swipe down
            dir = 'down';
          }
        } else {
          if (delta < 0) {
            //scroll down
            dir = 'down';
          } else {
            //scroll up
            dir = 'up';
          }
        } //-----


        if (scrollspyEnable) {
          var slideCurId = scrollspyConfigItems.filter('.is-active').index();
          var slideNextId;

          if (dir == 'down') {
            slideNextId = parseFloat(scrollspyConfigItems.filter('.is-active').index()) + 1; //Transition Between Slides

            sliderUpdates(slideCurId, slideNextId, 'next', scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop); //Pause the auto play event

            clearInterval(scrollspyConfigAutoAnim);
          }

          if (dir == 'up') {
            slideNextId = parseFloat(scrollspyConfigItems.filter('.is-active').index()) - 1; //Transition Between Slides

            sliderUpdates(slideCurId, slideNextId, 'prev', scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop); //Pause the auto play event

            clearInterval(scrollspyConfigAutoAnim);
          }
        }
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--liquid-scrollspy__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--liquid-scrollspy__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--liquid-scrollspy__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId; //Update Texture

          material.uniforms.texture.value = textures[Math.floor(slideCurId)];
          material.uniforms.texture2.value = textures[Math.floor(slideNextId)]; //console.log( 'material.uniforms.texture: ' + material.uniforms.texture.value.image.currentSrc );
          //console.log( 'material.uniforms.texture2: ' + material.uniforms.texture2.value.image.currentSrc );

          TweenMax.to(material.uniforms.dispFactor, 1.5, {
            value: 1,
            ease: Expo.easeOut,
            onComplete: function onComplete() {
              //Update Texture
              var tx1ID, tx2ID;

              if (dir == 'prev') {
                material.uniforms.texture.value = textures[Math.floor(slideCurId)];
                material.uniforms.texture2.value = textures[Math.floor(slideNextId - 1)];

                if (loop) {
                  tx1ID = slideNextId;
                  tx2ID = slideNextId - 1;
                  if (slideNextId == 0) tx2ID = total - 1;
                } else {}
              }

              if (dir == 'next') {
                material.uniforms.texture.value = textures[Math.floor(slideCurId)];
                material.uniforms.texture2.value = textures[Math.floor(slideNextId)];

                if (loop) {
                  tx1ID = slideNextId;
                  tx2ID = slideNextId + 1;
                  if (slideNextId == total - 1) tx2ID = 0;
                } else {}
              }

              material.uniforms.texture.value = textures[Math.floor(tx1ID)];
              material.uniforms.texture2.value = textures[Math.floor(tx2ID)]; //console.log( 'New material.uniforms.texture: ' + material.uniforms.texture.value.image.currentSrc );
              //console.log( 'New material.uniforms.texture2: ' + material.uniforms.texture2.value.image.currentSrc ); 
              //console.log( '--------------------' );

              TweenMax.set(this.target, {
                value: 0
              }); //Reset the trigger
              //-------------------------------------

              isAnimating = false;
            }
          }); //Fire the current object
          //-------------------------------------
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        wrapperInit: wrapperInit,
        texturesInit: texturesInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit(); //step 1

    MainStage.texturesInit(); // step 2
  };

  module.components.documentReady.push(module.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady);
  return function THREE_LIQUID_SCROLLSPY_SLIDER() {
    simple_3D_liquid_scrollspy_slider_js_classCallCheck(this, THREE_LIQUID_SCROLLSPY_SLIDER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/EffectComposer.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.EffectComposer = function (renderer, renderTarget) {
  this.renderer = renderer;

  if (renderTarget === undefined) {
    var parameters = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      stencilBuffer: false
    };
    var size = renderer.getDrawingBufferSize(new THREE.Vector2());
    renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
    renderTarget.texture.name = 'EffectComposer.rt1';
  }

  this.renderTarget1 = renderTarget;
  this.renderTarget2 = renderTarget.clone();
  this.renderTarget2.texture.name = 'EffectComposer.rt2';
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.renderToScreen = true;
  this.passes = []; // dependencies

  if (THREE.CopyShader === undefined) {
    console.error('THREE.EffectComposer relies on THREE.CopyShader');
  }

  if (THREE.ShaderPass === undefined) {
    console.error('THREE.EffectComposer relies on THREE.ShaderPass');
  }

  this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
  this._previousFrameTime = Date.now();
};

Object.assign(THREE.EffectComposer.prototype, {
  swapBuffers: function swapBuffers() {
    var tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  },
  addPass: function addPass(pass) {
    this.passes.push(pass);
    var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
    pass.setSize(size.width, size.height);
  },
  insertPass: function insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
  },
  isLastEnabledPass: function isLastEnabledPass(passIndex) {
    for (var i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }

    return true;
  },
  render: function render(deltaTime) {
    // deltaTime value is in seconds
    if (deltaTime === undefined) {
      deltaTime = (Date.now() - this._previousFrameTime) * 0.001;
    }

    this._previousFrameTime = Date.now();
    var currentRenderTarget = this.renderer.getRenderTarget();
    var maskActive = false;
    var pass,
        i,
        il = this.passes.length;

    for (i = 0; i < il; i++) {
      pass = this.passes[i];
      if (pass.enabled === false) continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

      if (pass.needsSwap) {
        if (maskActive) {
          var context = this.renderer.context;
          context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          context.stencilFunc(context.EQUAL, 1, 0xffffffff);
        }

        this.swapBuffers();
      }

      if (THREE.MaskPass !== undefined) {
        if (pass instanceof THREE.MaskPass) {
          maskActive = true;
        } else if (pass instanceof THREE.ClearMaskPass) {
          maskActive = false;
        }
      }
    }

    this.renderer.setRenderTarget(currentRenderTarget);
  },
  reset: function reset(renderTarget) {
    if (renderTarget === undefined) {
      var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(size.width, size.height);
    }

    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  },
  setSize: function setSize(width, height) {
    this.renderTarget1.setSize(width, height);
    this.renderTarget2.setSize(width, height);

    for (var i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(width, height);
    }
  }
});

THREE.Pass = function () {
  // if set to true, the pass is processed by the composer
  this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

  this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

  this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

  this.renderToScreen = false;
};

Object.assign(THREE.Pass.prototype, {
  setSize: function setSize(width, height) {},
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}); // Helper for passes that need to fill the viewport with a single quad.

THREE.Pass.FullScreenQuad = function () {
  var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var geometry = new THREE.PlaneBufferGeometry(2, 2);

  var FullScreenQuad = function FullScreenQuad(material) {
    this._mesh = new THREE.Mesh(geometry, material);
  };

  Object.defineProperty(FullScreenQuad.prototype, 'material', {
    get: function get() {
      return this._mesh.material;
    },
    set: function set(value) {
      this._mesh.material = value;
    }
  });
  Object.assign(FullScreenQuad.prototype, {
    render: function render(renderer) {
      renderer.render(this._mesh, camera);
    }
  });
  return FullScreenQuad;
}();

/* harmony default export */ var EffectComposer = (THREE.EffectComposer);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/MaskPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.MaskPass = function (scene, camera) {
  THREE.Pass.call(this);
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.inverse = false;
};

THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.MaskPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var context = renderer.context;
    var state = renderer.state; // don't update color or depth

    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false); // lock buffers

    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true); // set up stencil

    var writeValue, clearValue;

    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }

    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
    state.buffers.stencil.setClear(clearValue); // draw into the stencil buffer

    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering

    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false); // only render where stencil is set to 1

    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1

    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
  }
});

THREE.ClearMaskPass = function () {
  THREE.Pass.call(this);
  this.needsSwap = false;
};

THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype);
Object.assign(THREE.ClearMaskPass.prototype, {
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.state.buffers.stencil.setTest(false);
  }
});
/* harmony default export */ var MaskPass = (THREE.MaskPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/TexturePass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.TexturePass = function (map, opacity) {
  THREE.Pass.call(this);
  if (THREE.CopyShader === undefined) console.error("THREE.TexturePass relies on THREE.CopyShader");
  var shader = THREE.CopyShader;
  this.map = map;
  this.opacity = opacity !== undefined ? opacity : 1.0;
  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  this.material = new THREE.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    depthTest: false,
    depthWrite: false
  });
  this.needsSwap = false;
  this.fsQuad = new THREE.Pass.FullScreenQuad(null);
};

THREE.TexturePass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.TexturePass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.fsQuad.material = this.material;
    this.uniforms["opacity"].value = this.opacity;
    this.uniforms["tDiffuse"].value = this.map;
    this.material.transparent = this.opacity < 1.0;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear) renderer.clear();
    this.fsQuad.render(renderer);
    renderer.autoClear = oldAutoClear;
  }
});
/* harmony default export */ var TexturePass = (THREE.TexturePass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/ShaderPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.ShaderPass = function (shader, textureID) {
  THREE.Pass.call(this);
  this.textureID = textureID !== undefined ? textureID : "tDiffuse";

  if (shader instanceof THREE.ShaderMaterial) {
    this.uniforms = shader.uniforms;
    this.material = shader;
  } else if (shader) {
    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
    this.material = new THREE.ShaderMaterial({
      defines: Object.assign({}, shader.defines),
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
  }

  this.fsQuad = new THREE.Pass.FullScreenQuad(this.material);
};

THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.ShaderPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }

    this.fsQuad.material = this.material;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
});
/* harmony default export */ var ShaderPass = (THREE.ShaderPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/RenderPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {
  THREE.Pass.call(this);
  this.scene = scene;
  this.camera = camera;
  this.overrideMaterial = overrideMaterial;
  this.clearColor = clearColor;
  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
  this.clear = true;
  this.clearDepth = false;
  this.needsSwap = false;
};

THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.RenderPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.scene.overrideMaterial = this.overrideMaterial;
    var oldClearColor, oldClearAlpha;

    if (this.clearColor) {
      oldClearColor = renderer.getClearColor().getHex();
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }

    if (this.clearDepth) {
      renderer.clearDepth();
    }

    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

    if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);

    if (this.clearColor) {
      renderer.setClearColor(oldClearColor, oldClearAlpha);
    }

    this.scene.overrideMaterial = null;
    renderer.autoClear = oldAutoClear;
  }
});
/* harmony default export */ var RenderPass = (THREE.RenderPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/ClearPass.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.ClearPass = function (clearColor, clearAlpha) {
  THREE.Pass.call(this);
  this.needsSwap = false;
  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
};

THREE.ClearPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.ClearPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldClearColor, oldClearAlpha;

    if (this.clearColor) {
      oldClearColor = renderer.getClearColor().getHex();
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }

    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    renderer.clear();

    if (this.clearColor) {
      renderer.setClearColor(oldClearColor, oldClearAlpha);
    }
  }
});
/* harmony default export */ var ClearPass = (THREE.ClearPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/shaders/CopyShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */
THREE.CopyShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "opacity": {
      value: 1.0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
};
/* harmony default export */ var CopyShader = (THREE.CopyShader);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/shaders/ConvolutionShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */
THREE.ConvolutionShader = {
  defines: {
    "KERNEL_SIZE_FLOAT": "25.0",
    "KERNEL_SIZE_INT": "25"
  },
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "uImageIncrement": {
      value: new THREE.Vector2(0.001953125, 0.0)
    },
    "cKernel": {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function buildKernel(sigma) {
    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
    function gauss(x, sigma) {
      return Math.exp(-(x * x) / (2.0 * sigma * sigma));
    }

    var i,
        values,
        sum,
        halfWidth,
        kMaxKernelSize = 25,
        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;

    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    } // normalize the kernel


    for (i = 0; i < kernelSize; ++i) {
      values[i] /= sum;
    }

    return values;
  }
};
/* harmony default export */ var ConvolutionShader = (THREE.ConvolutionShader);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/BloomPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.BloomPass = function (strength, kernelSize, sigma, resolution) {
  THREE.Pass.call(this);
  strength = strength !== undefined ? strength : 1;
  kernelSize = kernelSize !== undefined ? kernelSize : 25;
  sigma = sigma !== undefined ? sigma : 4.0;
  resolution = resolution !== undefined ? resolution : 256; // render targets

  var pars = {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat
  };
  this.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetX.texture.name = "BloomPass.x";
  this.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetY.texture.name = "BloomPass.y"; // copy material

  if (THREE.CopyShader === undefined) console.error("THREE.BloomPass relies on THREE.CopyShader");
  var copyShader = THREE.CopyShader;
  this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = strength;
  this.materialCopy = new THREE.ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: THREE.AdditiveBlending,
    transparent: true
  }); // convolution material

  if (THREE.ConvolutionShader === undefined) console.error("THREE.BloomPass relies on THREE.ConvolutionShader");
  var convolutionShader = THREE.ConvolutionShader;
  this.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);
  this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurX;
  this.convolutionUniforms["cKernel"].value = THREE.ConvolutionShader.buildKernel(sigma);
  this.materialConvolution = new THREE.ShaderMaterial({
    uniforms: this.convolutionUniforms,
    vertexShader: convolutionShader.vertexShader,
    fragmentShader: convolutionShader.fragmentShader,
    defines: {
      "KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
      "KERNEL_SIZE_INT": kernelSize.toFixed(0)
    }
  });
  this.needsSwap = false;
  this.fsQuad = new THREE.Pass.FullScreenQuad(null);
};

THREE.BloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.BloomPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST); // Render quad with blured scene into texture (convolution pass 1)

    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)

    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture

    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);
    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    this.fsQuad.render(renderer);
  }
});
THREE.BloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);
THREE.BloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);
/* harmony default export */ var BloomPass = (THREE.BloomPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/postprocessing/FilmPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.FilmPass = function (noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
  THREE.Pass.call(this);
  if (THREE.FilmShader === undefined) console.error("THREE.FilmPass relies on THREE.FilmShader");
  var shader = THREE.FilmShader;
  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  this.material = new THREE.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
  if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
  if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
  if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;
  this.fsQuad = new THREE.Pass.FullScreenQuad(this.material);
};

THREE.FilmPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.FilmPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime
  /*, maskActive */
  ) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["time"].value += deltaTime;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
});
/* harmony default export */ var FilmPass = (THREE.FilmPass);
// CONCATENATED MODULE: ./src/third-party-plugins/esm/THREE/shaders/FilmShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */
THREE.FilmShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "time": {
      value: 0.0
    },
    "nIntensity": {
      value: 0.5
    },
    "sIntensity": {
      value: 0.05
    },
    "sCount": {
      value: 4096
    },
    "grayscale": {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", // control parameter
  "uniform float time;", "uniform bool grayscale;", // noise effect intensity value (0 = no effect, 1 = full effect)
  "uniform float nIntensity;", // scanlines effect intensity value (0 = no effect, 1 = full effect)
  "uniform float sIntensity;", // scanlines effect count value (0 = no effect, 4096 = full effect)
  "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", // sample the source
  "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", // make some noise
  "float dx = rand( vUv + time );", // add noise
  "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );", // get us a sine and cosine
  "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", // add scanlines
  "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", // interpolate between source and result by intensity
  "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", // convert to grayscale if desired
  "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")
};
/* harmony default export */ var FilmShader = (THREE.FilmShader);
// CONCATENATED MODULE: ./src/components/simple-3D-filmic-effects/js/index.js
function simple_3D_filmic_effects_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- 3D Filmic Effects -->
 *************************************
 */
 //filter basic
//---------------------








 //Extra filter -- film
//---------------------

 //Extra filter -- film
//---------------------



var THREE_FILMIC_EFF = function (module, $, window, document) {
  if (window.THREE_FILMIC_EFF === null) return false;
  module.THREE_FILMIC_EFF = module.THREE_FILMIC_EFF || {};
  module.THREE_FILMIC_EFF.version = '0.0.2';

  module.THREE_FILMIC_EFF.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-filmic-effects-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var $window = $(window);
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-filmic-effects-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          lights = [],
          renderer,
          clock = new THREE.Clock();
      var intersectionPlane;
      var composer, bloomPass, filmPass;

      function init() {
        //=================
        //camera
        camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0)); //=================
        //Scene

        scene = new THREE.Scene(); //=================
        //Lights

        lights[0] = new THREE.PointLight(0xffffff, 1, 0);
        lights[1] = new THREE.PointLight(0xffffff, 1, 0);
        lights[2] = new THREE.DirectionalLight(0xffffff);
        lights[0].position.set(0, 200, 0);
        lights[1].position.set(100, 200, 100);
        lights[2].position.set(120, 200, 0);
        lights[2].intensity = 0.6;
        scene.add(lights[0]);
        scene.add(lights[1]);
        scene.add(lights[2]); //=================
        //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; //=================
        //add bloom effect

        bloomPass = new THREE.BloomPass(1, // strength
        25, // kernel size
        4, // sigma ?
        256); //add film effect

        filmPass = new THREE.FilmPass(0.35, // noise intensity
        0.025, // scanline intensity
        648, // scanline count
        false); //-----

        var renderPass = new THREE.RenderPass(scene, camera);
        var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
        effectCopy.renderToScreen = true;
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(filmPass);
        composer.addPass(effectCopy); //=================

        var planeGeometry = new THREE.PlaneGeometry(100000, 100000);
        var planeMaterial = new THREE.MeshNormalMaterial({
          side: THREE.DoubleSide
        });
        intersectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        intersectionPlane.visible = false;
        scene.add(intersectionPlane);
        var hoverMaterial = new THREE.MeshNormalMaterial();
        var neutralMaterial = new THREE.MeshLambertMaterial({
          color: 0xffcccc
        });
        var selectedMaterial = new THREE.MeshBasicMaterial({
          color: 0x55ff88
        });
        var neutralGeometry = new THREE.IcosahedronGeometry(30, 1);
        var mesh = new THREE.Mesh(neutralGeometry, neutralMaterial);
        mesh.position.x = 0;
        mesh.position.y = 0;
        mesh.position.z = 0;
        scene.add(mesh); //=================
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render); //To set a background color.

        renderer.setClearColor(0x000000); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene with filter


        composer.render();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }(); // 


    MainStage.init();
    MainStage.render(); // Add stars to scene
    //-------------------------------------	

    var starScene = MainStage.getScene();
    var starCamera = MainStage.getCamera();

    function Stars(scene, terrainSize) {
      var starsGeometry = new THREE.IcosahedronGeometry(terrainSize, 4); // geometry deformation

      for (var i = 0; i < starsGeometry.vertices.length; i += 1) {
        var scalar = 1 + Math.random() + Math.random();
        starsGeometry.vertices[i].multiplyScalar(scalar);
      }

      var textureLoader = new THREE.TextureLoader();
      textureLoader.setCrossOrigin("anonymous");
      var texture = textureLoader.load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAACAAIUyQ49AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3AUUFhoiw1VdsQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAIQUlEQVR42u1baW/bRhB9u6Qkx1fiOFGcNCiaAGn//+9pG7RxTie1Y8u2TnL65a0xmcxSlCxbaWECCx6iyZ03b86lgbvtblvbJiKFiBTrnENcMwY9jjsA1rWVt0z54ADgXUcIQf7zADiCBXPc5XEBQDjS394KIOUNCx4ygmsTLAjERP0m5vgKkFUDUd6g4J7wHhgdAJsAppnHBgWIrBqI8hYE935L50n7mwDOtQlYk7CArAqI8gaE985zIBQ0g66JSFp4aQBDRCRcB4RyBcI3CW1/j4YVyQd0uIcStHYAsEBcsWFZEMoVaz2q82iuefcnBkQDgHWCtQJFzDVcx0mWS2hbGrQdG469vyk5Otx7mq7Ne615ZE2ijXm0BiCEICISAewwZE0c4aMR3u5hmFGoURpN63AoCojaMRMLQjKrKYBqlSZQ86E/8fjQCB/nnFszKc0Qh/I6DNaO5i0IDwnoOZXUuBVLmEAFYAZgjy87NQIXmREppL52nxGgAnCRAS7nUL3tCYBdKmkQQqhW4gNMShsAXAL4BOA5gN8AnAD4qgCwgFgTCer9hdrDsKDm31RzANiiaW5ybscAZiv1AU64uwTwkSD0AewDeGNAKBwAogGgQ0Z1jNevlb0HBYLdHlPwgiw64vNCJndYrBw2sd6OCwAfeNwD8Mo4NX1cGq/fUd7fnuvhPS+B+5Rm2AUwBvCZ9L+ao1dpLtsP0NrXNjqkOSQbf+UIUToC2uNew72l4z+e0Q9FCn+khMccX9HOBDKZXlR5fDoeKnMoAPzKa5/VxK0/0FEAAO5RkET7Stm/nu8ugA0CJjTFL4r20SZTTZliuYT27SgUCMkxBjqlXQDvjD/QjjBpOdKOKxPzrd0/pvCiIscXJycJJodY3ASU9uEI7yU6BTX4SYXYLoCXGcp3lG13yICciZS09/u8Ho3N58Lm1dxzviAuoX00mEOkNo4UhTsEwXOG3YwPsOHxgMKnUDmk5msn05zXj1jYBOZVetEZFZnwSGVmv1Bjuhm6p9piJQUbq+ZI5DM2eE2Y4R2rHCEquudKcLluHuA5Qc8cbKw/UxlaQSZ0yJJN0joBcKr+5lz1CUoCWjPhOqNAUYFQm/lIG+GzADTU+cgA4bGgUGHyhM7xIbW+w98eK1qfkxXHBOhSsWHG66NMUhUUENYMGqNBuUQegBZABOMc0/FTAnAAYJspbFQM2KSg50ywjgnCiYrxMVN2t5nvtavB0KLVZUFJtr5LAZ8TgC2CkLYdOrrPzCkmFP6dET73Ti8MXhuANq2ueaGyR8H69AX7dGyb5v09ldMnk3iXabCEOUpp7QiXaYlFE7p0KOuaNHaDdt8n/fsUfov32DWClPwMyYhUcgvtf0Y2pDHh/VPVpJl6LbPWDGDXpzRZms7Be0xaNlQ48xKdgvf1lfb3SPtOprRNawTbBOpE9QmGStiZGuk8mcyI905U7wLcVyIyBVCFEOrvAKD37yoH1TONjKBA6ahrIdPP013fxJiiYcFEFMg6W4yZDrH2OR2z0FITgEqlzmMCeiEi4xCClM7620hExvTA1psX1PwWX7KpihI9mUq1sOpMA3NuJa5aXloYfa5NYszQeUkhx/xdd5LlOmEwTSY9+CJDfX28RSpu0/ntA3hAlolhQZpYpeL/B/Yd3/N9U4f69lhrvZVDW1Qj9lrttLHS+ZQaOac9J/ucZhY89P1nZNulub923ikt59sOANJEMr34JsFrQ9EpNXdCQc5UojNR2qp4fsoa4oT3DciYqaF/3QKI7+bv9QTKBbUvplWtX+wBEKl1ofDvlSndY36QzGBAoQ8Z/08ISGrD/5kRvjYsqhsWTpbKAyTj5a32gxE+OdBtVbunxuUp4/y+mkPS/t8sp9+QNR2+52cAb1XXyGOBFyVk1QDAYYP2+pXqCO3RjpMD+0JKf1QO8R7vHwD4i/cccQz4+0M++wmjzgf1rjb0X6jA8apCu5wVzWJHNA2PfQqfkqRUzXVZE+ySGem4w3WFQ5pKKomT3aeMMp1fEKx0PlOA6P3VgmquJ9gWANsDtAsgpdr3KXxKnqq0UKFA2uDosiTuUeA3KuWtTLzf4LOTsCMAr9W5BUCa4n/rkrGBBcFZ+jogrZPwEzqzmWmI6q7wAYU7V9SWjEYLApZq/wmAP5yMr5X2F02E7Eqt7sSkju22KlxGqiMUTQsrqvx8zGfMjDZrR7Njan2L7wtstf2+TARoBQCXxT0wdBTo0+mJalhOFTvqzNJY4H2lSmm9pbHKsOErtf+Ez3upQGhF/WUZAMMCGOEvGe5mzgKFtzgaTCqby/gqhxGnBOGAz31Bc/ASt+sBQBYEh1r79OIVhf/HEd42MG2zQufvsxYJlh4DvjctkL5gwqQz2tW0xBxTeEThh5zIRSZpqk273LKgcgCoTSUomQwwhcBD+oVn9Amv234rtFA1qEB4QIc3IuUnjn2L4zhhogmc5gZMCV037HUWOGAWecDU+e1NNEWhmhoD2uEM336+EhTt7fpcMGmzNYEK/kdSkinArNO7ZILUFZGdEMJgpQDQD4gSHEbj3hpChP9lWdpsLe/l8k2fyX1zPz+LGYpIEJGYWl8rY0AIYWwAsQ0Tb3U296EkTBpbod2HknNLXVXSr9YHZHyC193x2tPiZJ8jFjyV+hYg96msZLS+nk9lTYiUhuwxt7wGRo8txYKmiu67Bs3aP5bWk8iwwUuk9HZBFjQ1UFcu+EoBmAOEzCm6Zsqhenn8N9d+6H+YyACBzHK1jQQwqznS5H9+aABykzaZpD4Z2mv/i3+amgeIAmZ0m0KvDYCGbYK77W6729ax/Qsf5ETUur8sQgAAAABJRU5ErkJggg==');
      var starMaterial = new THREE.PointsMaterial({
        map: texture,
        color: "#fff",
        size: 20,
        blending: THREE.AdditiveBlending,
        transparent: false
      });
      var stars = new THREE.Points(starsGeometry, starMaterial);
      scene.add(stars);

      this.update = function (time) {
        stars.rotation.y = time * 0.13;
      };
    }

    sceneSubjects.push(new Stars(starScene, 150));
  };

  module.components.documentReady.push(module.THREE_FILMIC_EFF.documentReady);
  return function THREE_FILMIC_EFF() {
    simple_3D_filmic_effects_js_classCallCheck(this, THREE_FILMIC_EFF);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/table/scss/_style.scss
var table_scss_style = __webpack_require__(9);

// CONCATENATED MODULE: ./src/components/table/js/basic.js
function js_basic_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Responsive Table -->
 *************************************
 */


var TABLE = function (module, $, window, document) {
  if (window.TABLE === null) return false;
  module.TABLE = module.TABLE || {};
  module.TABLE.version = '0.0.3';

  module.TABLE.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /* 
     ---------------------------
     Duplicate title
     ---------------------------
     */

    var $resTable = $('table.uix-table.is-responsive, .uix-table.is-responsive table'),
        $thead = $resTable.find('thead'),
        $tbody = $resTable.find('tbody');
    $thead.find('th').each(function () {
      var data = $(this).html().replace(/<span\s+class=(\"|\')js-uix-table-responsive__hidden(\"|\')(([\s\S])*?)<\/span>/g, '');

      if (!$(this).attr('data-table')) {
        $(this).attr('data-table', data);
      }
    });
    $tbody.find('td').each(function () {
      var index = $(this).index();
      var data = $thead.find('th:eq(' + index + ')').attr('data-table');
      $(this).attr('data-table', data);
    });
    /* 
     ---------------------------
     With scroll bars
     ---------------------------
     */

    var resTableSCrolled = '.js-uix-table--responsive-scrolled',
        columns = $(resTableSCrolled + ' tr').length,
        rows = $(resTableSCrolled + ' th').length;
    tableDataScrolledInit(windowWidth);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        tableDataScrolledInit(windowWidth);
      }
    });

    function tableDataScrolledInit(w) {
      if (w <= 768) {
        for (var i = 0; i < rows; i++) {
          var maxHeight = $(resTableSCrolled + ' th:nth-child(' + i + ')').outerHeight();

          for (var j = 0; j < columns; j++) {
            if ($(resTableSCrolled + ' tr:nth-child(' + j + ') td:nth-child(' + i + ')').outerHeight() > maxHeight) {
              maxHeight = $(resTableSCrolled + ' tr:nth-child(' + j + ') td:nth-child(' + i + ')').outerHeight();
            }

            if ($(resTableSCrolled + ' tr:nth-child(' + j + ') td:nth-child(' + i + ')').prop('scrollHeight') > $(resTableSCrolled + ' tr:nth-child(' + j + ') td:nth-child(' + i + ')').outerHeight()) {
              maxHeight = $(resTableSCrolled + ' tr:nth-child(' + j + ') td:nth-child(' + i + ')').prop('scrollHeight');
            }
          }

          for (var _j = 0; _j < columns; _j++) {
            $(resTableSCrolled + ' tr:nth-child(' + _j + ') td:nth-child(' + i + ')').css('height', maxHeight);
            $(resTableSCrolled + ' th:nth-child(' + i + ')').css('height', maxHeight);
          }
        }
      } else {
        $(resTableSCrolled + ' td, ' + resTableSCrolled + ' th').removeAttr('style');
      }
    }
  };

  module.components.documentReady.push(module.TABLE.documentReady);
  return function TABLE() {
    js_basic_classCallCheck(this, TABLE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/table/js/fn/sort-elements.js
var sort_elements = __webpack_require__(73);

// CONCATENATED MODULE: ./src/components/table/js/sorter.js
function sorter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Table Sorter -->
 *************************************
 */



var TABLE_SORTER = function (module, $, window, document) {
  if (window.TABLE_SORTER === null) return false;
  module.TABLE_SORTER = module.TABLE_SORTER || {};
  module.TABLE_SORTER.version = '0.0.3';

  module.TABLE_SORTER.documentReady = function ($) {
    $('.js-uix-table-sorter').each(function () {
      var $sortTable = $(this).find('table'); //add arrows

      $sortTable.find("[data-sort-type]").each(function () {
        if ($(this).find('.uix-table-sorter').length == 0) {
          $(this).wrapInner('<span class="uix-table-sorter" />');
        }

        var $th = $(this),
            thIndex = $th.index(),
            thType = $th.data('sort-type');
        var inverse = false;
        $th.off('click').on('click', function () {
          $sortTable.find('tbody td').filter(function () {
            return $(this).index() === thIndex;
          }).sortElements(function (a, b) {
            var txt1 = $.text([a]).replace(/(<([^>]+)>)/ig, ''),
                txt2 = $.text([b]).replace(/(<([^>]+)>)/ig, ''); //type of number

            if (thType == 'number') {
              txt1 = Number(txt1.replace(/[^0-9.-]+/g, ''));
              txt2 = Number(txt2.replace(/[^0-9.-]+/g, ''));
            } //type of date


            if (thType == 'date') {
              txt1 = new Date(txt1);
              txt2 = new Date(txt2);
            } //add filter class


            $sortTable.find('tbody tr').addClass('js-uix-newsort');

            if (txt1 > txt2) {
              if (inverse) {
                return -1;
              } else {
                return 1;
              }
            } else {
              if (inverse) {
                return 1;
              } else {
                return -1;
              }
            }
          }, function () {
            // parentNode is the element we want to move
            return this.parentNode;
          });
          inverse = !inverse;
        });
      });
    });
  };

  module.components.documentReady.push(module.TABLE_SORTER.documentReady);
  return function TABLE_SORTER() {
    sorter_classCallCheck(this, TABLE_SORTER);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/tabs/scss/_style.scss
var tabs_scss_style = __webpack_require__(74);

// CONCATENATED MODULE: ./src/components/tabs/js/index.js
function tabs_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function tabs_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tabs_js_typeof = function _typeof(obj) { return typeof obj; }; } else { tabs_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tabs_js_typeof(obj); }

/* 
 *************************************
 * <!-- Tabs -->
 *************************************
 */


var TABS = function (module, $, window, document) {
  if (window.TABS === null) return false;
  module.TABS = module.TABS || {};
  module.TABS.version = '0.1.4';

  module.TABS.documentReady = function ($) {
    $('.uix-tabs').each(function (id) {
      var $this = $(this);
      var $li = $this.find('.uix-tabs__nav ul > li'),
          liWidth = $li.first().outerWidth(),
          liHeight = $li.first().outerHeight(),
          liNum = $li.length,
          $contentbox = $this.find('.uix-tabs__content'),
          isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/,
          tabBoxID = id;
      var ulWidth = $this.data('width'),
          fullwidth = $this.data('fullwidth'),
          rotation = $this.data('rotation'),
          rotationRadius = $this.data('rotation-radius'),
          rotationWapperDeg = $this.data('rotation-wrapper-angle'),
          rotationDisplay = $this.data('rotation-display');

      if (tabs_js_typeof(fullwidth) != ( true ? "undefined" : undefined) && fullwidth == 1) {
        $li.css('width', 100 / liNum + '%');
      }

      if (tabs_js_typeof(rotation) === ( true ? "undefined" : undefined)) {
        rotation = false;
      }

      if (tabs_js_typeof(rotationWapperDeg) === ( true ? "undefined" : undefined)) {
        rotationWapperDeg = 0;
      }

      if (tabs_js_typeof(rotationDisplay) === ( true ? "undefined" : undefined)) {
        rotationDisplay = 5;
      }

      $li.each(function (index) {
        index = index + 1;
        $(this).attr('href', 'javascript:');
        $(this).attr('data-tab', tabBoxID + '-tabs-show' + index);
      });
      $($contentbox).each(function (index) {
        index = index + 1;
        $(this).attr('id', tabBoxID + '-tabs-show' + index);
      }); // Tab Rotation Effect

      if (rotation) {
        $this.find('.uix-tabs__nav').css({
          'width': rotationRadius * 2 + 'px'
        });
        $this.find('.uix-tabs__nav ul').css({
          'width': rotationRadius * 2 + 'px',
          'height': rotationRadius * 2 + 'px',
          'transform': 'rotate(' + parseFloat(rotationWapperDeg) + 'deg)'
        }); //Layout components in a circle layout

        var step = 2 * Math.PI / rotationDisplay,
            pad = $this.find('.uix-tabs__nav ul').width();
        var angle = 0,
            transitionDelay = 0;
        $this.find('.uix-tabs__nav ul > li').each(function () {
          //Can'nt use arrow function here!!!
          // 'this' works differently with arrow fucntions
          var el = $(this),
              x = rotationRadius * Math.cos(angle) - liWidth / 2,
              y = rotationRadius * Math.sin(angle) - liHeight / 2;
          el.css({
            'transform': 'translate(' + parseFloat(x) + 'px,' + parseFloat(pad / 2 + y) + 'px)',
            'transition-delay': transitionDelay + "s"
          }).find('> a').css({
            'transform': 'rotate(' + parseFloat(-rotationWapperDeg) + 'deg)'
          });
          angle += step;
          transitionDelay += 0.15; //Click on the rotation effect
          //----------------------- begin ----------------------

          el.off('click').on('click', function (e) {
            var increase = Math.PI * 2 / rotationDisplay,
                n = $(this).index(),
                endAngle = n % rotationDisplay * increase;

            (function turn() {
              if (Math.abs(endAngle - angle) > 1 / 8) {
                var sign = endAngle > angle ? 1 : -1;
                angle = angle + sign / 8;
                setTimeout(turn, 20);
              } else {
                angle = endAngle;
              }

              $this.find('.uix-tabs__nav ul > li').each(function (index) {
                var x2 = Math.cos(-Math.PI / 2 + index * increase - angle) * rotationRadius - liWidth / 2,
                    y2 = Math.sin(-Math.PI / 2 + index * increase - angle) * rotationRadius + liHeight;
                $(this).css({
                  'transform': 'translate(' + parseFloat(x2) + 'px,' + parseFloat(y2) + 'px)',
                  'transition': 'none',
                  'transition-delay': 0
                }).find('> a').css({
                  'transform': 'rotate(' + parseFloat(-rotationWapperDeg) + 'deg)'
                });
              });
            })();
          }); //----------------------- end ----------------------
        });
      } // Tab Sliding Effext


      if ($this.find('.uix-tabs__nav ul > li:first .uix-tabs__marker').length == 0) {
        $this.find('.uix-tabs__nav ul > li:first').prepend('<div class="uix-tabs__marker"></div>');
      } // Tab Fade Effect


      $this.off('click').on('click', '.uix-tabs__nav ul > li', function (e) {
        var tabID = $(this).attr('data-tab'),
            index = parseFloat($(this).index() - 1);
        $this.find('.uix-tabs__nav ul > li').removeClass('is-active');
        $this.find('.uix-tabs__content').removeClass('is-active');
        $(this).addClass('is-active');
        $('#' + tabID).addClass('is-active'); //sliding marker

        var translateX = $(this).index() * 100,
            liHeight = $this.find('.uix-tabs__nav ul > li:first').outerHeight(),
            translateY = $(this).index() * liHeight;

        if (window.innerWidth <= 768) {
          $this.find('.uix-tabs__marker').css({
            'transform': 'translateY( ' + translateY + 'px )'
          });
        } else {
          $this.find('.uix-tabs__marker').css({
            'transform': 'translateX( ' + translateX + '% )'
          });
        }

        return false;
      }); // Init

      $this.find('.uix-tabs__nav ul > li.is-active').trigger('click'); //Active current tab

      var url = window.location.href,
          locArr,
          loc,
          curTab;

      if (url.indexOf('#') >= 0) {
        locArr = url.split('#');
        loc = locArr[1];
        curTab = $('.uix-tabs').find('ul > li:eq(' + loc + ')');
        curTab.trigger('click');
      }
    });
  };

  module.components.documentReady.push(module.TABS.documentReady);
  return function TABS() {
    tabs_js_classCallCheck(this, TABS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/team-focus/scss/_style.scss
var team_focus_scss_style = __webpack_require__(75);

// CONCATENATED MODULE: ./src/components/team-focus/js/index.js
function team_focus_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function team_focus_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { team_focus_js_typeof = function _typeof(obj) { return typeof obj; }; } else { team_focus_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return team_focus_js_typeof(obj); }

/* 
 *************************************
 * <!-- Team Focus -->
 *************************************
 */


var TEAM_FOCUS = function (module, $, window, document) {
  if (window.TEAM_FOCUS === null) return false;
  module.TEAM_FOCUS = module.TEAM_FOCUS || {};
  module.TEAM_FOCUS.version = '0.0.4';

  module.TEAM_FOCUS.documentReady = function ($) {
    var teamFocusContent = '.uix-team-focus',
        teamFocusMask = '.uix-team-focus__mask';
    $(teamFocusContent).each(function () {
      var $this = $(this);
      var thisID = 'uix-team-focus-' + UixGUID.create(),
          el = '#' + thisID + '> div';
      var total = 0;
      var hoverWidth = $this.data('hover-width'),
          targetWidth = $this.data('target-width'),
          // Div over width as a percentage 
      targetInfo = $this.data('target-info'),
          // Corresponding character details display
      closeBtn = $this.data('close-btn');
      $this.attr('id', thisID);

      if (team_focus_js_typeof(hoverWidth) === ( true ? "undefined" : undefined)) {
        hoverWidth = 20;
      }

      if (team_focus_js_typeof(targetWidth) === ( true ? "undefined" : undefined)) {
        targetWidth = 80;
      }

      if (team_focus_js_typeof(closeBtn) === ( true ? "undefined" : undefined)) {
        closeBtn = '.close';
      }

      if (team_focus_js_typeof(targetInfo) === ( true ? "undefined" : undefined)) {
        targetInfo = '.uix-team-focus__info';
      }

      total = $(el).length;
      TweenMax.set(el, {
        width: 100 / total + '%'
      }); //Add an index to each item

      $(el).each(function (index) {
        $(this).attr('data-index', index);
      }); //Create item hover overlay effects

      $(el).on('mouseenter', function () {
        var $cur = $(this),
            $neighbor = $cur.siblings().not('.focus'); //Get the siblings of each element in the set of matched elements

        TweenMax.to($cur, 0.3, {
          width: hoverWidth + '%'
        });
        TweenMax.to($neighbor, 0.3, {
          width: (100 - hoverWidth) / (total - 1) + '%'
        });
      }); //Display the target item

      $(document).off('click.TEAM_FOCUS').on('click.TEAM_FOCUS', el, function (e) {
        e.preventDefault();
        var $cur = $(this),
            $neighbor = $cur.siblings(),
            //Get the siblings of each element in the set of matched elements
        $cloneItem = $cur.clone(); //The mask prevent click and hover

        $(teamFocusMask).show();
        $(el).removeClass('is-active');
        $cur.addClass('is-active');
        var $info = $(targetInfo),
            cName = $cur.data('name'),
            cPo = $cur.data('po'),
            cIntro = $cur.data('intro');
        TweenMax.set($info, {
          css: {
            opacity: 0,
            display: 'none'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              css: {
                opacity: 1,
                display: 'block'
              }
            });
          }
        });
        $info.find('h4 strong').html(cName);
        $info.find('h4 em').html(cPo);
        $info.find('.uix-team-focus__info__text').html(cIntro);

        if (!$cur.hasClass('focus')) {
          $(el + '.focus').remove();
          TweenMax.set($cloneItem, {
            alpha: 0,
            onComplete: function onComplete() {
              this.target.prependTo('#' + thisID).addClass('focus');
            }
          });
          TweenMax.to(el, 0.3, {
            alpha: 1
          });
          TweenMax.to($cur, 0.3, {
            alpha: 0
          });
          TweenMax.to($neighbor, 0.3, {
            alpha: 0.3
          });
        }
      }); //Close the focus item

      $(document).off('click.TEAM_FOCUS_CLOSE').on('click.TEAM_FOCUS_CLOSE', el + '.focus, ' + closeBtn + ', ' + targetInfo + ', ' + teamFocusMask, function (e) {
        e.preventDefault(); //Remove the mask

        $(teamFocusMask).hide();
        TweenMax.to(el, 0.3, {
          width: 100 / total + '%',
          ease: Back.easeOut
        });
        TweenMax.to(el + '.focus', 0.3, {
          alpha: 0,
          onComplete: function onComplete() {
            $(el + '.focus').remove();
            TweenMax.to(el, 0.3, {
              alpha: 1
            });
          }
        });
        var $info = $(targetInfo);
        TweenMax.to($info, 0.5, {
          css: {
            opacity: 0,
            display: 'none'
          }
        });
        $info.find('h4 strong').html('');
        $info.find('h4 em').html('');
        $info.find('.uix-team-focus__info__text').html('');
      });
    });
  };

  module.components.documentReady.push(module.TEAM_FOCUS.documentReady);
  return function TEAM_FOCUS() {
    team_focus_js_classCallCheck(this, TEAM_FOCUS);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/text-effect/js/fn/text-anime.js
var text_anime = __webpack_require__(76);

// EXTERNAL MODULE: ./src/components/text-effect/scss/_style.scss
var text_effect_scss_style = __webpack_require__(77);

// CONCATENATED MODULE: ./src/components/text-effect/js/index.js
function text_effect_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Text effect -->
 *************************************
 */

/**
 * module.TEXT_EFFECT
 * 
 * @requires ./examples/assets/js/min/anime.min.js
 * @example 

 //The data-text-eff attribute on the same page cannot be duplicated.

<h3 data-text-eff="letters-eff-flyInOut1" data-text-eff-speed="800">Text Text</h3>
<h3 data-text-eff="letters-eff-flyInOut2" data-text-eff-speed="800">Text Text</h3>
<h3 data-text-eff="letters-eff-flyInOut3" data-text-eff-speed="800">Text Text</h3>
 
 */



var TEXT_EFFECT = function (module, $, window, document) {
  if (window.TEXT_EFFECT === null) return false;
  module.TEXT_EFFECT = module.TEXT_EFFECT || {};
  module.TEXT_EFFECT.version = '0.0.5';

  module.TEXT_EFFECT.pageLoaded = function () {
    $('[data-text-eff]').each(function (index) {
      $(document).UixTextEff({
        selectors: '[data-text-eff="' + $(this).data('text-eff') + '"]',
        scrollSpy: true
      });
    });
  };

  module.components.pageLoaded.push(module.TEXT_EFFECT.pageLoaded);
  return function TEXT_EFFECT() {
    text_effect_js_classCallCheck(this, TEXT_EFFECT);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/timeline/scss/_style.scss
var timeline_scss_style = __webpack_require__(78);

// CONCATENATED MODULE: ./src/components/timeline/js/index.js
function timeline_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function timeline_js_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { timeline_js_typeof = function _typeof(obj) { return typeof obj; }; } else { timeline_js_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return timeline_js_typeof(obj); }

/* 
 *************************************
 * <!-- Timeline -->
 *************************************
 */


var TIMELINE = function (module, $, window, document) {
  if (window.TIMELINE === null) return false;
  module.TIMELINE = module.TIMELINE || {};
  module.TIMELINE.version = '0.1.8';

  module.TIMELINE.pageLoaded = function () {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /*! 
     ---------------------------
           Horizontal Timeline
     ---------------------------
     */

    $('.uix-timeline__container-wrapper.js-uix-timeline').each(function () {
      var $this = $(this);
      var $container = $this.find('.uix-timeline__container'),
          $timeline = $container.find('> .uix-timeline');
      var dir = $this.hasClass('is-vertical') ? 'vertical' : 'horizontal';
      var dateShowEle = $timeline.data('show-ele');

      if (timeline_js_typeof(dateShowEle) === ( true ? "undefined" : undefined)) {
        dateShowEle = '#timeline-number-show';
      }

      $this.find('.uix-timeline__btn--prev').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, null, dateShowEle, true, dir);
        return false;
      });
      $this.find('.uix-timeline__btn--next').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, null, dateShowEle, false, dir);
        return false;
      });
      $this.find('.uix-timeline__item .uix-timeline__item__img').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, $(this).parent(), dateShowEle, false, dir);
        return false;
      }); //Activate the default selection

      timelineUpdate($this, $this.find('.uix-timeline__item.is-active'), dateShowEle, false, dir);

      if ($this.find('.uix-timeline__item.is-active').index() == 0) {
        $this.find('.uix-timeline__btn--prev').addClass('is-disabled');
      } // for reversed timeline


      if (dir == 'horizontal' && $this.hasClass('is-reversed') && windowWidth > 768) {
        // Set equal heights
        var setEqualHeights = function setEqualHeights(el) {
          var counter = 0;

          for (var i = 0; i < el.length; i++) {
            var singleHeight = $(el[i]).outerHeight(true);

            if (counter < singleHeight) {
              counter = singleHeight;
            }
          }

          for (var k = 0; k < el.length; k++) {
            $(el[k]).css('height', counter + 'px');
          }

          return counter;
        }; // Reset container height


        var infoNewHeight = setEqualHeights($timeline.find('.uix-timeline__item__info'));
        $container.css({
          'padding': parseFloat(infoNewHeight + 64) + 'px 0'
        });
      }
    });
    /*
     * Method that updates items of timeline
     *
     * @param  {Element} obj                 - Wrapper of timeline.
     * @param  {?Element} iscur              - The current item.
     * @param  {String} showEle              - Element ID or class name that push the current text.
     * @param  {Boolean} prev                - Whether to slide forward.
           * @param  {String} dir                  - Timeline direction.
     * @return {Void}
     */

    function timelineUpdate(obj, iscur, showEle, prev, dir) {
      var itemTotal = obj.find('.uix-timeline__item').length,
          tNav = obj.find('.uix-timeline__item'),
          tLoop = false;
      var curIndex = obj.find('.uix-timeline__item.is-active').index(),
          tarIndex; //Check if a value is an object currently

      if (iscur != null && timeline_js_typeof(iscur) === 'object') {
        curIndex = iscur.index();
        tarIndex = curIndex;
      } else {
        if (prev) {
          tarIndex = curIndex >= 0 ? curIndex - 1 : 0;
        } else {
          tarIndex = curIndex < itemTotal ? curIndex + 1 : itemTotal - 1;
        }
      } //loop the items


      obj.find('.uix-timeline__btn--prev, .uix-timeline__btn--next').removeClass('is-disabled');

      if (prev) {
        //Previous
        if (tLoop) {
          if (tarIndex < 0) tarIndex = itemTotal - 1;
        } else {
          if (tarIndex < 0) tarIndex = 0;
          if (tarIndex == 0) obj.find('.uix-timeline__btn--prev').addClass('is-disabled');
        }
      } else {
        //Next
        if (tLoop) {
          if (tarIndex == itemTotal) tarIndex = 0;
        } else {
          if (tarIndex > itemTotal - 1) tarIndex = itemTotal - 1;
          if (tarIndex > itemTotal - 2) obj.find('.uix-timeline__btn--next').addClass('is-disabled');
          if (tarIndex == 0) obj.find('.uix-timeline__btn--prev').addClass('is-disabled');
        }
      }

      tNav.removeClass('is-active');
      obj.find('.uix-timeline__item:eq(' + tarIndex + ')').addClass('is-active'); //scroll left

      if (dir == 'horizontal') {
        var moveWidth = 0;

        for (var i = 0; i < tarIndex; i++) {
          moveWidth += obj.find('.uix-timeline__item:eq(' + i + ')').width();
        }

        obj.find('.uix-timeline__container > .uix-timeline').css({
          'margin-left': -parseFloat(moveWidth) + 'px'
        });
      } //scroll top


      if (dir == 'vertical') {
        var moveHeight = 0;

        for (var _i = 0; _i < tarIndex; _i++) {
          moveHeight += obj.find('.uix-timeline__item:eq(' + _i + ')').outerHeight(true);
        }

        obj.find('.uix-timeline__container > .uix-timeline').css({
          'margin-top': -parseFloat(moveHeight) + 'px'
        });
      } //Push the current text to element 


      $(showEle).text(obj.find('.uix-timeline__item:eq(' + tarIndex + ')').find('.uix-timeline__item__date').text());
    }
  };

  module.components.pageLoaded.push(module.TIMELINE.pageLoaded);
  return function TIMELINE() {
    timeline_js_classCallCheck(this, TIMELINE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/vertical-menu/scss/_style.scss
var vertical_menu_scss_style = __webpack_require__(79);

// CONCATENATED MODULE: ./src/components/vertical-menu/js/index.js
function vertical_menu_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- Vertical Menu -->
 *************************************
 */


var VERTICAL_MENU = function (module, $, window, document) {
  if (window.VERTICAL_MENU === null) return false;
  module.VERTICAL_MENU = module.VERTICAL_MENU || {};
  module.VERTICAL_MENU.version = '0.0.5';

  module.VERTICAL_MENU.documentReady = function ($) {
    var $window = $(window);
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var ulForDesktop = '.uix-v-menu__container:not(.is-mobile) ul.uix-menu'; // Menu Hover

    var mTop = 15;
    $(ulForDesktop + ' > li.multi-column > ul li ul').addClass('multi');
    $(ulForDesktop + ' > li:not(.multi-column) ul, .uix-v-menu__container:not(.is-mobile) li.multi-column > ul.sub-menu > li > ul, ' + ulForDesktop + ' li.multi-column > ul').css('margin-top', mTop + 'px');
    $(ulForDesktop + ' li').on('mouseenter', function () {
      TweenMax.set($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), {
        css: {
          opacity: 0,
          display: 'block',
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.3, {
            css: {
              opacity: 1,
              marginTop: 0
            },
            ease: Power2.easeOut
          });
        }
      }); //Calculate whether the total width of a large navigation is greater than the window

      var megaMenuW = $(ulForDesktop + ' > li.multi-column > ul').width(),
          megaMaxW = parseFloat(windowWidth - $(ulForDesktop).parent().width()),
          megaMenuCoLength = $(ulForDesktop + ' > li.multi-column > ul > li').length;

      if (megaMenuW > megaMaxW) {
        $(ulForDesktop + ' > li.multi-column > ul > li').css('width', megaMaxW / megaMenuCoLength + 'px');
      }
    }).on('mouseleave', function () {
      TweenMax.to($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), 0.3, {
        css: {
          opacity: 0,
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              display: 'none'
            }
          });
        }
      });
    }); //Add Sub-menu Arrow

    $(ulForDesktop + ' li').each(function () {
      if ($(this).find('ul').length > 0) {
        $(this).prepend('<span class="uix-menu__arrow"></span>');
      }
    }); //Monitor the maximum height of the vertical navigation

    menuWrapInit(windowWidth, windowHeight);
    $window.on('resize', function () {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight; // Do stuff here

        menuWrapInit(windowWidth, windowHeight);
      }
    });
    /*
     * Monitor the maximum height of the vertical navigation
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function menuWrapInit(w, h) {
      var $menuWrap = $('.uix-v-menu__container:not(.is-mobile)'),
          vMenuTop = 0; //This value is equal to the $vertical-menu-top variable in the SCSS

      var winHeight = h - vMenuTop; //WoedPress spy

      if ($('.admin-bar').length > 0) {
        winHeight = h - 132;
      }

      $menuWrap.css({
        position: 'fixed',
        height: winHeight + 'px',
        marginTop: 0
      });
      $window.off('scroll.VERTICAL_MENU touchmove.VERTICAL_MENU').on('scroll.VERTICAL_MENU touchmove.VERTICAL_MENU', function () {
        var curULHeight = $('ul.uix-menu').height(),
            scrolled = $(this).scrollTop();

        if (curULHeight > winHeight) {
          $menuWrap.css({
            position: 'absolute',
            height: curULHeight + 'px'
          });

          if (scrolled >= curULHeight - winHeight) {
            $menuWrap.css({
              position: 'fixed',
              marginTop: -(curULHeight - winHeight) + 'px'
            });
          } else {
            $menuWrap.css({
              position: 'absolute',
              marginTop: 0
            });
          }
        }

        if ($menuWrap.height() < winHeight) {
          $menuWrap.css({
            position: 'fixed',
            height: winHeight + 'px',
            marginTop: 0
          });
        }
      });
    }
  };

  module.components.documentReady.push(module.VERTICAL_MENU.documentReady);
  return function VERTICAL_MENU() {
    vertical_menu_js_classCallCheck(this, VERTICAL_MENU);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/wordpress/scss/_wp_core.scss
var _wp_core = __webpack_require__(80);

// EXTERNAL MODULE: ./src/components/wordpress/scss/_3rd_party_plugins.scss
var _3rd_party_plugins = __webpack_require__(81);

// CONCATENATED MODULE: ./src/components/wordpress/js/index.js
function wordpress_js_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* 
 *************************************
 * <!-- WordPress Core Scripts -->
 *************************************
 */



var WP_CORE = function (module, $, window, document) {
  if (window.WP_CORE === null) return false;
  module.WP_CORE = module.WP_CORE || {};
  module.WP_CORE.version = '0.0.1';

  module.WP_CORE.documentReady = function ($) {
    /* 
     ---------------------------
     Pagination
     ---------------------------
     */
    $('.uix-pagination__container li > span.current').each(function () {
      $(this).parent('li').addClass('is-active');
    });
    /* 
     ---------------------------
     Dropdown Categories
     ---------------------------
     */

    $('#cat').on('change', function () {
      var cvalue = $(this).val();

      if (cvalue) {
        location.href = homeUrl + "/?cat=" + cvalue;
      }

      return false;
    });
  };

  module.components.documentReady.push(module.WP_CORE.documentReady);
  return function WP_CORE() {
    wordpress_js_classCallCheck(this, WP_CORE);

    this.module = module;
  };
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/badges/scss/_style.scss
var badges_scss_style = __webpack_require__(82);

// EXTERNAL MODULE: ./src/components/blended-grid-layout/scss/_style.scss
var blended_grid_layout_scss_style = __webpack_require__(83);

// EXTERNAL MODULE: ./src/components/breadcrumbs/scss/_style.scss
var breadcrumbs_scss_style = __webpack_require__(84);

// EXTERNAL MODULE: ./src/components/button/scss/_style.scss
var button_scss_style = __webpack_require__(85);

// EXTERNAL MODULE: ./src/components/card/scss/_style.scss
var card_scss_style = __webpack_require__(86);

// EXTERNAL MODULE: ./src/components/circle-text/scss/_style.scss
var circle_text_scss_style = __webpack_require__(87);

// EXTERNAL MODULE: ./src/components/coach-mark/scss/_style.scss
var coach_mark_scss_style = __webpack_require__(88);

// EXTERNAL MODULE: ./src/components/content-placeholder-animated/scss/_style.scss
var content_placeholder_animated_scss_style = __webpack_require__(89);

// EXTERNAL MODULE: ./src/components/dividing-line/scss/_style.scss
var dividing_line_scss_style = __webpack_require__(90);

// EXTERNAL MODULE: ./src/components/dotted-line/scss/_style.scss
var dotted_line_scss_style = __webpack_require__(91);

// EXTERNAL MODULE: ./src/components/equal-width-columns/scss/_style.scss
var equal_width_columns_scss_style = __webpack_require__(92);

// EXTERNAL MODULE: ./src/components/features/scss/_style.scss
var features_scss_style = __webpack_require__(93);

// EXTERNAL MODULE: ./src/components/footer-templates/scss/_style.scss
var footer_templates_scss_style = __webpack_require__(94);

// EXTERNAL MODULE: ./src/components/gallery-grid-layout/scss/_style.scss
var gallery_grid_layout_scss_style = __webpack_require__(95);

// EXTERNAL MODULE: ./src/components/heading/scss/_style.scss
var heading_scss_style = __webpack_require__(96);

// EXTERNAL MODULE: ./src/components/image-animation/scss/_style.scss
var image_animation_scss_style = __webpack_require__(97);

// EXTERNAL MODULE: ./src/components/list-brands/scss/_style.scss
var list_brands_scss_style = __webpack_require__(98);

// EXTERNAL MODULE: ./src/components/list-maintain-aspect-ratio/scss/_style.scss
var list_maintain_aspect_ratio_scss_style = __webpack_require__(99);

// EXTERNAL MODULE: ./src/components/list-side-by-side/scss/_style.scss
var list_side_by_side_scss_style = __webpack_require__(100);

// EXTERNAL MODULE: ./src/components/list-side-by-side-img/scss/_style.scss
var list_side_by_side_img_scss_style = __webpack_require__(101);

// EXTERNAL MODULE: ./src/components/mouse-animation-scroll/scss/_style.scss
var mouse_animation_scroll_scss_style = __webpack_require__(102);

// EXTERNAL MODULE: ./src/components/overlay/scss/_style.scss
var overlay_scss_style = __webpack_require__(103);

// EXTERNAL MODULE: ./src/components/ribbon/scss/_style.scss
var ribbon_scss_style = __webpack_require__(104);

// EXTERNAL MODULE: ./src/components/separator-of-rule-with-text/scss/_style.scss
var separator_of_rule_with_text_scss_style = __webpack_require__(105);

// EXTERNAL MODULE: ./src/components/shape-animation/scss/_style.scss
var shape_animation_scss_style = __webpack_require__(106);

// EXTERNAL MODULE: ./src/components/single-post/scss/_comments.scss
var _comments = __webpack_require__(107);

// EXTERNAL MODULE: ./src/components/single-post/scss/_editing.scss
var _editing = __webpack_require__(108);

// EXTERNAL MODULE: ./src/components/striking/scss/_style.scss
var striking_scss_style = __webpack_require__(109);

// EXTERNAL MODULE: ./src/components/team-fullwidth/scss/_style.scss
var team_fullwidth_scss_style = __webpack_require__(110);

// EXTERNAL MODULE: ./src/components/team-grid/scss/_style.scss
var team_grid_scss_style = __webpack_require__(111);

// EXTERNAL MODULE: ./src/components/testimonials/scss/_style.scss
var testimonials_scss_style = __webpack_require__(112);

// EXTERNAL MODULE: ./src/components/tooltip/scss/_style.scss
var tooltip_scss_style = __webpack_require__(113);

// EXTERNAL MODULE: ./src/components/wave-background/scss/_style.scss
var wave_background_scss_style = __webpack_require__(114);

// CONCATENATED MODULE: ./src/components/_app-load.js
/*
 * Common website functions, Can be called separately in HTML pages or custom JavaScript.
 *    
 */



/*
 * Import modules from components
 *    
 */

/******/

/******/

/* base */

/* Note: The CSS style file has been included by JavaScript files */










/******/

/******/

/* pages */

/* Note: The CSS style file has been included by JavaScript files */














































































/******/

/******/

/* pages */

/* Note: These modules do not contain JavaScript */


































// CONCATENATED MODULE: ./src/index.js
/*
 * Import modules from components of ES6
 * 
 *        
 */


/***/ })
/******/ ]);
//# sourceMappingURL=../css/uix-kit.css.map
//# sourceMappingURL=uix-kit.js.map